---
title: Sequencer
sidebar_position: 11
image: /img/socialCards/sequencer.jpg
---

## What is it?

The sequencer is the heart of Linea's execution client, responsible for ordering, building, and executing blocks in a way that allows the subsequent zero-knowledge proof to be made. 

The sequencer is not directly accessible from outside the network (to prevent DDOS attacks). Instead itâ€™s connected to the RPC nodes via P2P.

## What does it do?

The sequencer: 

- Receives transactions from the network
- Orders and validates transactions
- Builds blocks according to Linea's rules
- Enforces transaction limits (trace counts, gas limits, calldata size)
- Ensures blocks fit within blob size constraints
- Executes those blocks 
- Prepares certain data relating to the _traces_ of that execution for the zero-knowledge prover

## How does it do it?

The sequencer is a set of plugins that extends Linea's execution client [Linea Besu](https://github.com/Consensys/linea-besu). This implementation of the Besu execution client provides additional functionality to support
Linea and its requirements as a zero-knowledge rollup. 

Linea's sequencer takes transactions from the Linea memory pool, and builds them into blocks. Furthermore, it provides data to the [coordinator](../coordinator.mdx), to ensure that 
blocks are made in such a way that they can be proven by the zero-knowledge prover, and that they 
are as compact as possible--doubly important in a situation where all data has to be written in 
tiny, costly pieces on Ethereum Mainnet. This is done specifically by subsystems within the 
sequencer: the [traces generator](./traces-generator.mdx) and [conflator](./conflation.mdx).

:::info

There is typically one sequencer instance per network. Although by applying a Quorum-Based Byzantine Fault Tolerance (QBFT) design, Linea could adopt multiple sequencers in a decentralized configuration.

:::





