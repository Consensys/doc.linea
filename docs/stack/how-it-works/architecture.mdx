---
title: Architecture
description: Architecture of The Linea stack components and their interactions
sidebar_position: 2
mainSource:
  url: 'https://github.com/Consensys/linea-monorepo'
image: /img/socialCards/architecture.jpg
---

The Linea stack uses a dual-layer architecture with separate consensus and execution layers. This design
enables modular deployment, client diversity, and operational flexibility.

## Dual-layer architecture

The Linea stack separates consensus from execution:

- **Consensus layer ([Maru](/protocol/repos#maru))**: Handles block production, consensus, and block
  validation
- **Execution layer ([Linea Besu](/protocol/repos#linea-besu-upstream), [Geth](/network/how-to/run-a-node/geth), or [Erigon](/network/how-to/run-a-node/erigon))**: Executes transactions and maintains state

The layers communicate via the Engine API, a standard Ethereum interface that cleanly separates
consensus from execution.

## Core components

### Consensus layer: Maru

[Maru](/protocol/repos#maru) is Linea's consensus layer client implementing the Quorum Byzantine
Fault Tolerance (QBFT) consensus algorithm. It:

- Coordinates block production with the execution layer
- Manages validator sets and consensus participation
- Provides P2P networking for block propagation
- Exposes REST API endpoints for monitoring and control

Maru requires a minimum of 4 nodes for QBFT consensus to ensure fault tolerance (3f+1 where f is the
number of faulty nodes).

### Execution layer clients

You can choose from multiple execution layer clients:

- **Linea Besu**: Recommended for operators. Includes Linea-specific plugins enabling features like
  `linea_estimateGas` and sequencer functionality
- **Geth**: Standard Ethereum client, suitable for following the chain
- **Erigon**: Optimized for archive nodes and historical data access

All execution clients maintain the EVM state and execute transactions, but only Linea Besu provides
full Linea-specific functionality.

### Sequencer

The [sequencer](/protocol/sequencer) is a specialized execution layer node (Linea Besu with sequencer
plugins) responsible for:

- Receiving transactions from the network
- Ordering and validating transactions
- Building blocks according to Linea's rules
- Enforcing transaction limits (trace counts, gas limits, calldata size)
- Ensuring blocks fit within blob size constraints

There is typically one sequencer instance per network, though QBFT allows for multiple sequencers
in a decentralized configuration.

### Coordinator

The [coordinator](/protocol/coordinator) orchestrates the proof generation and finalization process:

- **Batching**: Groups multiple blocks into batches for efficient proof generation
- **Blob creation**: Combines batches into blobs for submission to the finalization layer
- **Proof orchestration**: Coordinates execution proofs, compression proofs, and aggregation proofs
- **L1 submission**: Submits proofs and data to the finalization layer (Ethereum or Linea Mainnet)

The coordinator monitors block production, manages conflation deadlines, and ensures all required
data is available before requesting proofs.

### Prover

The [prover](/protocol/prover) generates zero-knowledge proofs that verify state transitions:

- **Execution proofs**: Prove the correctness of transaction execution within batches
- **Compression proofs**: Prove that blob compression is valid
- **Aggregation proofs**: Combine multiple proofs into a single finalization proof

Proof generation is computationally intensive and may be distributed across multiple prover
instances for performance.

### State Manager

The [state manager](/protocol/state-manager) maintains Linea's state representation optimized for
proof generation:

- Tracks state changes block by block
- Generates Merkle proofs for state transitions
- Provides state snapshots for recovery and initialization
- Serves `linea_getProof` RPC endpoints

The state manager consists of a Besu node with [Shomei](/protocol/repos#shomei) plugin and a Shomei
node that uses Sparse Merkle trees to represent state.

### Tracer

The [tracer](/protocol/repos#linea-tracer) is a Linea Besu plugin that:

- Generates execution traces during block processing
- Provides trace counts for batch size calculations
- Creates conflated trace files for prover input

Trace data is essential for proof generation and must be available for all blocks in a batch.

## Transaction lifecycle

The transaction lifecycle describes how transactions flow through The Linea stack from submission to
finalization. For detailed protocol-level information, see [Transaction lifecycle](/protocol/transaction-lifecycle).

1. **Submission**: Transactions enter the mempool via RPC nodes.
2. **Block building**: [Sequencer](/protocol/sequencer) orders and executes transactions into blocks.
3. **State tracking**: [State manager](/protocol/state-manager) updates state representation;
   [tracer](/protocol/repos#linea-tracer) generates traces.
4. **Conflation**: [Coordinator](/protocol/coordinator) groups blocks into batches.
5. **Proof generation**: [Prover](/protocol/prover) generates execution proofs for batches.
6. **Blob creation**: [Coordinator](/protocol/coordinator) combines batches into blobs; [prover](/protocol/prover) generates compression proofs.
7. **Finalization**: [Coordinator](/protocol/coordinator) submits proofs to finalization layer; after
   verification and epoch delay, transactions reach hard finality.

## Network topology

### Full nodes

Full nodes maintain complete network state and participate in consensus:

- Verify all blocks and transactions
- Serve RPC requests
- Participate in P2P networking
- May serve as validators in QBFT consensus

### RPC nodes

RPC nodes provide API access to the network:

- **Near-head nodes**: Optimized for low-latency access to recent state
- **Archive nodes**: Maintain complete historical state for auditing and analysis

RPC nodes may be deployed behind load balancers and access controls (RBAC) for private networks.

### Internal protocol services

These services are not directly accessible from outside the network:

- Sequencer (protected from DDoS)
- Coordinator
- Prover
- State Manager

They communicate via internal networks and file systems.

## Data availability

Data availability strategy depends on your deployment model:

- **Private Validium**: Data stored off-chain with private node set; no on-chain data posting
- **Hybrid**: Selective data availability based on transaction type
- **Public**: Data posted to finalization layer using EIP-4844 blobs

For details on data availability, finalization layers, and L2/L3 relationships, see [Data
availability and finalization](/stack/how-it-works/data-availability-finalization).

## Related documentation

- [Protocol Architecture](/protocol/architecture): Protocol-level details of how Linea works
- [Transaction lifecycle](/protocol/transaction-lifecycle): Detailed protocol-level view of how
  transactions flow through the system
- [Deployment Models](/stack/how-it-works/deployment-models): How architecture differs by deployment
  model
- [Boundaries & Responsibilities](/stack/how-it-works/boundaries-responsibilities): Component
  responsibilities and failure modes
