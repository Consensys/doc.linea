==================== FILE: /workspace/docs/release-notes.mdx ====================

---
title: Release notes
description: Find out all you need to know about the latest Linea versions.
sidebar_position: 4
image: /img/socialCards/release-notes.jpg
---

import CodeBlock from "@theme/CodeBlock";
import zkEVM2 from "!!raw-loader!/files/testnet/2023-06-13-release/zkEVM2.abi";
import L2MessageService from "!!raw-loader!/files/testnet/2023-06-13-release/L2MessageService.abi";
import TokenBridgeL1 from "!!raw-loader!/files/testnet/2023-06-13-release/TokenBridgeL1.abi";
import TokenBridgeL2 from "!!raw-loader!/files/testnet/2023-06-13-release/TokenBridgeL2.abi";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

## Beta v4.1

**Linea Mainnet: late October 2025** (target)

**Linea Sepolia: mid-October 2025** (target)

- Boost prover performance to support scaled trading, consumer, and institutional use cases.
- Activate EIP-7702 support.

## Beta v4

**Linea Mainnet: October 2025** (TBC)

**Linea Sepolia:**
- Paris: 24 September, 2025
- Shanghai: 29 September, 2025
- Cancun: 30 September, 2025

The Prague upgrade will occur on Linea Sepolia in early October (TBC).

- Implement Pectra hardfork on Linea (including all EVM upgrades since London), achieving full 
  EVM-equivalence. The upgrade will occur in stages, progressing through hard forks.
  - Note: EIP-7702 will only be activated in [Beta v4.1](#beta-v41)
  - These upgrades will add support for additional opcodes and precompiles, detailed on our [Ethereum
    differences page](./get-started/build/ethereum-differences.mdx).
- Add a new consensus client, Maru, replacing the existing Proof-of-Authority sequencer mechanism,
  Clique. Maru introduces a QBFT consensus mechanism, and will support Linea's future transition
  to decentralized sequencing. Initially only a single Maru node operated by Linea will produce
  blocks.

## Beta v3.1

**Linea Mainnet: early/mid-August 2025** (target)

**Linea Sepolia: late July 2025** (target)

- Remove sequencer limits. These are no longer required because of the limitless prover introduced in
  Beta v3.
- Increase throughput

## Beta v3

**Linea Mainnet: early August 2025** (target)

**Linea Sepolia: late July 2025** (target)

- **Limitless prover**: Eliminates the need for the sequencer to enforce module limits, as the prover 
can handle complex workloads. This unlocks:
  - Higher throughput and TPS
  - Stabler gas fees during high-traffic periods
  - Faster transaction confirmation during activity peaks.

Note that the higher throughput will not enabled until the sequencer limits are removed in [Beta v3.1](#beta-v31).

## Beta v2

**Linea Mainnet: June 9, 2025**

**Linea Sepolia: mid/late May 2025**

- **100% proven**: 100% of EVM operations will be covered by our zero-knowledge proofs, guaranteeing
the integrity of all onchain data when sequencing is decentralized. Linea is the first zkEVM
to be completely proven.
- Reworks [prover limits](./technology/prover/prover-limits.mdx) to reduce infrastructure costs and 
reduce instances of transactions reverting due to exceeding limits.
- Upgrades the dictionary to improve compression and reduce the costs of L1 data availability by 
7.5%.
- Improves Security Council configuration, and onboards the first cohort of members to stage 1, 
supporting future decentralization and security. 

## Beta v1

Beta v1 on Linea introduces new arithmetization. The overall objective of the Linea Beta is to prove 
100% of the zkEVM specification, an objective currently scheduled to be completed in Beta v2.

### Beta v1.4

**Linea Mainnet: April 28, 2025** 

**Linea Sepolia: April 7, 2025**

- Adds the [`eth_sendBundle` RPC method](./api/reference/eth-sendbundle.mdx), enabling apps to 
protect users against MEV and improve UX in various ways.
- Introduces [state recovery](./get-started/how-to/state-recovery.mdx), enabling anyone to recover 
and audit Linea state, reducing the risk of having a centralized sequencer.

### Beta v1.3

**Linea Mainnet: March 3, 2025**

**Linea Sepolia: February 18, 2025**

- Raises the block gas limit to 2B.

### Beta v1.2

**Linea Mainnet: with Beta v2**

**Linea Sepolia: February 4, 2025**

- Full implementation of new arithmetization, with all modules from the Linea specification except 
the hub's consistency arguments. 
- Proof of all the activated modules (i.e. excluding the hub consistency arguments).

### Beta v1.1

**Linea Mainnet: with Beta v2**

**Linea Sepolia: September 26, 2024**

- New arithmetization, with selected modules activated from the [Linea specification](https://github.com/Consensys/linea-specification).
- The transition to generating traces with Besu. 

## Alpha v4.2

**Mainnet: March 26, 2025**

**Linea Sepolia: March 18, 2025**

- Improvements to the Linea bridge: 
  - New UI for improved user experience 
  - Update Linea native bridge to use the [Circle CCTP](https://circle.com/cross-chain-transfer-protocol) 
  for USDC transfers
  - Add new bridging aggregators for faster transfers and greater chain selection
  - Integrate [Onramper](https://onramper.com/) for seamless fiat onramping to Linea only (live on 
  April 3)
- Transition to native USDC, seamless for Linea users 

## Alpha v4.1

**Mainnet: February 4, 2025**

**Linea Sepolia: January 28, 2025**

- Add automatic claiming for L1 &rarr; L2 bridging on the Linea native bridge.
- Introduces the [Linea Token API](./api/token-api/overview.mdx) at alpha stage.

## Alpha v4

**Mainnet: December 16, 2024**

**Linea Sepolia: November 27, 2024**

This update upgrades several key contracts. Some updates prepare the protocol for the ability to 
reconstruct the Linea state, while others add granularity to available roles, better preparing them
for any required pauses. Many of the contract modifications have also resulted in gas optimizations.

Additionally, we are removing the `finalizeBlocksWithoutProof` function, and adding functionality
that enables any address to send blob submission and finalization transactions through a call 
forwarding contract if no finalization occurs for more than six months. This effectively allows L1 
finalization, enabling withdrawal of potentially locked funds. 

Code in the upgrade has been audited by:
- OpenZeppelin, whose report is available [here](https://blog.openzeppelin.com/linearollup-and-tokenbridge-role-upgrade),
- Diligence, whose report is available [here](https://diligence.consensys.io/audits/2024/12/linea-rollup-update/), and;
- Cyfrin, whose report is [here](https://github.com/Cyfrin/cyfrin-audit-reports/blob/642b409c207d0e31679467480c3d9b8797b98696/reports/2025-01-06-cyfrin-linea-v2.2.pdf).

Changes in this release:
- Adjust blob submission and finalization events to be state reconstruction-compatible
  - This is a breaking change for the event structures. The new structures are below:
  ```solidity
  /**
   * @notice Emitted when compressed data is being submitted and verified successfully on L1.
   * @dev The block range is indexed and parent shnarf included for state reconstruction simplicity.
   * @param parentShnarf The parent shnarf for the data being submitted.
   * @param shnarf The indexed shnarf for the data being submitted.
   * @param finalStateRootHash The L2 state root hash that the current blob submission ends on. NB: The last blob in the collection.
   */
  event DataSubmittedV3(bytes32 parentShnarf, bytes32 indexed shnarf, bytes32 finalStateRootHash);

  /**
   * @notice Emitted when L2 blocks have been finalized on L1.
   * @param startBlockNumber The indexed L2 block number indicating which block the finalization the data starts from.
   * @param endBlockNumber The indexed L2 block number indicating which block the finalization the data ends on.
   * @param shnarf The indexed shnarf being set as currentFinalizedShnarf in the current finalization.
   * @param parentStateRootHash The parent L2 state root hash that the current finalization starts from.
   * @param finalStateRootHash The L2 state root hash that the current finalization ends on.
   */
  event DataFinalizedV3(
    uint256 indexed startBlockNumber,
    uint256 indexed endBlockNumber,
    bytes32 indexed shnarf,
    bytes32 parentStateRootHash,
    bytes32 finalStateRootHash
  );
  ```
  - `DataSubmittedV2` becomes `DataSubmittedV3`, `DataFinalized` becomes `DataFinalizedV3`
  (`DataFinalizedV2` was skipped to align version numbers).
  - The change also introduced gas optimizations for blob submission and finalization. 
- Create granular roles for contracts `LineaRollup`, `L2MessageService` and `TokenBridge`:
  - `LineaRollup`: Introduce more granular pausing and an additional verifier unsetting role 
  - `L2MessageService`: Introduce more granular pausing
  - `TokenBridge`: Previously, all administration functions were managed by a single owner (multisig) 
  role. The update adds role-based access with more granular roles per function, particularly for 
  pausing.
- Remove `finalizeBlocksWithoutProof` function
  - The function enabled finalization without proofs. This allowed network activity to continue 
  while fundamental changes, such as changing the state management hashing mechanism, were being 
  made. This is the only time the function was used, and it was primarily retained as a contingency.
- Allow any address to finalize blocks if no finalization has occurred in the last six months
  - Add functionality to the `LineaRollup` contract to allow any address to submit valid blobs and 
  valid finalization proofs, generated by running the Linea stack locally, to withdraw funds from 
  L2. The mechanism only works if no finalization has happened for six months. The system is 
  intended as a contingency. 
  - The change enables the `LineaRollup` contract to grant a "fallback operator" the `OPERATOR_ROLE` 
  required to submit the blobs and finalization proofs. The "fallback operator" is a message 
  forwarding contract enabling any address to submit this data.
- Bump L1 Solidity version to v0.8.26. Introduces slight gas optimizations.
- Optimize message and new token creation hashing, making it slightly cheaper to send and claim 
messages.
- Address non-critical findings from previous audit rounds
- Generally clean up error management and interfaces.

## Alpha v3.6 

### Block size changes

**Mainnet: September 25**

**Linea Sepolia: September 25**

Increase block limit to 30M units of gas. The transaction limit remains at 24M. Block time also 
remains the same, at 2 seconds.

## Alpha v3.5.2

### Transaction exclusion API

**Mainnet: September 23**

**Linea Sepolia: September 18**

Introduces an API that can be used to check whether a transaction was rejected because it exceeded
the sequencer's trace limits.

## Alpha v3.5.1

### Linea native bridge UI v2 

**Mainnet: September 18**

**Linea Sepolia: September 18**

Upgrades the [Linea bridge](https://linea.build/hub/bridge/) UI.  

## Alpha v3.5.0

### `finalized` tag

**Mainnet: October 9**

**Linea Sepolia: September 17**

Adds support for the `finalized` tag to the `blockParameters` strings that can be used in various
JSON-RPC API calls. The tag enables you to confirm whether or not a block has been finalized on L1.
See our [guide](../docs/get-started/how-to/finalized-block.mdx) for more.

## Alpha v3.4.1

### Reactivate `linea_estimateGas`

**Mainnet: September 30**

**Linea Sepolia: September 9**

Reactivates [`linea_estimateGas`](../docs/api/reference/linea-estimategas.mdx), disabling compatibility 
mode. 

## Alpha v3.4

**Mainnet and Testnet: July 30**

### ENS on Linea

Adds support for Linea Names domains, including a frontend app for users to register and manage their
domains. The Linea Names system is comparable to ENS on Ethereum Mainnet, except that domains are 
limited to one per account and registering requires completion of [Proof of Humanity](https://poh.linea.build/).
As the system leverages CCIP Read, which enables L1 to trustlessly query the Linea Names registry 
through an offchain gateway, Linea Names domains resolve on L1. 

Read more about ENS in the user guide [here](https://support.linea.build/general/ens).

### CCIP Read

One of the building blocks of ENS on Linea is a custom implementation of CCIP Read, which uses the
gateway system introduced in EIP-3668 to enable Linea Names domains to resolve on L1. The key 
contracts created by ENS have been adjusted by the Linea team to ensure they work with Linea's
Sparse Merkle Tree system. 

The CCIP Read functionality can be applied to any context where a L1 protocol may benefit from 
securely querying data on Linea. See our [page on CCIP Read](../docs/get-started/tooling/cross-chain/ccip-read.mdx) 
for more information and guidance on how to use the relevant contracts.

The Linea repository containing the relevant contracts is [here](https://github.com/Consensys/linea-ens).

Consensys Diligence carried out an audit on Linea Names, available [here](https://consensys.io/diligence/audits/2024/06/linea-ens/).

### `linea_estimateGas` mainnet activation

:::note

Available on Linea Sepolia on July 31; available on Mainnet from August 1.

:::

Activates the `linea_estimateGas` endpoint for use on Mainnet in compatibility mode. 

See our [reference page](../docs/api/reference/linea-estimategas.mdx) for more information and usage.

## Alpha v3.3

**Testnet: June 3**

**Mainnet: June 11, 10:00 UTC**

### Breaking change: block time and block size reduction

Reducing block time to 2 seconds, with a target block size of 24M gas.

The change will increase transaction throughput by approximately 20%, improving user experience by 
making Linea faster and more responsive.

:::warning[Actions recommended for node runners]

We recommend you adjust your node configurations to ensure any submitted transactions are handled 
in line with the sequencer.

**Besu:**

In the `besu-sequencer` plugin, adjust:
- `plugin-linea-max-tx-gas-limit` to `24000000`
- `plugin-linea-max-block-gas` to `24000000`

**Geth:**

- In the config `.toml` file, set `[Eth]RPCGasCap` to `24000000`
  - Or use `—-rpc.gascap` in the command line, again specifying `24000000`

:::

## Alpha v3.2

**Testnet: May 28**

**Mainnet: June 4**

### Smart contract gas optimization

Upgraded smart contracts to achieve gas optimizations in several areas:
- Major gas optimizations in blob submission, primarily in [`LineaRollup.sol`](https://github.com/Consensys/linea-contracts/blob/main/contracts/LineaRollup.sol)
- Finalization
- The token bridge. 

The upgrade commit is available [here](https://github.com/Consensys/linea-contracts/releases/tag/contract-audit-2024-05-24). 

Code in the upgrade has been audited by:
- OpenZeppelin, whose report is available [here](https://blog.openzeppelin.com/linea-gas-optimizations-audit), and;
- Cyfrin, whose report is [here](https://github.com/Cyfrin/cyfrin-audit-reports/blob/main/reports/2024-05-24-cyfrin-linea-v2.0.pdf).

### Bridge to a different recipient

:::note

May 29: Fully functional on testnet; ETH and USDC supported on mainnet.

June 4: Fully functional on mainnet.

::: 

The [Linea bridge](https://linea.build/hub/bridge/) has been upgraded to enable recipient addresses to
always be able to claim bridged funds. Bridge transfers to alternative recipients (i.e. an address
that isn't the sender's address) now appear on the recipient's "Recent transactions" list, 
enabling them to claim.

These changes have been audited by [OpenZeppelin](https://blog.openzeppelin.com/linea-gas-optimizations-audit)
and [Cyfrin](https://github.com/Cyfrin/cyfrin-audit-reports/blob/main/reports/2024-05-24-cyfrin-linea-v2.0.pdf). 

## Alpha v3.1

**Mainnet: May 14**

- Introduces dynamic L1 Gwei thresholds for submitting data to L1 for finalization.
- Adds the [`eth_sendRawTransaction`](../docs/api/reference/eth-sendrawtransaction.mdx) method, 
available only via Besu endpoints.

## Alpha v3

### Summary

The main objective of Alpha v3 is to implement EIP-4844 on Linea, following its introduction to 
Ethereum mainnet with the Dencun upgrade on March 13.

### Features

**March 26: EIP-4844**

Begin using blobs to post compressed L2 data to L1, with the aim of reducing data availability
costs. Blobs represent a transient data storage mechanism and an alternative to `calldata`, and
can be significantly cheaper in L1 ETH costs depending on market demand.

<details>
  <summary>Learn more about EIP-4844</summary>

    EIP-4844's arrival on Ethereum Mainnet enabled Ethereum L2s to start using a new transaction type 
    that transports L2 transaction and messaging data to L1 in "blobs". Blobs are a considerably 
    more cost-efficient alternative to the existing method of posting L2 transaction and messaging data 
    to L1, which involves sending `calldata` embedded in a transaction.

    With Alpha v3, L2 transaction data is added to blobs. The savings generated by using blobs rather 
    than `calldata` mainly derive from avoiding the highly competitive L1 gas fee market.

    Since transactions containing `calldata` have to compete with regular L1 transactions for 
    block space, L2s are vulnerable to L1 network congestion and the fee spikes it can generate. 
    Before the transition to using blobs, L1 data availability—i.e. the cost of posting data to L1 
    in `calldata`—made up more than 95% of the gas costs on Linea.

    Conversely, blobs have their own fee market, completely separate to the regular gas fee market on 
    L1. As a result, L2s like Linea now have an alternative to paying regular gas fees, and can 
    instead compete for blob space. 

    Due to having an entirely new market designed for L2 data availability, the cost of using blobs 
    will be a fraction of the cost of using `calldata`.
</details>

L1 and L2 smart contracts have been updated and deployed for Alpha v3. The contract addresses are:

- New verifier contract
  - Sepolia (L1): [0x5ca5dBf7Cb8F3f3c92E04B16FF5fCA1cdf147f79](https://sepolia.etherscan.io/address/0x5ca5dBf7Cb8F3f3c92E04B16FF5fCA1cdf147f79)
  - Ethereum Mainnet: [0x8AB455030E1Ea718e445f423Bb8D993dcAd24Cc4](https://etherscan.io/address/0x8AB455030E1Ea718e445f423Bb8D993dcAd24Cc4)
- New L1 message service contract
  - Sepolia (L1): [0xB218f8A4Bc926cF1cA7b3423c154a0D627Bdb7E5](https://sepolia.etherscan.io/address/0xB218f8A4Bc926cF1cA7b3423c154a0D627Bdb7E5)
  - Ethereum Mainnet: [0xd19d4B5d358258f05D7B411E21A1460D11B0876F](https://etherscan.io/address/0xd19d4B5d358258f05D7B411E21A1460D11B0876F)
- New L2 message service contract
  - Linea Sepolia: [0x971e727e956690b9957be6d51Ec16E73AcAC83A7](https://sepolia.lineascan.build/address/0x971e727e956690b9957be6d51Ec16E73AcAC83A7)
  - Linea Mainnet: [0x508Ca82Df566dCD1B0DE8296e70a96332cD644ec](https://lineascan.build/address/0x508ca82df566dcd1b0de8296e70a96332cd644ec)

Smart contract updates will be executed by the Linea Security Council using the Safe multi-sig 
procedure. 

Additionally, all contracts have been audited by OpenZeppelin. You can find the report [here](https://blog.openzeppelin.com/linea-blob-submission-audit).

**March 27**

- Block time reduced to 3 seconds. This change increases the throughput of the network to avoid
any potential L2 execution bottlenecks from increased Linea activity.
- Gas fee reductions. After EIP-4844 was implemented on March 26, we monitored data for 24 hours
before reducing gas fees for all users on March 27. 

### Breaking changes

None.

## February 2024

### February 19

**Testnet:**
- Released a higher priced version of `linea_estimateGas` (this will change once the endpoint is fully functional)

**Mainnet:**
- Released a higher priced version of `linea_estimateGas` (this will change once the endpoint is fully functional)

### February 12

**Testnet:**
- Updated Bridge UI to v0.5.4 to support the new claiming method via Linea SDK v0.2.1 

**Mainnet:**
- Updated Bridge UI to v0.5.4 to support the new claiming method via Linea SDK v0.2.1 

### February 5

**Testnet:**
- Deployed Linea Gas API to estimate how much gas is necessary to be included and published on Ethereum.
:::note
Learn how to use the Linea Gas API [here](https://docs.linea.build/reference/api/linea-estimategas).
:::

## Alpha v2

<table>
  <tbody>
    <tr>
      <th>Network</th>
      <th>Target Release Date</th>
    </tr>
    <tr>
      <td>Mainnet</td>
      <td>February 13th, 2024</td>
    </tr>
    <tr>
      <td>Testnet</td>
      <td>January 24, 2024</td>
    </tr>
  </tbody>
</table>

### Summary

This release focuses on reducing L1 costs, enabling lower prices for end users.

L1 costs are primarily driven by the following:

- Proof verification, which is essentially a fixed cost for every batch submission.

- Hashing the batch submission data to produce the public input of the Plonk verifier.

- Calldata costs, driven by the size of the batch submission data. This includes all the 
transaction data from L2, as well as messaging data (one hash per L2 to L1 message).

### Features

To decrease L1 costs, we implemented the following features:

- Proof aggregation:
  - This allows us to create a set of execution proofs for conflated batches and generates an aggregated proof
      that verifies that all the batches are correct. Since it takes the same amount of gas to verify
      an aggregated proof vs. a proof for a single batch of conflated blocks, the average cost of verifying a
      proof aggregating N proofs is N times cheaper.

<details>

  <summary>Learn more about proof aggregation</summary>

  Generating a zkSNARK proof on L1 is an essential step for finalizing transactions, as a verified 
  proof demonstrates the integrity and validity of the submitted transactions. 

  Previously, Linea generated one proof per batch of transactions. After Alpha v2, Linea began 
  to recursively aggregate multiple proofs into one.

  The verification process on L1 costs ~400,000 gas — a cost that previously had to be covered for 
  every batch. This gas cost is the same, however, for verifying a single batch of conflated batches
  (as Linea did in Alpha v1) as it is for verifying an aggregated proof representing multiple 
  batches (as in Alpha v2). A proof that aggregates N proofs is N times cheaper, as the cost 
  remains consistent.

  With Alpha v2 upgrades, Linea now averages ~30 batches per final proof, making the process 
  1/30th as costly as it was in Alpha v1.
</details>

- Data compression:
  - This reduces the call data cost on L1 by compressing L2 block data. (Post EIP-4844 this will be stored in blobs)

<details>

  <summary>Learn more about data compression</summary>

  Data compression significantly reduces the cost of posting L2 transaction and messaging data 
  to L1.

  The system leverages the Linea prover's ability to operate with a compressed input, meaning it 
  can decompress `calldata` or blob data to validate L2 state transitions. The data passed to the 
  L1 smart contract can therefore be considerably smaller, driving down the sum cost of transactions 
  in each block.

  The data compression algorithm is completely lossless, and can achieve compression ratios of up to 
  15:1 (where the data is 15 times smaller than its uncompressed state). This affords Linea 
  the ability to submit data about far more transactions in each batch: before Alpha v2, 
  Linea averaged ~150 transactions per batch; afterwards, it averages ~1,500.

  As a result, significantly more transactions can be processed for the same computational cost on L1.
  The combination of blobs and data compression further amplifies the gas fee savings that are 
  passed on to Linea users.
</details>

- Switched L2 to L1 messaging anchoring from individual hashes to Merkle trees:
  - Due to the size of the Merkle trees (32 messages) requiring only one Merkle root to be anchored, there
      is a 32x calldata size reduction for message hashes

### Smart contract changes

To support these new features, we implemented changes to our smart contracts. 

We introduce a `VERIFIER_SETTER_ROLE`, that will be attributed to the Timelock.sol so that all core
contract upgrades (Rollup and Message and Token bridge) and verifiers are executed through a TimeLock mechanism.
Note that we are also using this upgrade to update the way the type 2 state was calculated; as such we'll
need to call `finalizeWithoutProof()` to perform a state transition from type2 state v1 to type2 state v2.

The Security Council will first execute the following transactions on L1:
- Assign Operator Role via the Safe to the account for blob submission
- Assign Verifier Setter role via the Safe to the Timelock
- Schedule Set new Verifier at index 0
- Execute Set new Verifier at index 0
- Schedule LineaRollup upgrade (at L1 block N)
- Execute LineaRollup upgrade (at L1 block N)
- Update Zodiac delegate roles from pauseByType(bytes32) &rarr; pauseByType(uint8)

The Security Council will then execute the following transactions on L2:
- Schedule L2MessageService upgrade
- Execute L2MessageService upgrade

Post upgrade, Execute the following Security Council transactions on L1:
- Call `finalizeWithoutProof()`
- Clear verifier mapping at index 6 and 7

The audited commit for this update can be found
[here](https://github.com/Consensys/linea-contracts-audit/commit/99039ebc8d6cb3009cf46286d5de4c484e03bc81). 

Two independent audits have been performed for this update. Reports can be found here: 

- Diligence: https://consensys.io/diligence/audits/2024/01/linea-contracts-update/

- Open Zeppelin: https://blog.openzeppelin.com/linea-v2-audit

### Breaking changes

**Message claiming**

- Parties claiming messages on Layer 1 will need to adjust claiming behavior to account for Merkle Proof
    generation requests and their submission when claiming a message. This applies to messages sent post
    upgrading. Pre-existing messages must be claimed with the current approach.

:::info[Note] 

If you are using the Linea Bridge UI, then this is already done for you. If you are a partner/user who manages
their claiming outside of the Bridge UI, then we recommend looking at the updated [SDK](../docs/api/linea-sdk.mdx).

:::

**Finalization events**

- After migration to the new finalization mechanism, the rollup contract will no longer emit finalization
    events per block, but will instead emit events for data submission as well as an event indicating the
    current point of finalization.
  - The calldata will contain only the final block state root hash and final block number.

:::info[Note]

This is a breaking change for consumers listening to the existing events. The `BlockFinalized` event will
be replaced by the `DataFinalized` event.

:::

<table>
  <tbody>
    <tr>
      <th>Event</th>
      <th>Description</th>
      <th>Status</th>
    </tr>
    <tr>
      <td>
        <code>DataFinalized</code>
      </td>
      <td>
        Emitted at the end of finalization - used to indicate range of
        finalization
      </td>
      <td>New</td>
    </tr>
    <tr>
      <td>
        <code>BlockFinalized</code>
      </td>
      <td>
        Deprecated finalization event - an indicator that each block has been
        finalized.
      </td>
      <td>Old</td>
    </tr>
  </tbody>
</table>

## December 2023

### December 11

**Testnet:**
- Transitioned the sequencer to Besu from Geth

**Mainnet:**
- Fixes to the Linea bridge UI:
  - Users are now redirected to MetaMask Mobile when attempting to access the bridge on a mobile browser
  - Default token list now refreshes on every load rather than being stored locally; only the user's custom tokens are stored

### December 4

**Testnet:**
- Fixes to the Linea bridge UI:
  - Users are now redirected to MetaMask Mobile when attempting to access the bridge on a mobile browser
  - Default token list now refreshes on every load rather than being stored locally; only the user's custom tokens are stored

**Mainnet:**
- Lowered block time to 6 seconds

## November 2023

### November 27

**Testnet:** 
- Upgrades to the official Linea bridge:
  - UI updated to display tokens from the official token list
  - Improved page to redirect most users to MetaMask Portfolio to bridge

**Mainnet:**
- Upgrades to the official Linea bridge:
  - UI updated to display tokens from the official token list
  - Improved page to redirect most users to MetaMask Portfolio to bridge

### November 13

**Testnet:**
- Lowered block time to 6 seconds
- Updated default `gasPrice` to 3 Gwei

**Mainnet:**
- Increased block size from 60KB to 109KB
- Deployed the Linea Voyage XP (LXP) [token contract](https://lineascan.build/address/0xd83af4fbD77f3AB65C3B1Dc4B38D7e67AEcf599A)
- Lowered block time to 8 seconds
- Updated default `gasPrice` to 3 Gwei

## October 2023

### October 23

**Testnet:**
- Increased block size limit from 70KB to 109KB

## Summary release notes (June - October)

### Performance improvements

- Changes to the Genesis File: We made changes to the genesis file to enable block times to be reduced. This
    enhancement improves the overall performance and throughput of Linea.

- Improved Gas Limit Estimation for Finalization on L1: We improved the gas limit estimation for finalization on L1.

### Cost efficiency

- We updated the L1 message service contract to work with the Merkle tree, reducing gas costs and further
    enhancing the cost-effectiveness of Linea.

- We added a fixed cost to the gas price to cover infrastructure costs for system economic sustainability. This
    change ensures the long-term financial viability of Linea.

### User experience

- We smoothed the L2 gas price estimation by using an L1 moving average. This update makes our gas price
    estimation more accurate and reliable.

## Linea Alpha v0.2.3 (June 22, 2023)

### Summary

This release focuses on optimizing the prover's hashing strategy to increase its computational efficiency.

## Linea Alpha v0.2.2 (June 20, 2023)

### Summary

This release focuses on updating the Postman SDK configuration values and revising gas fee calculations.

### Features

- Updated the Postman SDK configuration files to handle messages that are contract calls with zero ETH value
    being transferred and revised gas fee calculations.

## Linea Alpha v0.2.1 (June 15, 2023)

### Summary

This release reduces the gas cost of submitting a batch of transactions on L1 by optimizing L2 logs in the
calldata that is sent to L1.

### Features

- Instead of sending the entire event MessageSent, we only send the \_messageHash field of the event.

- **Old calldata for L2 originated event**:

  ```bash
  //		event MessageSent(
  //			address indexed _from,
  //			address indexed _to,
  //			uint256 _fee,
  //			uint256 _value,
  //			uint256 _salt,
  //			bytes _calldata,
  //			bytes32 _messageHash
  //	    );
  ```

- **New calldata for L2 originated event**:
  ```bash
    //			bytes32 _messageHash
  ```

## Linea Alpha v0.2.0 (June 13, 2023)

### Summary

This release focuses on testing a substantial architecture upgrade in preparation for Mainnet launch. It
contains multiple improvements and breaking changes, specifically around the messaging layer which is changed
to a push model. It also improves EVM prover coverage, and provides batch conflation.

### Features

- Add Batch Conflation feature to the sequencer to minimize L1 transaction cost.
  - With Batch Conflation, L2 blocks' proofs that should have been independent are instead merged together.
      Therefore, L1 costs for these blocks’ proofs are divided by the number of merged blocks.
- Improve the following smart contracts:
  - Rollup zkEVM: Upgrade the rollup main contract with support for
    - Conflation
    - Security Council management
    - Verifier
      - Outer proof system moved from Groth16 to Plonk + custom gates to support efficient
          Fiat Shamir, c.f.: https://eprint.iacr.org/2022/1072.pdf section 6.2
    - Messaging Service
      - Changed the message service model by splitting the delivery into anchoring and claiming of
          messages to allow more flexible workflows, remove the mandatory fee for L1→L2, reduce the mandatory fee for L2→L1
  - Canonical Token Bridge: Upgrade from 1-1 ERC-20 basic token bridge to N-N ERC-20 canonical token bridge
      with reservation and token registry
- Add Postman Service for message execution
  - The Postman Service is Linea’s off-chain message delivery service. It’s decentralized, permissionless, and
      used to claim messages once the protocol has anchored the message hashes. The first release will only
      contain the following scenarios:
    - DApps/protocols operating the SDK (to be released) claiming messages and paying for gas
      - The protocol can filter messages based on origin or destination smart-contracts
    - Linea operating the SDK for dApps/Protocols that aren’t yet integrated
  - If messages don’t get delivered by the postman, the message can be manually claimed by calling
      `claimMessage` with the `MessageSent` event parameters or by using the SDK.
- Update prover to integrate with the new architecture and support Batch Conflation

### Breaking changes

**Message bridge**

- Bridging partners will need to listen to different events. Modifications to the events are seen below:

  <table>
    <tbody>
      <tr>
        <th></th>
        <th>Event</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>
          <b>L1</b>
        </td>
        <td>
          <code>MessageClaimed</code>
        </td>
        <td>When a message is claimed</td>
      </tr>
      <tr>
        <td>
          <b>L1</b>
        </td>
        <td>
          <code>L1L2MessagesReceivedOnL2</code>
        </td>
        <td>
          Message hashes have been anchored on L2 and the zkRollup updates the
          L1 statuses - <b>Includes multiple message hashes</b>
        </td>
      </tr>
      <tr>
        <td>
          <b>L1</b>
        </td>
        <td>
          <code>L2L1MessageHashAddedToInbox</code>
        </td>
        <td>
          The L2 message hash has been anchored on L1 and can be claimed on
          block finalization.
        </td>
      </tr>
      <tr>
        <td>
          <b>L2</b>
        </td>
        <td>
          <code>MessageSent</code>
        </td>
        <td>Emitted when a message is sent</td>
      </tr>
      <tr>
        <td>
          <b>L2</b>
        </td>
        <td>
          <code>MessageClaimed</code>
        </td>
        <td>Emitted when a message is claimed</td>
      </tr>
      <tr>
        <td>
          <b>L2</b>
        </td>
        <td>
          <code>L1L2MessageHashesAddedToInbox</code>
        </td>
        <td>
          L1→L2 message hash has been anchored on L2 and can be claimed on block
          finalization.
        </td>
      </tr>
    </tbody>
  </table>

- The anchoring and execution (claim) process has been separated into 2 steps. The deadline concept has been completely removed.

:::note


Contracts audit is in progress. This doesn't reflect final versions.

:::

- **L1 (Goerli)**:

  - Bridging partners, to send messages, will need to call the new contract address with a different ABI.

    <details>
      <summary>zkEVM2.abi</summary>
      <CodeBlock language="json">{zkEVM2}</CodeBlock>
    </details>

  - Contracts:
    - [Transparent Proxy](https://goerli.etherscan.io/address/0x70BaD09280FD342D02fe64119779BC1f0791BAC2#readProxyContract)
    - [Implementation](https://goerli.etherscan.io/address/0x2652e1547Ac6b9a0311cF1B7F024a378f30ad8D8#code)

- **L2 (Linea)**:

  - Bridging partners, to send messages, will need to call the new contract address with a different ABI.

    <details>
      <summary>L2MessageService.abi</summary>
      <CodeBlock language="json">{L2MessageService}</CodeBlock>
    </details>

  - Contracts
    - Transparent Proxy: `0xC499a572640B64eA1C8c194c43Bc3E19940719dC` 
    - Implementation: `0xc0557e2149751e201749b87f86acd91DB22e2662`

- Bridging partners, before sending messages on L2, need to retrieve the service protection fee before sending messages and include it in the value sent.

**Canonical Token Bridge**

Major changes are applied to the Canonical Token Bridge as described in our [documentation](./technology/canonical-token-bridge.mdx).

- **L1 (Goerli)**

  <details>
    <summary>TokenBridge.abi</summary>
    <CodeBlock language="json">{TokenBridgeL1}</CodeBlock>
  </details>

  - Contracts
    - [Transparent Proxy](https://goerli.etherscan.io/address/0xaA012D038E6440535Ec66eDf2DA592F4F8398133)
    - [Implementation](https://goerli.etherscan.io/address/0x6e4437828b4a7e7730e3d7efc676e22ce905b705#code)

- **L2 (Linea)**

  <details>
    <summary>TokenBridge.abi</summary>
    <CodeBlock language="json">{TokenBridgeL2}</CodeBlock>
  </details>

  - Contracts
    - Transparent Proxy: `0xB191E3d98074f92584E5205B99c3F17fB2068927`
    - Implementation: `0x6081C1392793e22dA39871D4362c1e7045A5bace`

If you have any questions, please reach out in the **Developer Support** channel in our [community forum](https://community.linea.build/c/developer-support)!


==================== FILE: /workspace/docs/technology/prover/proving.mdx ====================

---
title: 'Proving: Circuit execution and runtime'
sidebar_position: 2
image: /img/socialCards/proving-circuit-execution-and-runtime.jpg
---

## gnark zk-snarks

### What is it?

In Linea, gnark is the final part of the prover. It is also standalone software which can be used in other projects to create cryptographic circuits.

### What does it do?

Similarly to Corset, gnark has two functions: it prepares a set of “circuits”, another way of referring to a constraint system, of the kind that will create a zk-SNARK proof that can be verified in an L1 Ethereum environment. It also, in fact, _makes_ those proofs.

### How does it do it?

gnark’s codebase is divided into two separate APIs: a [frontend](https://pkg.go.dev/github.com/consensys/gnark/frontend) and a [backend](https://pkg.go.dev/github.com/consensys/gnark/backend). The methods in gnark’s frontend API allow developers to do the first part, creating cryptographic circuits. In other words, gnark translates Corset’s precompiled Go constraint system into a final set of “circuits”, or constraints, which will ultimately produce the SNARK proof that is submitted to the L1 network. The methods in the backend API are used at runtime to consume data through the proving system created previously in the frontend, producing as a result a proof. That is, gnark accepts the “expanded” trace data for each block or set of blocks from Corset, and processes it through its prepared circuits. At this point, we have what we’ve been out here amongst the stars searching for: a fresh set of transactions, executed in an EVM environment, provably real and correct, ready to dispatch to the L1. So, what does the prover do with it? Send it back to the Coordinator, that’s what.


==================== FILE: /workspace/docs/technology/prover/prover-limits.mdx ====================

---
title: Module limits
description: How module limits ensure the prover can generate proofs.
sidebar_position: 3
image: /img/socialCards/module-limits.jpg
---

Linea uses module limits to keep proof complexity manageable and ensure that the prover can
generate proofs efficiently without overwhelming the infrastructure. 

Linea's arithmetization specification is divided into modules, and each module represents a collection
of EVM or Linea zkEVM operations (opcodes). Modules can:
- Process transaction data.
- Manage zkEVM memory.
- Coordinate interactions between modules.

Each module has a specific limit on the number of lines of data its operations can generate, 
regardless of its purpose. You can view these limits in the 
[Linea source code](https://github.com/Consensys/linea-monorepo/blob/main/config/common/traces-limits-v2.toml). 
Additional lines are generated each time unique instructions are provided to a module's operations, 
but repeat calls with the same arguments do not generate new lines.

High-complexity transactions that repeatedly use a large volume of operations may generate too many 
lines of data and exceed a module's limit. Transactions that reach this point are rejected by the 
[sequencer](../sequencer/index.mdx) to ensure that the trace data passed to the prover is of a 
manageable scope, and that a proof can be generated.

Transactions rejected for exceeding module limits can be identified through the following
methods, which return an error:

- [`linea_estimateGas`](../../api/reference/linea-estimategas.mdx)
- [`eth_sendRawTransaction`](../../api/reference/eth-sendrawtransaction.mdx)

Use [`linea_getTransactionExclusionStatusV1`](../../api/reference/linea-gettransactionexclusionstatusv1.mdx)
to get the rejection status of a transaction hash, if it was sent and didn't get rejected directly, 
nor included in a block.

This API method can be used to query the reason for transaction rejection in edge cases where
`linea_estimateGas` or `eth_sendRawTransaction` did not return an error. It's intended to be used 
only in cases the transaction execution differs between an RPC node and the sequencer.


==================== FILE: /workspace/docs/technology/prover/index.mdx ====================

---
title: Trace expansion and proving
sidebar_position: 5
image: /img/socialCards/trace-expansion-and-proving.jpg
---

## What is it?

The module responsible for generating the final set of data for a zero-knowledge proof, and producing that proof.

## What does it do?

It receives several sets of information from the Coordinator and linea-besu, and produces a succinct, non-interactive argument of knowledge, or **zkSNARK**.

## How does it do it?

There are multiple operations involved; the first part of this module is Corset. Corset takes in conflated trace data from the Coordinator, and prepares it for the second part, gnark. gnark takes in that prepared, or "expanded", trace data, and uses it to produce a proof of the type that can be submitted to Ethereum.


==================== FILE: /workspace/docs/technology/prover/trace-expansion.mdx ====================

---
title: 'Proving: Circuit building'
sidebar_position: 1
image: /img/socialCards/proving-circuit-building.jpg
---

## Corset

### What is it?

Corset is the first of two parts of the component of Linea’s architecture generally referred to as “the prover”.

### What does it do?

Corset takes the traces, expands them, and prepares them for the prover.

### How does it do it?

Corset performs its duties through two different paths:

First, every time Linea’s overall codebase and implementation of the zkEVM is updated, Corset creates a _constraint system_. This is a term you may hear often in zk-land. A constraint, in this context, refers to a kind of test you can run on something, to make sure it’s the way it’s supposed to be. An entire constraint system allows you to define a whole set of rules, or checks, which must be fulfilled. Since the goal of Zero Knowledge technology is to _prove_ something, you can probably see where this is going: a constraint system allows you to, using math, prove that underlying conditions are a certain way, without revealing those underlying conditions.

Corset–which is written in Rust–uses a Domain-Specific Language, or DSL, written in Lisp, to create a constraint system specifically designed for Linea’s zkEVM environment. This system, once built, is compiled into the Go programming language. This constraint system, which is optimized for Linea’s architecture, becomes the input for gnark, which converts it to the type of constraint system that would produce **a zk-SNARK**–the kind you would, you know, send to a smart contract on Ethereum mainnet to prove that everything on your L2 is the way you say it is.

**Second** (it’s OK to take a deep breath here), Corset helps process data with _every block that’s submitted_. The trace data, generated in every block, will have to go into gnark’s implementation of Corset’s compiled constraint system, in order to produce the final proof. And because of the way Corset, and the Lisp part of it specifically, processes trace data, Corset can prepare that trace data for gnark. This process is called “trace expansion”, because it refers to taking matrices of data, and deriving certain sets of them from others–so that they can be more accurately processed by gnark.

In these two modes, then–once at build time, when Corset makes the constraint system and compiles it to Go, and at the runtime of every block, when Corset takes traces and expands them into a format that will work well with gnark’s implementation of Corset’s original constraint system, Corset is the bespoke data preparation system for gnark, which is the final executor of Linea’s proving system.


==================== FILE: /workspace/docs/technology/message-service/reference.mdx ====================

---
title: Technical reference
description: Technical reference for the canonical message service
image: /img/socialCards/technical-reference.jpg
---

import CodeBlock from "@theme/CodeBlock";
import IMessageService from "!!raw-loader!/files/testnet/IMessageService.sol";
import MessageServiceBase from "!!raw-loader!/files/testnet/MessageServiceBase.sol";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Canonical message service technical reference

The message service is responsible for cross-chain messages between Ethereum and Linea, which:

- Allows a contract on the source layer to safely interact with a contract on the target layer 
(e.g. L1TokenBridge triggering mint on the L2TokenBridge),
- Is responsible for bridging ETH (native currency on L1 and L2)
- Supports:
  - **push**: auto-execution on target layer if a fee is paid
  - **pull**: users/protocols responsible for triggering the transaction

The L2 message service contract holds ~999M ETH, a value set at genesis. This ETH is distributed to
addresses on L2 to reflect the deposits (i.e. bridging requests) sent to the L1 message service.

## Contracts

<Tabs groupId="Mainnet-Testnet" className="my-tabs">
  <TabItem value="Mainnet" label="Mainnet" default>
    <table>
      <tbody>
        <tr>
          <th>L1 (Ethereum) Address</th>
          <th>L2 (Linea) Address</th>
        </tr>
        <tr>
          <td>
            <a href="https://etherscan.io/address/0xd19d4B5d358258f05D7B411E21A1460D11B0876F">
              0xd19d4B5d358258f05D7B411E21A1460D11B0876F
            </a>
          </td>
          <td>
            <a href="https://lineascan.build/address/0x508Ca82Df566dCD1B0DE8296e70a96332cD644ec">
              0x508Ca82Df566dCD1B0DE8296e70a96332cD644ec
            </a>
          </td>
        </tr>
      </tbody>
    </table>
  </TabItem>
    <TabItem value="Linea Sepolia" label="Linea Sepolia">
    <table>
      <tbody>
        <tr>
          <th>L1 (Sepolia) Address</th>
          <th>L2 (Linea Sepolia) Address</th>
        </tr>
        <tr>
          <td>
            <a href="https://sepolia.etherscan.io/address/0xB218f8A4Bc926cF1cA7b3423c154a0D627Bdb7E5">
            0xB218f8A4Bc926cF1cA7b3423c154a0D627Bdb7E5
            </a>
          </td>
          <td>
            <a href="https://sepolia.lineascan.build/address/0x971e727e956690b9957be6d51ec16e73acac83a7">
            0x971e727e956690b9957be6d51Ec16E73AcAC83A7
            </a>
          </td>
        </tr>
      </tbody>
    </table>
  </TabItem>
</Tabs>

## Usage

### Step 1: Send a message

Call `sendMessage()` on the origin layer using the proxy contract at one of the contract addresses 
[above](#contracts).

<details>

<summary>Proxy contract?</summary>

A proxy contract is one that simply points towards the actual "implementation" contracts. This model
is beneficial as it allows the implementation contracts to be upgraded independently of the proxy,
allowing contract upgrades without having to start afresh and lose the proxy contract's history. 
When the implementation contracts are updated, the proxy contract is simply amended to point 
towards the new implementation contract addresses.

</details>

`sendMessage()` takes the following arguments:

- `_to`: the destination address on the destination layer
- `_fee`: the message service fee on the origin layer. 
  - An optional field used to incentivize a postman to perform `claimMessage(...)` automatically 
  on the destination layer (not available when bridging from L2 to L1, or for non-ETH transfers)
- `_calldata`: a flexible field that is generally created using `abi.encode(...)`

<details>

  <summary>What is the `_fee`?</summary>

  **L1 &rarr; L2:**
  - Automatic claiming: 0 (The postman fee is sponsored by Linea.)
  - Manual claiming: 0

  :::note

  The postman fee for automatic claiming is only sponsored for transactions using less than 
  250,000 gas. Where sponsorship doesn't apply, the postman fee = `target layer gas price * (gas 
  estimated + gas limit surplus) * margin`, where:

  - `target layer gas price` = `eth_gasPrice` on the target layer
  - `gas estimated` = the current gas estimation
  - `gas limit surplus` = 6000
  - `margin` = 2

  :::

  **L2 &rarr; L1:**
  - Manual claiming: 0.001 ETH (anti-DDOS fee)

  _Automatic claiming is not available for L2 &rarr; L1._

  See our [main bridge page](../../get-started/how-to/bridge.mdx) for more information on the 
  execution fees that apply.

</details>

### Step 2: Claim a message

Once the message is sent, you must execute the message on the destination layer by claiming it.

#### Option 1: Run a postman

You can run a postman locally or as part of a dapp to claim messages. This can be useful if messages 
don't get picked up by the Linea postman because there was no fee attached or the fee was too low, 
for example. Event filtering, detailed below, also makes it possible to filter for messages
that relate to specific criteria, such as messages sent on a specific dapp.

Run a postman by cloning the [Linea monorepo](https://github.com/Consensys/linea-monorepo) 
locally and following the instructions in the [postman README](https://github.com/Consensys/linea-monorepo/tree/main/postman#readme).

You can trigger a manual claim via the postman by:

1. **Event filtering**: Run the postman with event filtering configuration that instructs it to 
listen only for messages that meet certain criteria. Configure the event filtering in your local 
`.env` file (available as `env.sample` when you clone the monorepo): 
    - `L1_EVENT_FILTER_FROM_ADDRESS`: Filter events using a `from` address
    - `L1_EVENT_FILTER_TO_ADDRESS`: Filter events using a `to` address
    - `L1_EVENT_FILTER_CALLDATA`: Filter by the contents of event calldata using a [Filtrex](https://github.com/joewalnes/filtrex/tree/master) 
    expression. For example: `calldata.funcSignature == "0x6463fb2a" and calldata.params.messageNumber == 85804`
    - `L1_EVENT_FILTER_CALLDATA_FUNCTION_INTERFACE`: Filter by the calldata data function interface, 
    following this format: `"function transfer(address to, uint256 amount)"`. Make sure you specify 
    parameter names in order, using syntax like `calldata.params.messageNumber`.

2. **`claimMessage`**: This call is made automatically by the postman if the configuration is 
correct. If, however, gas exceeds 250,000 (the threshold for postman fee sponsorship), you will 
need to call one of these methods using the parameters detailed in the [interface below](#interface-imessageservicesol):
    - L2: `claimMessage` 
    - L1: `claimMessageWithProof`

#### Option 2: Use the Linea SDK

The [Linea SDK](../../api/linea-sdk.mdx) (view the [npm package](https://npmjs.com/package/@consensys/linea-sdk?activeTab=readme))
simplifies the execution of messages on the destination layer.

Install the SDK using the package manager of your choice. For example:

```bash
npm install @consensys/linea-sdk
```

Refer to the [SDK README](https://github.com/Consensys/linea-monorepo/tree/main/sdk#readme) for 
directions on initializing the SDK and enabling read-write mode. 

Now you can use the `claim()` function on the destination layer to claim messages, passing the 
message hash as an argument:

```js
const tx = await l2Contract.claim(message);
```

You can call `claim()` either on the `l1Contract` or `l2Contract` depending on which you need.

## Claim old messages

The Linea native bridge app only retains unclaimed message for 90 days; if your bridge transfer is
older than this, you'll need to claim it outside of the native bridge app using a block explorer or 
the Linea SDK. We recommend you use the SDK, particularly if you're claiming on L1.

:::note

Since the message service fee is automatically set to 0 for all deposits to Linea (L1 &rarr; L2) using 
less than 250,000 gas, your transaction will be claimed by the postman service automatically in 
most cases.

:::

Select the appropriate message service contract for your _destination_ layer:

- L1 (Ethereum):
  - Mainnet: [`0xd19d4B5d358258f05D7B411E21A1460D11B0876F`](https://etherscan.io/address/0xd19d4B5d358258f05D7B411E21A1460D11B0876F)
  - Sepolia: [`0xB218f8A4Bc926cF1cA7b3423c154a0D627Bdb7E5`](https://sepolia.etherscan.io/address/0xB218f8A4Bc926cF1cA7b3423c154a0D627Bdb7E5)
- L2 (Linea):
  - Mainnet: [`0x508Ca82Df566dCD1B0DE8296e70a96332cD644ec`](https://lineascan.build/address/0x508Ca82Df566dCD1B0DE8296e70a96332cD644ec)
  - Sepolia: [`0x971e727e956690b9957be6d51Ec16E73AcAC83A7`](https://sepolia.lineascan.build/address/0x971e727e956690b9957be6d51Ec16E73AcAC83A7)

On the contract's page, find the "Contract" tab and then select the "Write as proxy" tab:

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/technology/message_service/reference/write_as_proxy_tab.png"
      alt="Find the contract tab and then select write as proxy"
    />
  </div>
</div>

Make sure your wallet is connected using the "Connect to Web3" button immediately above contract
functions.

The function you need to use to claim your funds depends on the layer you're claiming on:
- L1 &rarr; L2: use `claimMessage`
- L2 &rarr; L1: use `claimMessageWithProof`

:::warning

If your L2 &rarr; L1 transfer predates the L2 block `2242568` (Alpha v2, early 2024), use 
`claimMessage` rather than `claimMessageWithProof`. See the [release notes](../../release-notes.mdx#alpha-v2) 
for more information. 

:::

<Tabs className="my-tabs">
  <TabItem value="L1 &rarr; L2">
    Click the `claimMessage` function to see its parameters. You'll need to fill these out to claim 
    your bridged funds:

    <div class="center-container">
      <div class="img-large">
        <img
          src="/img/technology/message_service/reference/claimmessage_function_parameters.png"
          alt="claimMessage function parameters"
        />
      </div>
    </div>

    - `_from`: The address that sent the transfer on L1. 
    - `_to`: The recipient address on the destination layer.
    - `_fee`: `0`.
    - `_value`: The amount of ETH to claim, in wei.
    - `_feeRecipient`: `0x0000000000000000000000000000000000000000`
    - `_calldata`: `0x0`.
    - `_nonce`: The message nonce. You can find it in the `MessageSent` event on the origin layer.

    :::note

    In most cases, the `_from` and `_to` address will be identical, unless you intentionally
    specified a different recipient when bridging.

    :::

    When ready, click the "Write" button underneath the parameters to prompt the transaction in your
    wallet, and then confirm it to execute the claim.
  </TabItem>
  <TabItem value="L2 &rarr; L1">
    We don't recommend manually claiming messages on L1 with `claimMessageWithProof`, as gathering
    the parameters is complex and involves querying for various events to reconstruct the proof.

    Instead, we recommend using the Linea SDK, which abstracts away most of this complexity. See 
    the [SDK documentation](../../api/linea-sdk.mdx#claim) for guidance on claiming on L1.
  </TabItem>
</Tabs>

## Interface IMessageService.sol

<details>
  <summary>IMessageService.sol</summary>
  <CodeBlock language="solidity">{IMessageService}</CodeBlock>
</details>

## Abstract contract MessageServiceBase.sol

<details>
  <summary>MessageServiceBase.sol</summary>
  <CodeBlock language="solidity">{MessageServiceBase}</CodeBlock>
</details>


==================== FILE: /workspace/docs/technology/message-service/index.mdx ====================

---
title: Canonical message service
image: /img/socialCards/canonical-message-service.jpg
---

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/concepts/message_service/Linea_message_service_2.png"
      alt="Linea message service architecture"
    />
  </div>
</div>

## What is it?

The canonical message service is a combination of smart contracts and other protocols which work together to pass "arbitrary messages"--that is, user-specified data--between Linea and other networks.

## What does it do?

If you've ever used a bridge between two blockchains, you may be used to what feels like a fairly restrictive experience; you can only send certain tokens, for example. The canonical message service itself isn't like an end-user bridge interface. It's a system through which data and assets can be permissionlessly and reliably transferred from one blockchain to another. The service, as a whole, receives requests to move something from one network to the other, and then carries that request out, delivering the message as submitted to an established smart contract on the destination network.

One of the most important things that the message service transfers is information about the current state of the Ethereum network, from Ethereum to Linea, and in return, an updated Merkle tree and a zk-proof from Linea to Ethereum, every time Linea reports back about activity on the network. In other words, the canonical message service transmits the rollup data.

However, the service is not limited or restricted to use by Linea's core functionality. It is general-purpose, public infrastructure which can be used by developers, integrated into dapps, and triggered by end users.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/concepts/message_service/Linea_bridge_architecture.png"
      alt="Linea bridge architecture"
    />
  </div>
</div>

## How does it do it?

The canonical message service consists of three main elements: two smart contracts, and the postman service in between. As you may have guessed already, the smart contracts are [on Linea and Ethereum](./reference.mdx#contracts), and are almost exactly the same. They allow for ETH to be minted on the target network, for example, though they are not limited to that.

A user initiates a network-to-network transfer by executing a call on one of the contract's methods--that is, invoking a function built into the smart contract. The user could do this on their own, if they have the knowledge of how to interact with a smart contract directly, or they could do so through a frontend. If properly formulated, the smart contract will accept the request from the user, and pass it off to the postman.

The postman service is currently centralized, but will be decentralized. The postman "listens" for calls being made to one of the contracts, either on Linea or Ethereum, and passes the submitted information to the other network.

Once the information is delivered to the destination smart contract, the code contained in the request is executed. If the message being transferred carried orders to mint tokens, users can either choose to manually _pull_ the transferred assets out of the destination end of the bridge, or pay up-front and allow the assets to be _pushed_ directly to the destination address.

There's an additional layer of logic, though, which serves to ensure that the message delivered to the L2 is valid. Essentially, a message is sent from Ethereum, relayed through the message service, and is delivered to the Linea smart contract. That smart contract checks the message received against the list of messages sent on the Ethereum side, verifies that it exists on the L1, and only then accepts it as a valid message:

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/concepts/message_service/Linea_message_service_1.png"
      alt="Linea message service verification"
    />
  </div>
</div>



==================== FILE: /workspace/docs/technology/architecture.mdx ====================

---
title: Architecture
description: An overview of how Linea works
image: /img/socialCards/architecture.jpg
---

Linea aims to be a fully decentralized, permissionless network. To support this goal, the Linea architecture is made up of three main elements:

- Sequencer
- Prover
- Bridge relayer

## Current state

Linea is in mainnet status, and the team is fervently working towards full decentralization. 
The following is a good representation of the main components of Linea, and how they interact:

<div className="responsive-graphic">
  <picture>
    <source
      srcSet="/img/get_started/concepts/architecture/Linea_architecture_mobile.svg"
      media="(max-width: 1499px)"
    />
    <source
      srcSet="/img/get_started/concepts/architecture/Linea_architecture_desktop.svg"
      media="(min-width: 1500px)"
    />
    <img
      src="/img/get_started/concepts/architecture/Linea_architecture_desktop.svg"
      alt="Linea architecture diagram"
    />
  </picture>
</div>

## First of all: what _is_ Linea, anyway? What's a zkEVM L2?

There are several different mental models that people use to explain the different
networks and how they relate to one another. Some people prefer to call L2s "rollup networks", 
or "scaling solutions". The term "layer" is a popular mental model: where one network is "built on top of another". 

Let's set metaphor aside for a moment, and clarify:

**The Ethereum network has several functional areas:**

- _Blockchain_: keeps track of addresses, and which tokens are allocated to 
which addresses
- _Consensus_ mechanism: wherein many nodes communicate about the movement of 
tokens from one address to another, and each keeps their local copy of the ledger up to date
- _Execution environment_: the EVM (Ethereum Virtual Machine) wherein computer programs can be run. 

These three areas are heavily interconnected, and this is a simplification, but it's a helpful 
one to understand the tradeoffs all networks must make.

Ethereum prioritizes security: that consensus mechanism is designed to ensure that no one can 
singlehandedly alter the state of the network. This is a very impressive feat of engineering, 
and it comes with a tradeoff: the execution environment is highly limited in the amount of work 
it can do, because the consensus mechanism intentionally runs slowly, to keep everything safe.

Linea and other L2s are designed to participate in the security mechanism of Ethereum, 
while optimizing for execution. In other words, L2s enable users to make many transactions, run 
lots of programs, deploy contracts, mint NFTs, absolutely go to town—fast and cheap, and then compresses this data into a report back to Ethereum for inclusion in Ethereum's blockchain. By sending regular 
reports of activity on Linea to Ethereum, the network can optimize for execution without being as 
limited by security.

This is the action known as "rolling up": we can say that Linea "rolls up its transactions to 
Ethereum". And the fact that it relies on Ethereum for its security leads people to say 
that it's "built on top of Ethereum": it's a "second-layer network", an L2. And before you ask, 
yes, Ethereum is an L1, and L3s exist, too: networks that roll up to Linea would roll up to 
Ethereum.

The trick is in how that _rollup_ happens. Linea is special: it uses cutting-edge developments in 
a branch of mathematics and computer science often referred to as zero-knowledge, or 
_zero-knowledge cryptography_, to prove to the Ethereum network that everything that is happening 
on the Linea network is, in fact, happening, without having to submit a complete record of every 
last transaction and check each one. Instead, Linea submits a verifiable proof to Ethereum of each transaction: that's the 'zk' part.

So, now that we've walked through some concepts, we can roll it all up: Linea is a zkEVM L2 
network.

<div class="center-container">
  <div class="img-xsmall">
    <img
      src="/img/get_started/concepts/architecture/Linea_bluecircle.png"
      alt="Linea blue circle"
    />
  </div>
</div>

## OK... But what's a _sequencer_ and a _prover_? How does all this actually work?

At a high level, if you were to follow a flow from Ethereum, through Linea, and back to Ethereum, it would go like this:

1. Ethereum bridge contract >
2. Linea bridge contract >
3. Coordinator >
4. Sequencer (Block building > Execution > Trace data generation) >
5. Coordinator >
6. Trace Conflation >
7. EVM State Manager >
8. Trace Expansion and Proving (Corset > gnark) >
9. Coordinator >
10. zk-proof and updated Merkle tree >
11. Linea bridge contract >
12. Ethereum bridge contract >
13. Ethereum blockchain

_...in other words, there's a lot involved._

<div class="center-container">
  <div class="img-xsmall">
    <img
      src="/img/get_started/concepts/architecture/Linea_redcircle.png"
      alt="Linea red circle"
    />
  </div>
</div>

## Next steps

- Learn more about the different components that comprise the [Linea architecture](./architecture.mdx).
- Understand the first point of contact for many new L2 users, the bridge. Linea has more than one bridge; and that number is likely to continue to 
grow. The [Linea canonical message service](./message-service/index.mdx) is key to these bridges and how they function.


==================== FILE: /workspace/docs/technology/transaction-lifecycle.mdx ====================

---
title: Transaction lifecycle
description: >-
  An overview of what happens to transactions from the point of submission to
  finalization
image: /img/socialCards/transaction-lifecycle.jpg
---

:::note[Finality]

Finality has two definitions on Linea:
- Soft finality: The transaction is confirmed on Linea. This takes two seconds, i.e Linea's block 
time. See [step 3](#step-3-transaction-data-sent-to-the-state-manager). For simplicity, Linea is 
guaranteed to not reorg—remove competing versions of blockchain history in favor of a canonical 
one—when there are reorgs on L1. 
- Hard finality: The proof submitted to L1 has been verified, and two epochs have elapsed. The 
typical time before hard finality is 6-32 hours, although the six-hour minimum will be reduced to
zero in future. See [step 6](#step-6-batch-finalization).

:::

Transactions on Linea proceed through the following steps:

## Step 1: Submission

This is where every transaction originates: at the wallet level, a user signs a transaction and 
broadcasts it to Linea. From here, transactions head straight to the **mempool**, similarly to 
Ethereum, where they become pending transactions.

## Step 2: Block building

The Linea [sequencer](./sequencer/index.mdx) is responsible for ordering, building, and 
executing blocks. For each transaction added to the mempool, the sequencer checks its validity, 
rejecting transactions as necessary. Transaction validity conditions are specific to Linea, and 
differ slightly from those on other networks, including Ethereum.

The sequencer orders transactions according to the priority fee paid for each, a method known as
a priority gas auction. So, having passed the above checks, valid transactions are placed into
blocks in the correct sequence and executed.

At this point, the transaction's lifecycle is more or less complete — at least from a user
perspective. The block containing the transaction has been added to the "head" of the Linea
blockchain—the most recent block—and a transaction receipt is returned to the user's wallet as
confirmation.

However, the transaction and its associated data will continue to be processed in order to
generate ZK proofs. Let's press on.

## Step 3: Transaction data sent to the state manager

Data about the transaction and the state of the network at its time of execution are recorded
in **traces**, an output of part of the sequencer called the [trace generator](./sequencer/traces-generator.mdx).

Traces are passed to the state manager block-by-block and then used to update the network state.
Once state is up to date, you'll see the transaction reflected and confirmed in your wallet.

With the transaction executed and state updated, the transaction has reached **soft finality**:
as far as the Linea chain is concerned—if considered in isolation—your transaction is complete.
A L2 like Linea doesn't work in isolation, though, as we know; so there is more work to be done
before true finality is reached.

## Step 4: Conflation

The transaction's block will then be subject to [conflation](./sequencer/conflation.mdx), which
combines two or more blocks' transaction data into a single data set (batch) that forms part of
the package of data passed on to Ethereum. Combining the transaction data of multiple blocks
means that a single proof can be used to verify a large volume of transactions, minimizing the
costs of submitting proofs to L1.

Occasionally, a batch may only consist of one block, with no conflation having taken place.
This occurs when chain activity levels are particularly high, and the block size is larger
than normal.

Amongst Ethereum's L2 networks, Linea is the only network that uses batch conflation.

## Step 5: Generating a ZK proof using transaction data

With the block that contains the transaction's trace data conflated into a batch with one or
more others, the only remaining task on the checklist to achieve **_hard_ finality** is to use
the transaction's data—as contained in its trace—to generate a proof.

When prompted by the [Coordinator](./coordinator.mdx), Linea's [prover](./prover/trace-expansion.mdx)
will first **expand** the trace, preparing it for inclusion in the proof. Linea's prover employs
a two-stage method for developing the proofs that eventually get passed to L1, first developing
an **inner proof** and then an **outer proof**.

The inner proof uses a combination of tools, including Arcane and Vortex, to recursively reduce
the proof size. For a more in-depth look at Linea's inner proof system, see [this article](https://linea.build/blog/the-linea-prover-for-a-very-smart-high-schooler).

Next, the outer proof is generated using the Consensys-maintained library [`gnark`](https://docs.gnark.consensys.net/),
compressing the proof size even further. The resulting proof is what's known as a zk-SNARK:
the proofs that are eventually submitted to Ethereum.

Since the trace data of _every_ transaction in _every_ block feeds into producing the final proof,
the single transaction we started with remains vital to Linea's function, well beyond the point
at which it achieves soft finality in [step 3](#step-3-transaction-data-sent-to-the-state-manager).

## Step 6: Batch finalization

The final step in the process is to finalize the batch by submitting it to Ethereum mainnet,
proving its computational integrity. Since the batch of conflated blocks is comprised of
transactions, our transaction is involved in this process as well.

Let's break down the two elements submitted to L1:

- The proof, as explained [above](#step-5-generating-a-zk-proof-using-transaction-data), and;
- Blob data, which contains L2 transaction and messaging data. Once shared to L1, blob data
can be used to reconstruct Linea's state and verify the contents of the proof, before it disappears
after 4,096 epochs (~18 days). The Linea rollup contract on L1 calls the Ethereum verifier contract
using blob data, determining whether or not to accept the batch as valid.

:::note[Calldata]

Up until Linea Alpha v3, L2 transaction data was transported to L1 via `calldata` embedded in
transactions. Although effective, this method was costly, and has now been replaced by
blob-carrying transactions made possible by EIP-4844, added in Ethereum's Dencun upgrade.

:::

You can also view finalized batches on Lineascan, [here](https://lineascan.build/batches).

Once the proof is verified and two epochs have passed, the transaction becomes immutable history,
and reaches **hard finality**. Its lifecycle is complete.


==================== FILE: /workspace/docs/technology/tokenomics.mdx ====================

---
title: Tokenomics
description: 'The utility, distribution, and numbers behind the token, LINEA.'
image: /img/socialCards/tokenomics.jpg
---

The LINEA token is designed to grow and support Ethereum and Linea, and has several radical features 
that set it apart from most layer 2 tokens:
- ETH is the gas token
- LINEA does not come with any governance rights
- There is no token allocation for insiders, investors, or team members.

Instead, LINEA will help to organically grow the chain by being distributed to users as a reward for 
using apps and protocols on Linea. 

The token's contract address on Linea Mainnet and Ethereum Mainnet is [`0x1789e0043623282D5DCc7F213d703C6D8BAfBB04`](https://lineascan.build/address/0x1789e0043623282D5DCc7F213d703C6D8BAfBB04).

:::note[Need help?]

This page explains the rationale behind token distribution. If you're looking for help with claiming 
your airdrop, using the token, or any other common issues, see the [Linea support page](https://support.linea.build/linea-hub/airdrop).

:::

## Allocation

LINEA will have a **total supply of 72,009,990,000**. This 1,000x the genesis supply of ETH on 
Ethereum.

85% of the supply of LINEA will be be invested in the community and ecosystem, comprising the 
Ecosystem Fund, with 15% held long-term by Consensys.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/technology/tokenomics/allocation.png"
      alt="Pie chart showing the token allocation"
    />
  </div>
</div>

The supply will be allocated according to the below table:

<table>
	<tr>
		<th>Category</th>
		<th>% of supply</th>
		<th>Details</th>
	</tr>
	<tr>
		<td>Ecosystem</td>
		<td>85%</td>
		<td>75% for a long-term Ecosystem Fund, and 10% for early contributors.</td>
	</tr>
	<tr>
		<td>Consensys treasury</td>
		<td>15%</td>
		<td>Locked (non-transferrable) for five years. Consensys will hold the tokens long-term for 
		alignment and to support Linea and its ecosystem.</td>
	</tr>
</table>

Except from the initial allocation to Consensys, which is locked for five years, there is **no 
allocation to private investors, insiders, or employees and team members**. Instead, value is 
funneled straight into the ecosystem, the builders bringing it to fruition, and the community members 
engaging with it. 

At the time of the token generation event (TGE), 22% of the LINEA supply will be in circulation, 
split between a user and builder airdrop, ecosystem activations, and liquidity provisioning.

All other allocations will be locked at TGE, or vesting according to various schedules.

## Ecosystem (85%)

### Early contributors (10%)

The initial airdrop for early contributors, comprising 10% of the supply, will include:
- 9% to early contributors
- 1% to strategic builders

The early contributor airdrop for users will be based on onchain activity over the long term, including 
LXP. An eligibility checker will be available before TGE. The 1% allocation for builders will be 
distributed through a curated, targeted process for maximum impact.
	
All tokens distributed through the above airdrops are fully unlocked.

### Ecosystem Fund (75%)

The long-term section of the Ecosystem Fund will be managed by the Linea Consortium.

This 75% will unlock over 10 years, with unlocks weighted towards the earlier years to encourage 
early activation and adoption. Unlocks occur early — 10% per year in the early years, tapering to 2% 
by the tenth year.

These funds will be used for:
- Funding for Ethereum R&D
- Maintaining shared ecosystem infrastructure such as audits, developer tools, and node infrastructure
- Funding public goods, such as open-source software, research, and community programs
- Strategic co-development with aligned organizations or emerging protocols.

## Consensys treasury (15%)

15% of the total token supply will be incorporated into the Consensys treasury. This allocation will 
be locked for five years and is non-transferrable until a vesting schedule is complete.

## Burning mechanism

Linea and the LINEA token are designed specifically to reinforce the strength of Ethereum and ETH, 
achieved through an automatic, dual-burn mechanism:
- All gas fees on Linea are paid in ETH
- 20% of net ETH profits (Linea revenue minus operating costs and subsidies) will be burned, 
  reducing ETH supply
- 80% of net ETH profits are used to burn LINEA, reducing LINEA supply.

As a result, network activity on Linea directly supports both the value of ETH and LINEA. 


==================== FILE: /workspace/docs/technology/coordinator.mdx ====================

---
title: Coordinator
sidebar_position: 2
image: /img/socialCards/coordinator.jpg
---

## What is it?

The Coordinator is Linea’s coordination module across a number of functions. It is also the channel through which information on the state of Ethereum comes into Linea, and through which information on the state of Linea returns to Ethereum.

## What does it do?

The Coordinator moves information internally, between different parts of Linea’s execution client, and externally, with other blockchains, Linea’s data availability stack, and the nodes syncing its own network state. In this way, **the Coordinator is Linea’s consensus client.**

## How does it do it?

It does these things through a highly modularized internal architecture. These various systems and requirements are broken out into their own environments, each one receiving input from the Coordinator, and returning the corresponding output back to it.


==================== FILE: /workspace/docs/technology/canonical-token-bridge.mdx ====================

---
title: Canonical token bridge
sidebar_position: 1
image: /img/socialCards/canonical-token-bridge.jpg
---

import CodeBlock from "@theme/CodeBlock";
import TokenBridge from "!!raw-loader!/files/testnet/ITokenBridge.sol";
import TokenBridgeL1 from "!!raw-loader!/files/testnet/canonical-token-bridge/TokenBridgeL1.abi";
import TokenBridgeL2 from "!!raw-loader!/files/testnet/canonical-token-bridge/TokenBridgeL2.abi";
import LineaBridgeGraphic from "/img/get_started/concepts/canonical_token_bridge/Linea_canonical_token_bridge.svg";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<div className="img-large">
  <LineaBridgeGraphic />
</div>

The canonical token bridge is the pair of “lock & mint” contracts that allow bridging of any 
ERC-20 token. The bridge relies on the [message service](./message-service/index.mdx)
for cross-chain interactions.

The Linea team operates a UI for the [official Linea bridge](https://linea.build/hub/bridge/).

The canonical token bridge is optimized for technical partners who are deploying on Linea. 
We recommend that everyday users of Linea seeking to bridge their personal tokens between 
networks leverage one of the many bridges deployed to the network.

Linea seeks to foster a permissionless, resilient, decentralized environment — not to have our 
bridge be a centralized arbiter and point of failure.

To find out which bridges are currently operating on Linea, head to the [ecosystem portal](https://linea.build/hub/apps) 
and click on the **Bridge** button to show all that are available.

## Contracts

<Tabs className="my-tabs">

<TabItem value="Mainnet" label="Mainnet">

- **Ethereum Mainnet**

  <details>
    <summary>TokenBridge.abi</summary>
    <CodeBlock language="json">{TokenBridgeL1}</CodeBlock>
  </details>

  - Contracts:
    - [Canonical token bridge](https://etherscan.io/address/0x051F1D88f0aF5763fB888eC4378b4D8B29ea3319)

- **Linea Mainnet**

  <details>
    <summary>TokenBridge.abi</summary>
    <CodeBlock language="json">{TokenBridgeL2}</CodeBlock>
  </details>

  - Contracts:
    - [Canonical token bridge](https://lineascan.build/address/0x353012dc4a9a6cf55c941badc267f82004a8ceb9)

</TabItem>
<TabItem value="Linea Sepolia" label="Linea Sepolia">

- **Ethereum Sepolia**

  <details>
    <summary>TokenBridge.abi</summary>
    <CodeBlock language="json">{TokenBridgeL1}</CodeBlock>
  </details>

  - Contracts:
    - [Canonical token bridge](https://sepolia.etherscan.io/address/0x5A0a48389BB0f12E5e017116c1105da97E129142)

- **Linea Sepolia**

  <details>
    <summary>TokenBridge.abi</summary>
    <CodeBlock language="json">{TokenBridgeL2}</CodeBlock>
  </details>

  - Contracts:
    - [Canonical token bridge](https://sepolia.lineascan.build/address/0x93DcAdf238932e6e6a85852caC89cBd71798F463)

</TabItem>
</Tabs>

## How to use

### Workflow

1. Triggering the transfer

- **Without Permit**
  - User should first allow the bridge to transfer tokens on their behalf
  - This is done by calling `allowance()` on the TokenBridge.
  - Then, the user should call the `bridgeToken()` method.
- **With Permit**
  - User can call `bridgeTokenWithPermit()` to pass permit data in a single transaction

2. Triggering the delivery

- See the [message service workflow](./message-service/reference.mdx#usage).

## Interface TokenBridge.sol

<details>
  <summary>ITokenBridge.sol</summary>
  <CodeBlock language="solidity">{TokenBridge}</CodeBlock>
</details>


==================== FILE: /workspace/docs/technology/state-manager.mdx ====================

---
title: EVM state manager
description: How state management works on Linea
sidebar_position: 4
image: /img/socialCards/evm-state-manager.jpg
---

The state manager is the part of the execution client responsible for updating the state of the 
network globally, and the state of every account individually. The state manager also audits the
"read" access made in the EVM, meaning it monitors, verifies, and logs all operations where the
EVM needs to read data from the blockchain state.

:::info

"State" refers to the data stored on the blockchain at any given point in time. To
update state is to update the record of the contents of every account whose contents have 
changed. 

:::

The main task of the state manager is to receive blocks that have been executed by the [sequencer](./sequencer/index.mdx) 
and use the trace data from their execution to update the state of the network. Linea uses two 
data structure types to manage state: 
1. A Merkle-Patricia Trie to record the world state, maintain consensus, and process blocks. This 
mirrors how consensus and state are [managed on Ethereum Mainnet](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/). 
2. A variant of regular Merkle trees called a sparse Merkle tree (SMT), which is used to more 
efficiently track, manage, and update storage slots representing accounts. 

It then passes this updated network state information to the [prover](./prover/index.mdx) 
in the form of Merkle proofs for submission to Ethereum Mainnet (L1). 

Below, we'll explain the element of Linea's state management in greater detail, focussing on the 
SMT configuration that sets Linea apart.

## Merkle trees

The Merkle tree and its variations are commonly used across EVM chains to store and retrieve 
data about the state of every account on the blockchain. 

A Merkle tree is comprised of 'nodes' that branch off from each other. At the base is the 'root', 
or state root, from which branches stem, and leaves stem from the branches. 

<div class="img-large">
  <div class="mermaid-medium">
    ```mermaid
        flowchart TD
            A[root] --> B[node] & C[node]
            B --> D[node] & E[node]
            C --> F[node] & G[node]
    ```
  </div>
</div>

Each node, regardless of type, is represented by a cryptographic hash which encodes data about its 
properties — for example, the contents of your account. Each hash encodes the hashes of its child 
nodes. Taken to its full extent, this cascading system means the root encodes data of the state of 
every single account on the blockchain. 

Cryptographic hashes are deterministic, which means you can reverse the hash function to get the 
data which it encoded. If you have the hash of the root—the only node without a parent—you can 
theoretically derive from it the data of any node in the entire tree. 

As a layer 2 (L2) network, Linea is in the business of making transacting faster and more efficient.
Linea implements a sparse Merkle tree to track account state and generate and store proofs, and 
unlock greater efficiency when compared to standard Merkle trees, which require recomputation for 
every block, leading to excessive computational demands.

### Sparse Merkle trees

Linea's state management uses sparse Merkle trees to minimize computation and contribute to the 
blockchain's efficiency. 

A sparse Merkle tree is a variation of a standard Merkle tree where not all leaf nodes are filled 
with data; instead, data is only stored in nodes where it's needed. It is a complete tree of fixed 
depth, meaning that all branches of the tree have the same length—i.e. the same number of leaves. 

At initialization—the beginning of the chain's history—all leaf nodes are set to a default value, 
which is typically a hash of a specific value, such as zero. Because all leaf nodes have the same 
hash value, the parent nodes and higher-level nodes also have the same hash value. A node whose 
hash is the default value for its level is therefore considered to represent an _empty_ subtree. 

<div class="center-container">
  <div class="mermaid-medium">
    ```mermaid
    flowchart TD
        A[root] --> B["`**node A**`"
        null] & C["`**node B**`"
        contains data]
        B --> D["`**node C**`":
        null] & E["`**node D:**`"
        null]
        C --> F["`**node E**`":
        data] & G["`**node F**`":
        data]
    ```
  </div>
</div>

In the example above, the children of node A (leaves) contain null values, which means node A does 
too. Node B, meanwhile, reflects that its children also contain values.

With this construction, we do not need to keep track of every individual node's hash. Instead, we 
can assume hashes that reflect the default value are empty, and the subtree or node that lies 
further down the chain of nodes can be disregarded; we only need to pay attention to the ones that 
correspond to _non-empty_ subtrees.

## Cryptographic accumulator

In this context, we can consider Linea's sparse Merkle tree as a type of "cryptographic 
accumulator". A cryptographic accumulator is a type of cryptographic primitive encoding a collection 
of items into very short strings and allowing read/write operations to be proven. Merkle trees and 
sparse Merkle trees are elementary examples of accumulators but there are others with more powerful 
capabilities.

Linea's state manager uses an extended version of a sparse Merkle tree that enables it to prove all 
CRUD (create, read, update, delete) operations for a key-addressed database. As an outline, the 
construction uses a sparse Merkle tree to store the nodes of a sorted doubly-linked list that 
encodes all the non-zero items of the state.

Linea's state manager uses the accumulator to track the account trie of Linea but also the storage 
of every contract separately.

The leaves of the tree have the following structure: `prev || next || hKey || hVal`.

`hKey` and `hVal` are the hashes of the key and the value of the stored state entry, respectively. 
`prev` and `next` are pointers storing the position of the leaves whose `hKeys` are immediately 
lower and higher, respectively, following lexicographic order. The first two leaves of the SMT are 
called the head and the tail, and are special in that they do not encode a stored tuple. The head is 
the lowest possible `hKey`, while the tail is the highest possible `hKey`. They are therefore 
situated at the beginning and the end of the linked list, respectively. Starting from the head, we 
can access the SMT leaf stored at `head.next` to get the lowest "actually stored" item. Further 
incrementing the `next` value will give us the second-lowest stored item and so on. Repeating the 
process walks us through the entire set of stored items before we end up at the tail node, marking 
the final step.

Leaves can also be referred to as storage slots, in that they contain data about the contents of 
the account in question.

### Tracking empty leaves

All leaves in the tree are populated with default/zero values at initialization. Since a 
deterministic hashing function will ensure that these leaves are always represented by the same 
hash, empty leaves can be easily recognized by the accumulator. 

However, in order for the state manager to update a storage slot with data about a Linea account's 
contents, it must know which empty leaf to overwrite, and exactly where these empty leaves are. A 
further consideration is that we require the index of any 'new' leaf—an empty leaf being updated 
so that it stores data—to be overwritten in a deterministic way. This requirement means that anyone 
can theoretically reconstruct the tree simply by looking at transaction history. 

To ensure consistency in the leaves' position, the state manager only ever inserts 'new' leaves to
the left of the previous leaf in the tree. If this wasn't the case, and the state manager was able
to insert any node in any position, it would be impossible to reconstitute the tree in the exact 
same configuration, severely impacting the ability of L1 to verify the Merkle proof provided.

## Applying the accumulator

The Ethereum Virtual Machine (EVM) uses a variant of a Merkle tree known as a [Merkle-Patricia Trie](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/) to track:
- World state, which keeps track of accounts, and;
- Account storage state (or simply 'storage'), which keeps track of the contents of each account. 

On Linea, we adapt this structure. The Merkle-Patricia Trie is still used for world state, but the
custom cryptographic accumulator described above is used for account storage state.

The accumulator can perform the following operations:
- **Insertion**: adding a new storage slot to the tree, triggered by storing a non-zero value in a 
previously zero-valued slot.
- **Update**: changing the value of an existing storage slot in the tree, triggered by storing a new 
non-zero value in a previously non-zero slot.
- **Deletion**: removing a storage slot from the tree, triggered by storing the zero value in a 
previously non-zero slot.
- **Read zero**: proving non-membership, triggered when a storage slot has been accessed, but not 
updated, and its value is zero.
- **Read non-zero**: proving membership, triggered when a storage slot has been accessed, but not 
updated and its value is non-zero.

These operations are applied to two trees; [world state](#world-state) and [account storage state](#account-storage-state).

### World state

The world state tree maps all accounts that exist on the blockchain—contracts and externally-owned 
accounts (EOAs)—and points towards the account storage state for each. While on Ethereum Mainnet,
this data is stored in a standard trie, Linea uses the accumulator to map accounts as key:value 
pairs. Otherwise, the implementation is similar to the EVM.

Their structure is as follows:

- `HKey`: Hash(`address`)
- `Val`: Hash(`nonce`, `balance`, `storageRoot`, `codeHash`, `keccakCodeHash`, `CodeSize`)

Critically, every piece of data fed into the `Val` (value) hash function must have a finite field
interpretation. The data must be formatted this way to enable the Linea prover to correctly 
access the world state when verifying proofs. Each element is formatted as follows (all elements
require one field, other than `keccakCodeHash`):

- `nonce`: The nonce is written in big-endian form into a `byte32`. For instance if the nonce is 10,
then the nonce should be encoded as `0x000000000000000000000000000000000000000000000000000000000000000a`.
- `balance`: Formatted the same as the nonce; big-endian `byte32`.
- `storageRoot`: The storage root should _not_ be the Keccak of the Patricia trie root as in the 
EVM, but the “custom Merkle tree” root of the account storage state that we describe in the 
[following section](#account-storage-state).
- `codeHash`: The code hash should not be the Keccak of the code, it should instead be the one 
obtained as described in the following section.
- 2 field elements for `keccakCodeHash`: One for the 128 most significant bits and one for the 128 
least significant bits. The Keccak code hash corresponds exactly to the Keccak hash as specified by 
the EVM (i.e. the output of [EXTCODEHASH](https://eips.ethereum.org/EIPS/eip-1052). We keep the 
Keccak and the “custom” version for practical reasons.
- `codeSize`: The code size should be the same value as that returned by the CODESIZE/EXTCODESIZE 
opcodes.

### Account storage state

Also referred to as the storage trie, the account storage state is the database the state manager
accesses to retrieve data about the contents of accounts. Account storage is mainly relevant for
contract accounts; for EOAs, the data about assets and transactions is stored in the [world state](#world-state)
`Val`, and the `codeHash` and its variants are empty. 

Since the main function of account storage is to record contracts in such a way that they can be 
easily retrieved and processed, it must efficiently encode the contract. It does this using the 
following format:

- `HKey`: Hash(`StorageKeyMSB`, `StorageKeyLSB`)
- `Val`: Hash(`StorageValueMSB`, `StorageValueLSB`)

In both cases, the `MSB` refers to the first 16 bytes of a 'word', and `LSB` the last 16. 'Word' in
this context refers to the natural unit of data used by the EVM, which is 256-bit (32 byte) chunks. 

For example, if the data regarding a contract's code was encoded in a `byte32`, the standard data
type for words on the EVM and equivalents like Linea, it might look like this:
```
[a0, a1, a2, …., a15, b0, b1, …, b15]
```

That `byte32` would be split into an `MSB` and `LSB` like this:
- `MSB`: `[0, 0, .., 0, a0, a1, a2, a3, .., a15]`
- `LSB`: `[0, 0, .., 0, b0, b1, b2, b3, .., b15]`

The `MSB` takes the first 16 bytes, and the `LSB` the second 16 bytes. 

## Generating state-root-transition witnesses

The accumulator, built using a sparse Merkle tree, is simultaneously: 

- A data structure on which we can perform operations;
- A dataset that we can summarize using a short string at any time (i.e. the root hash);
- A tool that can be used by the Linea protocol to verify that a given operation triggered a 
transition from hash A to hash B.

Once the accumulator has processed the trace information it receives about a new block and updated
state accordingly, it can pass a new state root hash to the prover, via the coordinator. The state
root hash can then be used by the prover as a "witness": a verifiable method of proving that the
transactions in each block have taken place, without having to divulge the nature of those 
transactions.  


==================== FILE: /workspace/docs/technology/decentralization.mdx ====================

---
title: Decentralization roadmap
sidebar_position: 9
image: /img/socialCards/decentralization-roadmap.jpg
---

The Linea roadmap is currently scoped in five phases which the team intends to deliver sequentially 
in collaboration with the broader Linea ecosystem and community.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/concepts/decentralization/Linea_decentralization_roadmap.png"
      alt="Linea Decentralization Roadmap"
    />
  </div>
</div>

## Phase 0 — Complete

Phase 0 began with the launch of the Linea Mainnet Alpha. From day one, Linea's EVM-equivalent zkEVM 
offered default portability through its implementation of the EVM as specified by the Ethereum 
Foundation. A developer building on Linea can choose at any time to move their dapp to another 
EVM-supported chain, such as Ethereum, in the event they are unsatisfied with the Linea network, 
without re-writing their smart contracts, retooling, or paying for new audits.

During this phase we convened the first iteration of the Linea Security Council, formed to 
monitor the network, protect users, and mitigate the risks associated with a new production system. 
The Security Council is managed through a multi-sig Safe (formerly Gnosis Safe) contract that 
requires certain thresholds of signatures to be submitted to carry out an action. Details can be 
found in our [risk disclosures](../risk-disclosures/index.mdx).

Finally, the client software used to run a local node on the Linea network was made publicly 
available, giving any actor the option to verify the Linea state for themselves and minimize trust 
in the Linea operator. View our [node running guides](../get-started/how-to/run-a-node/index.mdx) to get started.

## Phase 1 — Current

There are two significant components in this phase: the **open-source stack** and ensuring **100% 
EVM coverage**.

Open-sourcing Linea's software stack is an essential element of our roadmap, fostering transparency 
and aligning with web3 values. The Linea software stack is publicly available under the 
[AGPL-2.0](https://apache.org/licenses/LICENSE-2.0) license, which ensures that users have the 
freedom to view, fork, and modify the code. An overview of Linea's repositories is available in 
our [architecture section](./repos.mdx). 

The second cornerstone of this phase is the implementation of **100% EVM coverage** in the zkEVM 
arithmetization. Linea will generate proofs of computation for all EVM opcodes and precompiles,
unlocking trustless execution for all use cases. The specification for the arithmetization 
will be published, audited, and open to bug bounties to increase the security and reliability of 
the system.

## Phase 2 

There are two significant components in this phase: **diversifying the Security Council**, and 
enabling **censorship-resistant withdrawals**.

**Diversifying the Security Council** forms the first part of this stage. The Security Council 
established during Linea's Mainnet Alpha launch plays a critical role in the oversight and control 
of the network. However, to prevent the concentration of power and potential bias, we plan to expand 
participation in the council, while also retaining a 6-of-8 multisig threshold (or stricter) for 
immediate upgrades. This modification ensures a balanced representation and fosters more robust 
collective decision-making, adding an additional layer of checks and balances to the system.

Closely tied to our principle of user sovereignty, enabling **censorship-resistant withdrawals** is 
a fundamental element of our roadmap. The architecture will be refined to prevent rollup operators 
from preventing user withdrawals. We will ensure that users can independently initiate exits, which 
guarantees continuous access to, and control over their assets on Linea. This assurance amplifies 
user confidence and upholds our commitment to ensuring users have sovereignty over their assets.

Through these initiatives, our Phase 2 aims to further decentralize power, enhance transparency, 
and boost the user experience, all while maintaining robust security and control measures.

## Phase 3

In this phase, we turn our focus to decentralizing the roles crucial to the functioning of the Linea 
ecosystem, as well as our governance system itself, thereby further reinforcing our commitment to 
trust minimization and decentralization.

The first part of this phase is **decentralizing operators**. At present, provers and sequencers, 
which generate zero-knowledge proofs and manage Layer 2 transactions respectively, are crucial 
roles within our ecosystem. By decentralizing these roles, we aim to significantly bolster the trust 
of our network participants and the overall integrity of our system. We acknowledge the technical 
complexities this may bring, such as potential latency, increased transaction costs, and potential 
MEV (maximum extractable value) issues. However, we are committed to navigating these challenges to 
shepherd forward a trustworthy, efficient platform for the community.

The second component of this phase is **decentralizing governance**. We believe that democratizing 
Linea's governance is key to our continued evolution. This approach fosters an equitable, 
transparent system where all stakeholders can participate and the future of Linea is steered by its 
user community. This shared governance not only mitigates unilateral decisions and the risk of a 
single point of failure but also reinforces the resilience of the network. In turn, this promotes 
collective ownership and trust among network participants, thereby enhancing the ecosystem's 
sustainable growth.

## Phase 4

The final phase of our roadmap, aims to further ensure the robustness of our ecosystem and mitigate 
trust-related risks through the implementation of a **multi-prover** and by **limiting governance 
powers**.

The EVM will continue to evolve as described in the Ethereum roadmap and will be driven by the 
larger Ethereum community and Ethereum Foundation. Therefore, in order to make changes to the Linea 
network at a reasonable pace and safeguard against implementation risk, we plan to incorporate 
multiple diverse implementations of a zkEVM prover, known as a **multi-prover** rollup. With each 
transaction on Linea verified by multiple heterogeneous implementations of the zkEVM, we can ensure 
that even if one prover encounters a bug or becomes unavailable, which is not improbable given the 
complexity, the system continues to operate uninterrupted. This approach not only boosts confidence 
in the reliability of our platform during a period where the EVM specification is constantly 
evolving but also encourages the exploration of innovative advancements, all while maintaining 
exceptional levels of system uptime.

Lastly, as part of our commitment to a robust and decentralized governance model limiting governance 
to where it is only necessary, we plan to **limit governance powers**. Upgrades to the rollup logic 
will be immutable, allowing upgrades only to be made to the verifier given a change in the EVM 
specification, of which users will be given reasonable notice to exit the rollup.

The role of the Security Council will be delineated to step in only in case of discrepancies or 
potential system issues, such as when the prover system disagrees or appears to be stuck. By 
implementing these measures, we hope to strike a balance between governance where necessary and the 
principles of decentralization.


==================== FILE: /workspace/docs/technology/sequencer/conflation.mdx ====================

---
title: Conflation
sidebar_position: 2
image: /img/socialCards/conflation.jpg
---

import ConflationGraphic from '/img/get_started/concepts/sequencer/conflation/Linea_block_conflation.svg';

<div className="img-large">
    <ConflationGraphic />
</div>

## What is it?

Conflation is the process of combining two or more blocks’ worth of transactions into one data set. It can then be used to produce a ‘before and after’ map of the network state (a Merkle tree, in technical terms) as well as a zero-knowledge proof, which is published to Ethereum.

## What does it do?

Conflation is not normally seen in mainnet Ethereum environments, where transaction data must be published in discrete blocks, one by one in order, before the next block can be published. In a zkEVM environment, the ‘source of truth’ from Ethereum’s perspective is the data submitted to it: the ZK proof, the list of transactions proved by it, and the Merkle tree. That means that it’s not a question of “how many transactions fit in a block”, but “how many transactions fit in a proof”. By conflating multiple blocks into one, Linea's proving system becomes much more efficient.

## How does it do it?

Conflation occurs within the execution client, but through a process of communication with the Coordinator:

- The conflator waits for a traces file to appear
- Marks that blocks' worth of traces as "merged"
- Waits a certain amount of time in case more block data comes in
  - If it does, it checks to see if the number of lines in the block and the length of the data would exceed the limit
    - If it's within the limit, the conflator marks it as merged as well

The conflator continues this cycle until the time limit is reached, at which point it passes the conflated trace data back to the Coordinator, for subsequent Merkle tree and proof generation.


==================== FILE: /workspace/docs/technology/sequencer/traces-generator.mdx ====================

---
title: Traces generation
sidebar_position: 1
image: /img/socialCards/traces-generation.jpg
---

## What is it?

The part of Linea’s sequencer responsible for generating the data used by the prover to create ZK proofs, and for making them as compact as possible.

## What does it do?

The traces generator executes blocks that have been built by the sequencer, and preserves data relating to the traces of each transaction.

## How does it do it?

Once the sequencer has built its blocks, they are executed; and in the process, the EVM produces data known as _traces_. These traces specify the state of the network, and the state of the accounts involved in the transaction, at each granular step of each transaction’s execution. This is the Infinite Improbability Drive at the heart of Linea and its zero-knowledge technology: these traces are the very data that the prover will use to produce a proof. That proof allows Ethereum to know that everything that occurs on Linea truly did occur–without actually knowing any of it.

Linea's sequencer puts these traces through an additional process: **trace conflation.**


==================== FILE: /workspace/docs/technology/sequencer/index.mdx ====================

---
title: Sequencer
sidebar_position: 3
image: /img/socialCards/sequencer.jpg
---

## What is it?

The sequencer is the heart of Linea's execution client, responsible for **ordering, building, and executing blocks** in a way that allows the subsequent zero-knowledge proof to be made.

## What does it do?

The sequencer does a number of things: 

- Determines the order—the _sequence_—in which transactions will be executed 
- Builds blocks from them 
- Executes those blocks 
- Prepares certain data relating to the _traces_ of that execution for the zero-knowledge prover.

## How does it do it?

Linea's execution client is [Linea Besu](https://github.com/Consensys/linea-besu), an 
implementation of the Besu execution client extended with additional functionality to support
Linea and its requirements as a zero-knowledge rollup. You can [run your own Linea Besu node](../../get-started/how-to/run-a-node/linea-besu.mdx). 

Linea's sequencer takes transactions from the Linea memory pool, and builds them into blocks. However, 
on Linea, it also does a bit of extra work, and communication, with the coordinator, to ensure that 
blocks are made in such a way that they can be proven by the zero-knowledge prover, and that they 
are as compact as possible-doubly important in a situation where all data has to be written in 
tiny, costly pieces on Ethereum Mainnet. This is done specifically by subsystems within the 
sequencer: the traces generator and conflator.


==================== FILE: /workspace/docs/technology/network-data.mdx ====================

---
title: Network data
sidebar_position: 7
image: /img/socialCards/network-data.jpg
---

## What is it?

One of the main value propositions of a public blockchain network is that it be, well, _public_. This means that the information about what’s going on the network needs to be readily available. Networks like Ethereum have this more or less built in and available as part of the software: each node has an API that will return any information you ask for; if you have a lot of requests, well, you just need more nodes.

To be clear, that’s how Linea works too–it’s just that Ethereum is decentralized and open; anyone can run a node. Linea is still a testnet, and its nodes are only being run by teams at Consensys. Therefore, in order to provide for the massive interest that the network has generated, a lot of nodes have to be run. This allows dapps to ask for information about the state of the network without impeding the actual execution of transactions by overloading the client.

## What does it do?

Receives and responds to requests from users and dapps according to the Ethereum JSON-RPC API standard. This includes providing information to MetaMask users about their accounts on Linea.

## How does it do it?

By leveraging the expertise and resources of Infura, Consensys, and the Ethereum ecosystem as a whole 😀 Infura is running a number of nodes to provide this service, in two main capacities:

### Client-facing RPC-API nodes

- These nodes do the “traditional” work of EVM nodes: on the one hand, they are receiving updated network state information from the sequencer and state manager, and providing information about that state to users and dapps when they request it. On the other, they are receiving incoming transactions.
- All that traffic means that Infura is running them behind a load balancer, and bringing their expertise in scaling blockchain networks across the operation. Those transactions submitted by users are therefore balanced across the nodes, and are thereby routed into the memory pool, for subsequent ingestion and processing by the Coordinator and sequencer in linea-besu.

### Archive nodes

- There are more and more dapps and research activities being performed not just on current transaction data, but historical data as well–whether from a day ago, last month, or three years ago (though not that long on Linea, yet!).
- This type of data request can be quite resource-intensive, and could put the live network nodes at risk of having their performance impacted, and thus threaten the overall health of the network. For this reason, Infura also has deployed archive nodes in a scalable architecture; these kinds of transactions aren’t being run _all_ the time, after all–but when they are, more nodes are spun up as needed to keep up with demand.


==================== FILE: /workspace/docs/technology/repos.mdx ====================

---
title: Linea repositories
image: /img/socialCards/linea-repositories.jpg
---

import DocCardList from "@theme/DocCardList";

Linea is open source, meaning you can inspect the code yourself. 

Each repository that hosts the Linea software is listed below, together with a description of its 
purpose.

## [`linea-monorepo`](https://github.com/Consensys/linea-monorepo)

The principal Linea repository. This mainly includes the smart contracts covering Linea's core 
functions, the prover in charge of generating ZK proofs, the coordinator responsible for multiple 
orchestrations, and the postman for executing bridge messages. 

## [`linea-specification`](https://github.com/Consensys/linea-specification)

Specification of the constraint system underlying Linea's zkEVM.

Constraints are mathematical equations and a constraint system is a collection of such equations. 
Linea's constraint system aims to capture the logic of valid EVM executions.

The constraints specified here are implemented in the `linea-constraints` repo.

## [`linea-constraints`](https://github.com/Consensys/linea-constraints)

Implementation of the constraint system specified in the `linea-specification` repo.

Linea's constraint system applies to so-called "traces", which are large matrices of fixed width 
(i.e. fixed number of columns or "registries") and variable depth (correlating with the complexity 
of the EVM execution). The production of such traces is the job of the `linea-tracer` repo.

Constraints and traces are two of the inputs to the prover.

## [`linea-tracer`](https://github.com/Consensys/linea-tracer)

Tracing refers to the process of extracting data from the execution of an EVM client in order to 
construct large matrices known as execution traces. Execution traces are subject to the constraint 
system specified in the `linea-specification` repo and implemented in the `linea-constraints` repo.

The repository contains the elements of Linea responsible for this process.

## [`linea-besu`](https://github.com/Consensys/linea-besu)

The Linea implementation of Besu, an Ethereum client, extended with plugins.

As Linea is EVM-equivalent, it is compatible with standard Ethereum clients without plugins; for 
example, you can also [run a Linea node using Erigon, Nethermind, or Geth](../get-started/how-to/run-a-node/index.mdx). 

## [`linea-sequencer`](https://github.com/Consensys/linea-sequencer)

The implementation of the sequencer, the component of Linea responsible for ordering and building 
blocks, as well as executing them. 

## [`gnark`](https://github.com/Consensys/gnark)

Linea's zk-SNARK with a high-level API to design circuits and efficient cryptographic primitives,

## [`shomei`](https://github.com/Consensys/shomei)

A plugin that extends Besu functionality by maintaining and updating Linea's state. 


==================== FILE: /workspace/docs/api/reference/eth-sendrawtransaction.mdx ====================

---
title: eth_sendRawTransaction
description: Simulate transaction submission to help prevent failed transactions.
image: /img/socialCards/ethsendrawtransaction.jpg
---

# `eth_sendRawTransaction`

:::note

`eth_sendRawTransaction` is functionally very similar to the [Ethereum Mainnet equivalent](https://docs.infura.io/api/networks/ethereum/json-rpc-methods/eth_sendrawtransaction). 

The difference lies in the [error responses](#errors). On Linea, `eth_sendRawTransaction` has some 
unique error responses.

:::

Submits a pre-signed and serialized transaction and returns the transaction hash if successful. 
This endpoint can help prevent transactions being rejected due to exceeding the sequencer's 
per-block line limit. If the line count check fails, it returns an error message indicating the 
transaction is likely to be rejected.

:::info

Please note the error relating to exceeding the line limit is only available on Besu nodes using 
version `delivery-25` or later, together with `linea-sequencer` v0.1.4-test28 or later.

:::

On Linea, each transaction is represented by a sequence of lines representing the operations 
happening at the EVM level. These lines are grouped by modules and are used as inputs to the prover. 
In order to limit the resources required to generate proofs, limits are enforced on the maximum 
number of lines each module can have. Hence, when a transaction is considered for inclusion in a 
block, a [line count check is performed to ensure it conforms to the requirements](../../technology/prover/prover-limits.mdx).

## Parameters

`transaction data`: [Required] The signed transaction data.

## Returns

The 32-byte transaction hash, or the zero hash if the transaction is not yet available.

## Example

### Request

```bash
curl https://linea-mainnet.infura.io/v3/YOUR-API-KEY \
-X POST \
-H "Content-Type: application/json" \
-d '{"jsonrpc":"2.0","method":"eth_sendRawTransaction","params": ["0xf869018203e882520894f17f52151ebef6c7334fad080c5704d77216b732881bc16d674ec80000801ba02da1c48b670996dcb1f447ef9ef00b33033c48a4fe938f420bec3e56bfd24071a062e0aa78a81bf0290afbc3a9d8e9a068e6d74caa66c5e0fa8a46deaae96b0833"],"id":1}'
```
### Response

```JSON
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": "0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331"
}
```

## Errors

### Gas price too low

The error `Gas price too low` is thrown when the transaction's gas is too low; specifically, the 
offered gas doesn't create enough of a buffer to ensure that Linea can cover the costs of 
finalizing the transaction on L1.

### Transaction line count above limit

This error will display in the format:
`Transaction line count for module [A] is above the limit [B]`

Where `[A]`  is the module for which the number of lines is above the maximum allowed value `[B]`,
with `[B]` a parameter of the system.


==================== FILE: /workspace/docs/api/reference/linea-getproof.mdx ====================

---
title: linea_getProof
description: Reference content for the linea_getProof method.
image: /img/socialCards/lineagetproof.jpg
---

# `linea_getProof`

Returns the account and storage values, including the Merkle proof, of the specified account.
The supplied block parameter must be an L2 block that has been finalized on L1.

- When an account or storage slot exists, the response includes the `leafIndex` and
    a proof of existence.
- When an account or storage slot doesn't exist, the response will include the proof of the
    elements before and after it in the tree.

In the [example response](#response) the account exists but the slot doesn't.

## Parameters

- `address`: A string representing the address (20 bytes) for which the proof is requested.
- `storageKeys`: An array of 32-byte storage keys to be proofed and included.
- `blockParameter`: A hexadecimal block number, or one of the string tags  `latest`, `earliest`,
      `pending`, or `finalized`.
     
      :::note
      A `finalized` block is a block on an L2 blockchain (Linea) that has been confirmed and validated by
      the L1 blockchain (Ethereum).
      :::

## Returns

- `accountProof`: Provides proof data for the account:
  - `key`: The address of the account for which the proof is generated.
  - `leafIndex`: The index of the leaf node in the sparse Merkle tree that corresponds to the account.
  - `proof`: Object containing the proof data for the account:
    - `proofRelatedNodes`: Array of nodes in the sparse Merkle tree used to construct the proof.
    - `value`: The value stored at the account's leaf node in the sparse Merkle tree.
- `storageProof`: An array of storage-entries as requested. Each entry is an object with these properties:
  - `key`: The requested storage key.
  - `leftLeafIndex`: The index of the left leaf node in the sparse Merkle tree that corresponds to the
      storage slot.
  - `leftProof`: Contains the proof data for the left leaf node, which includes the array of nodes used
      to construct the proof and the value stored at the left leaf node in the sparse Merkle tree.
  - `rightLeafIndex`: The index of the right leaf node in the sparse Merkle tree that corresponds to
      the storage slot.
  - `rightProof`: Contains the proof data for the right leaf node, which includes the array of nodes used
      to construct the proof and the value stored at the right leaf node in the sparse Merkle tree.

## Example

### Request

```bash
curl https://linea-mainnet.infura.io/v3/YOUR-API-KEY \
-X POST \
-H "Content-Type: application/json" \
-d '{
    "jsonrpc": "2.0",
    "method": "linea_getProof",
    "params": [
        "0x87f21c771EAC9c547Eb22312997153D3A1fC40F6",
            ["0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421"], "0x7AA88B"
    ],
    "id": 1
}'
```

### Response

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "accountProof": {
      "key": "0x87f21c771eac9c547eb22312997153d3a1fc40f6",
      "leafIndex": 2410424,
      "proof": {
        "proofRelatedNodes": [
          "0x000000000000000000000000000000000000000000000000000000000075965e0a85198ef8a5f75a15db565de5bff89b409ff5e507a7be546149c32b99044df3",
          "0x008a47a2a53dd5183a2dc127c399a004e2a6c7e60f73e104d7d79e6a2bd7e809008a47a2a53dd5183a2dc127c399a004e2a6c7e60f73e104d7d79e6a2bd7e809",
          "0x060f08aed06ffb90efc9705dc38d37a7000da1add99cef1b8a84b9e72e7c8b7b060f08aed06ffb90efc9705dc38d37a7000da1add99cef1b8a84b9e72e7c8b7b",
          ...
        ],
        "value": "0x0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000001f2f46337996eabca16927c459f3fbdb8fb82672c464aa332b613a3c08db27c03dcbfed33825518e0122265146c2948b3bcb9b173348556e13c462f7a6b1a86f7d11acadc51eaeba164e92ebb5ecbe6c64ebc7d0190f93bf0edebeadf610ad80000000000000000000000000000000000000000000000000000000000001c85"
      }
    },
    "storageProofs": [
      {
        "key": "0x0000000000000000000000000000000000000000000000000000000000000001",
        "leftLeafIndex": 0,
        "leftProof": {
          "proofRelatedNodes": [
            "0x00000000000000000000000000000000000000000000000000000000000000030961e5d86a7bbdaac1547b2abfdb09dcaa0548b3d277a154b8c89081a22195a4",
            "0x008a47a2a53dd5183a2dc127c399a004e2a6c7e60f73e104d7d79e6a2bd7e809008a47a2a53dd5183a2dc127c399a004e2a6c7e60f73e104d7d79e6a2bd7e809",
            "0x060f08aed06ffb90efc9705dc38d37a7000da1add99cef1b8a84b9e72e7c8b7b060f08aed06ffb90efc9705dc38d37a7000da1add99cef1b8a84b9e72e7c8b7b",
            "0x0a06dc31ae8e893bca0a076decb8c0caa9036b5f394abf79d7956411eef322550a06dc31ae8e893bca0a076decb8c0caa9036b5f394abf79d7956411eef32255",
           ...
          ],
          "value": "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        "rightLeafIndex": 2,
        "rightProof": {
          "proofRelatedNodes": [
            "0x00000000000000000000000000000000000000000000000000000000000000030961e5d86a7bbdaac1547b2abfdb09dcaa0548b3d277a154b8c89081a22195a4",
            "0x008a47a2a53dd5183a2dc127c399a004e2a6c7e60f73e104d7d79e6a2bd7e809008a47a2a53dd5183a2dc127c399a004e2a6c7e60f73e104d7d79e6a2bd7e809",
            "0x060f08aed06ffb90efc9705dc38d37a7000da1add99cef1b8a84b9e72e7c8b7b060f08aed06ffb90efc9705dc38d37a7000da1add99cef1b8a84b9e72e7c8b7b",
            "0x0a06dc31ae8e893bca0a076decb8c0caa9036b5f394abf79d7956411eef322550a06dc31ae8e893bca0a076decb8c0caa9036b5f394abf79d7956411eef32255",
            ...
          ],
          "value": "0x0000000000000000000000000000000000000000000000000000000000000064"
        }
      }
    ]
  }
}
```


==================== FILE: /workspace/docs/api/reference/eth-sendbundle.mdx ====================

---
title: eth_sendBundle
description: Send a bundle of signed transactions to be executed atomically.
image: /img/socialCards/ethsendbundle.jpg
---

# `eth_sendBundle`

:::note

Access to this endpoint is permissioned via Infura. Currently, only Infura nodes are able to forward 
the requests to the sequencer.

This method is in private beta and not publicly available for use.

:::

Privately sends a bundle of signed transactions to be executed atomically, allowing the caller to 
define transaction execution order. This enables services such as:
- Frontrunning protection
- Gas abstraction
- Revert protection.

Due to being sent atomically, the bundle will only be executed if all transactions are confirmed.

The method can also improve UX, as users can review and approve a bundle of transactions with one 
click, rather than multiple clicks. (Assuming the dapp and wallet being used have implemented [EIP-5792](https://eips.ethereum.org/EIPS/eip-5792), 
and the wallet supports `eth_sendBundle` on Linea.)

:::info

Methods for cancelling the bundle (`eth_cancelBundle`) or retrieving its status (`eth_getBundleStatus`) 
are not yet supported. To get the bundle status, we recommend wallets use `eth_getTransactionReceipt` 
on each transaction in the bundle. Dapps can fetch status by using the `wallet_getCallsStatus` 
method added in EIP-5792.

:::

## Parameters

- `txs`: An array of signed transactions to execute in the bundle.
- `blockNumber`: Hexadecimal block number for the block the bundle is valid in.
- `minTimestamp`: [optional] A number representing the minimum timestamp for which the bundle is 
valid, in seconds since the unix epoch.
- `maxTimestamp`: [optional] A number representing the maximum timestamp for which the bundle is 
valid, in seconds since the unix epoch.

Additional optional parameters supported [elsewhere](https://docs.flashbots.net/flashbots-auction/advanced/rpc-endpoint#eth_sendbundle) 
are not supported on Linea.

## Returns

- `bundleHash`: The hash of the executed bundle.

## Example

### Request

```bash
curl 'https://linea-mainnet.infura.io/v3/YOUR-API-KEY' \
-H 'Content-Type: application/json' \
-d '{
    "jsonrpc": "2.0","method": "eth_sendBundle","params":[{"txs": ["0x1234567890abcdef...", "0x1234567890abcdef..."],"blockNumber": "0x123..."}],"id": 1}'
```

### Response

```json
{
    "jsonrpc": "2.0",
    "id": 1,
    "result": {
        "bundleHash": "0x1234567890abcdef..."
    }
}
```


==================== FILE: /workspace/docs/api/reference/index.mdx ====================

---
title: Use the Linea API
description: How to make calls to the Linea blockchain using the Linea JSON-RPC APIs
image: /img/socialCards/use-the-linea-api.jpg
---

import DocCardList from "@theme/DocCardList";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Linea supports the standard Ethereum JSON-RPC API methods, meaning the developer experience is
identical to building on Ethereum itself. However, some methods differ to Ethereum, and are covered
in this section.

:::info
View the full list of Linea methods in the
[MetaMask services documentation](https://docs.metamask.io/services/reference/linea/json-rpc-methods/).
:::

You must connect to an RPC endpoint when making calls to the Linea blockchain. Use one or more of the
following options:

- **Run your own node**: Either [run your own node by setting it up yourself](../../get-started/how-to/run-a-node/index.mdx), or
    [use a node provider](../../get-started/tooling/node-providers/index.mdx).
    We recommend running [Linea Besu](../../get-started/how-to/run-a-node/linea-besu.mdx) if you want to run a node yourself and interact with the
    blockchain.
- **Connect to a private RPC endpoint**: [Connect to a blockchain infrastructure provider](../../get-started/tooling/node-providers/index.mdx#private-rpc-endpoints)
    such as Infura or Alchemy. Multiple providers offer free tier access.
- **Use a public endpoint**: [Public endpoints](../../get-started/tooling/node-providers/index.mdx#public-rpc-endpoints) are
    free to use but are rate limited and not suitable for production environments.

## Make calls

The following examples call the Linea API methods using an Infura endpoint, however you can substitute
the endpoint with whichever endpoint you prefer.

In the examples, replace `<YOUR-API-KEY>` with your actual Infura API key.

:::info
View the [list of node providers](../../get-started/tooling/node-providers/index.mdx) if you require an endpoint.
:::


### curl

Run the [`curl`](https://curl.se/) command in a terminal:

```bash
curl https://linea-mainnet.infura.io/v3/<YOUR-API-KEY> \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc": "2.0", "method": "eth_blockNumber", "params": [], "id": 1}'
```

### Node (JavaScript)

The following examples use various JavaScript libraries to make calls to the Linea blockchain.

#### Prerequisites

Install [npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)
or [yarn](https://yarnpkg.com/getting-started/install) as the package manager. Then, in your project
folder, initialise your new project:

    <Tabs>
      <TabItem value="npm">

      ```bash
      npm init -y
      ```
      </TabItem>
      <TabItem value="yarn">

      ```bash
      yarn init -y
      ```
      </TabItem>
    </Tabs>

#### Node Fetch

1. In your project folder, install the `node-fetch` package:

    <Tabs>
      <TabItem value="npm">

      ```bash
      npm i node-fetch
      ```
      </TabItem>
      <TabItem value="yarn">

      ```bash
      yarn add node-fetch
      ```
      </TabItem>
    </Tabs>

1. Create your JavaScript file and copy the following code:

    ```javascript title="index.js"
    const fetch = require("node-fetch");

    fetch("https://linea-mainnet.infura.io/v3/<YOUR-API-KEY>", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "eth_blockNumber",
        params: [],
        id: 1,
      }),
    })
      .then((response) => response.json())
      .then((data) => {
        console.log(data)
      })
      .catch((error) => {
        console.error(error)
      })
    ```

1. Run the code using the following command:

    ```bash
    node index.js
    ```

#### Axios

1. In your project folder, install the `axios` package:

    <Tabs>
      <TabItem value="npm">

      ```bash
      npm i axios
      ```
      </TabItem>
      <TabItem value="yarn">

      ```bash
      yarn add axios
      ```
      </TabItem>
    </Tabs>

1. Create your JavaScript file and copy the following code:

    ```javascript title="index.js"
    const axios = require("axios")

    axios
      .post("https://linea-mainnet.infura.io/v3/<YOUR-API-KEY>", {
        jsonrpc: "2.0",
        method: "eth_blockNumber",
        params: [],
        id: 1,
      })
      .then((response) => {
        console.log(response.data)
      })
      .catch((error) => {
        console.error(error)
      })
    ```

1. Run the code using the following command:

    ```bash
    node index.js
    ```

#### Viem

1. In your project folder, install the `viem` package:

    <Tabs>
      <TabItem value="npm">

      ```bash
      npm i viem
      ```
      </TabItem>
      <TabItem value="yarn">

      ```bash
      yarn add viem
      ```
      </TabItem>
    </Tabs>

1. Create your JavaScript file and copy the following code:

    ```javascript title="index.js"
    const { createClient, http } = require('viem');

    const client = createClient({
      transport: http('https://linea-mainnet.infura.io/v3/<YOUR-API-KEY>')
    });

    client.request({
      method: 'eth_blockNumber',
      params: []
    })
    .then((blockNumber) => {
      console.log(parseInt(blockNumber, 16)); // Convert hex to decimal
    })
    .catch((error) => {
      console.error(error);
    });
    ```

1. Run the code using the following command:

    ```bash
    node index.js
    ```


==================== FILE: /workspace/docs/api/reference/linea-estimategas.mdx ====================

---
title: linea_estimateGas
description: Reference content for the linea_estimateGas method.
image: /img/socialCards/lineaestimategas.jpg
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# `linea_estimateGas`

Generates and returns an estimate of how much gas is necessary to allow the transaction to complete
and be published on Ethereum. The transaction will not be added to the blockchain.

For more information about estimating gas, and how this API formulates the transaction costs, see
the [Estimate transaction costs](../../get-started/how-to/gas-fees.mdx) topic.

The `priorityFeePerGas` returned by this method includes the cost of submitting the transaction to
Ethereum, which can vary based on the size of the calldata.

:::note

`linea_estimateGas` uses the same inputs as the standard
[`eth_estimateGas`](https://docs.infura.io/api/networks/linea/json-rpc-methods/eth_estimategas), but 
returns the recommended gas limit, the base fee per gas, and the priority fee per gas. We recommend 
using `linea_estimateGas` for more accurate results.

:::

## Parameters

- `call`: _\[required]_ Transaction call object:
  - `from`: _\[optional]_ 20 bytes - The address the transaction is sent from.
  - `to`: _\[optional]_ 20 bytes - The address the transaction is directed to.
  - `gas`: _\[optional]_ Hexadecimal value of the gas provided for the transaction execution. `linea_estimateGas` consumes
      zero gas, but this parameter may be needed by some executions.
  - `gasPrice`: _\[optional]_ Hexadecimal value of the gas price used for each paid gas.
  - `maxPriorityFeePerGas`: _\[optional]_ Maximum fee, in wei, the sender is willing to pay per gas above the base fee.
  - `maxFeePerGas`: _\[optional]_ Maximum total fee (base fee + priority fee), in wei, the sender is willing to pay per gas.
  - `value`: _\[optional]_ Hexadecimal value of the value sent with this transaction.
  - `data`: _\[optional]_ Hash of the method signature and encoded parameters. See the
      [Ethereum contract ABI specification](https://docs.soliditylang.org/en/latest/abi-spec.html).
- `stateOverride`: _\[optional]_  Object that contains the address-to-state mapping to [override state values](#override-state-values).
    Each entry specifies a state that will be temporarily overridden before executing the call:
  - `balance`: _\[optional]_ Hexadecimal of the temporary account balance for the call execution.
  - `nonce`: _\[optional]_ Hexadecimal of the temporary nonce value for the call execution.
  - `code` : _\[optional]_ Bytecode to inject into the account.
  - `stateDiff`: `key:value` pairs to override individual slots in the account storage.

## Returns

Hexadecimal values representing the recommended gas limit, the base fee per gas, and the priority 
fee per gas.

## Example

:::tip

You can also call the API using [Infura's supported Linea endpoints](https://docs.metamask.io/services/reference/linea/json-rpc-methods/).

:::

### Request

<Tabs groupId="sdk-lang">
  <TabItem value="curl">

  ```bash
  curl https://linea-mainnet.infura.io/v3/YOUR-API-KEY \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc": "2.0","method": "linea_estimateGas","params": [{"from": "0x971e727e956690b9957be6d51Ec16E73AcAC83A7","gas":"0x21000"}],"id": 53}'
  ```

  </TabItem>
  <TabItem value="ethers.js">

  ```javascript
  type LineaEstimateGasResponse = {
    baseFeePerGas: string;
    priorityFeePerGas: string;
    gasLimit: string;
  };

  const provider = new ethers.JsonRpcProvider("<RPC_URL>");

  const params = {
    from: "0x...", // Signer address
    to: "0x...", // Recipient address
    value: ethers.parseEther("1").toString(), // Value in wei
    data: "0x...", // Encoded call in case of smart contract interaction
  };

  const fees: LineaEstimateGasResponse = await provider.send("linea_estimateGas", [params]);
  console.log(fees);
  ```
  </TabItem>
  <TabItem value="viem">

  ```javascript
  import { createPublicClient, http, parseEther } from 'viem'
  import { linea } from 'viem/chains'
  import { estimateGas } from 'viem/linea'

  async function EstimateGas() {
    const client = createPublicClient({
      chain: linea,
      transport: http(),
    });

    try {
      const gasEstimate = await estimateGas(client, {
        account: '0x...', // Source account's address
        to: '0x...', // Destination account's address
        value: parseEther('0.004') // Amount of ETH to transfer
      });
      console.log('Gas Estimate:', gasEstimate);
    } catch (error) {
      console.error('Error estimating gas:', error);
    }
  }

  EstimateGas();
  ```

  </TabItem>
</Tabs>

### Response

<Tabs groupId="sdk-lang">
  <TabItem value="curl">

```JSON
{
  "jsonrpc": "2.0",
  "id": 53,
  "result": {
    "baseFeePerGas": "0x7",
    "gasLimit": "0xcf08",
    "priorityFeePerGas": "0x43a82a4"
  }
}
```

  </TabItem>
  <TabItem value="ethers.js">

  ```javascript
  {
    baseFeePerGas: "0x7",
    gasLimit: "0xcf08",
    priorityFeePerGas: "0x43a82a4"
  }
  ```
  </TabItem>
  <TabItem value="viem">

  ```javascript
  {
    baseFeePerGas: 7n,
    gasLimit: 53000n,
    priorityFeePerGas: 4444716n
  }
  ```

  </TabItem>
</Tabs>

Where:
- `baseFeePerGas` - Uses the Linea base fee which is set at 7 wei.
- `gasLimit` - Uses the standard `eth_estimateGas` API calculation.
- `priorityFeePerGas` - Calculates the fee required to prioritize a transaction by considering factors such as the
    compressed transaction size, layer 1 verification costs and capacity, gas price ratio between layer 1 and
    layer 2, the transaction's gas usage, the minimum gas price on layer 2, and a minimum
    margin (for error) for gas price estimation.

:::note

The result of the request returns hexadecimal equivalent integers of gas prices in wei. Convert the hexadecimal value into
decimals to get the wei value. You can use any hexadecimal to decimal converter such as
[RapidTables](https://rapidtables.com/convert/number/hex-to-decimal.html).

:::

## Override state values

You can override an account with temporary state values before making the call. This allows you to
make temporary state changes without affecting the actual blockchain state.

The following example estimates the cost for transferring an ERC-20 token for an account which does not
have the required assets onchain.

The example sets a custom ETH balance for the sender (to cover gas costs) and modifies the account's
balance within the ERC-20 contract's storage for the duration of the call.

```json
curl https://linea-mainnet.infura.io/v3/<YOUR-API-KEY> \
-X POST \
-H "Content-Type: application/json" \
-d '{
  "jsonrpc":"2.0",
  "method":"linea_estimateGas",
  "params":[
      {
          "from":"0xfe3b557e8fb62b89f4916b721be55ceb828dbd73",
          "to":"0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f",
          "data":"0xa9059cbb000000000000000000000000627306090abaB3A6e1400e9345bC60c78a8BEf570000000000000000000000000000000000000000000000001bc16d674ec80000"
      },
      {
          "0xfe3b557e8fb62b89f4916b721be55ceb828dbd73": {
              "balance": "0x16345785d8a0000"
          },
          "0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f": {
              "stateDiff":{
                  "0x2d206e5210c119b1cbed144f517f1f1dfd586eed26793a233e6afc261f4cf97f":"0x0000000000000000000000000000000000000000000000001bc16d674ec80000"
              }
          }
      }
  ],
  "id":53
}'
```


==================== FILE: /workspace/docs/api/reference/linea-gettransactionexclusionstatusv1.mdx ====================

---
title: linea_getTransactionExclusionStatusV1
description: Reference content for the linea_getTransactionExclusionStatusV1 method.
image: /img/socialCards/lineagettransactionexclusionstatusv1.jpg
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# `linea_getTransactionExclusionStatusV1`

Queries a temporary database maintained by the transaction exclusion API service to check if a 
transaction was rejected by the sequencer, connected P2P node, or RPC nodes for exceeding data line limits 
that would prevent the prover from generating a proof.


:::info

You can only check for transaction rejection within seven days of the transaction attempt. Querying
transactions older than this will return a `null` response.

:::

If the transaction is rejected, the API call will succeed and provide the reason; otherwise, it
will return `null`.

## Parameters

`txHash`: [Required] The hash of the subject transaction.

## Returns

- `txHash`: The hash of the subject transaction. 
- `from`: The public address of the account that sent the transaction. 
- `nonce`: Number of transaction made by the sender, in hexadecimal format. 
- `txRejectionStage`: A string detailing the point at which the transaction was rejected. One of:
    - `SEQUENCER`: Rejected by the sequencer.
    - `RPC`: Rejected by an RPC node (e.g. `https://rpc.linea.build`).
    - `P2P`: Rejected by a P2P-connected node (for example, a bootnode). 
- `reasonMessage`: Explains why the transaction was rejected. 
- `blockNumber`: The block that the transaction was rejected from, in hexadecimal format. Only 
returned for transactions rejected by the sequencer. 
- `timestamp`: Time of rejection, in ISO 8601 format. 

## Example

### Request

<Tabs>
    <TabItem value="curl">
        ```bash
        curl https://linea-mainnet.infura.io/v3/YOUR-API-KEY \
        -X POST \
        -H "Content-Type: application/json" \
        -d '{
            "jsonrpc": "2.0",
            "id": "1",
            "method": "linea_getTransactionExclusionStatusV1",
            "params": ["0x526e56101cf39c1e717cef9cedf6fdddb42684711abda35bae51136dbb350ad7"]
        }'
        ```
    </TabItem>
</Tabs>

### Response

<Tabs>
    <TabItem value="JSON">
        ```json
        {
            "jsonrpc": "2.0",
            "id": "1",
            "result": {
                "txHash": "0x526e56101cf39c1e717cef9cedf6fdddb42684711abda35bae51136dbb350ad7",
                "from": "0x4d144d7b9c96b26361d6ac74dd1d8267edca4fc2",
                "nonce": "0x64",
                "txRejectionStage": "SEQUENCER",
                "reasonMessage": "Transaction line count for module ADD=402 is above the limit 70",
                "blockNumber": "0x3039",
                "timestamp": "2024-08-22T09:18:51Z"
            }
        }
        ```
    </TabItem>
</Tabs>

:::note

This example is purely representative; the database retains transaction data for only seven days, so
you'll be unable to reproduce this response with the above example.

:::

If a transaction was not rejected for exceeding line limits, it will not be found in the database, 
and a `null` result is returned. For example:

```json
{
    "jsonrpc": "2.0",
    "id": 1,
    "result": null
}
```

A similar `null` result is also returned if the transaction is older than seven days.


==================== FILE: /workspace/docs/api/token-api/overview.mdx ====================

---
title: Token API
image: /img/socialCards/token-api.jpg
---

The Token API provides comprehensive programmatic access to token data on the Linea network. This
API is designed for developers, builders and analysts who need detailed information about ERC-20
tokens and their activity on Linea.

## Key features

### Token data
- Complete list of available tokens on Linea
- Detailed token metadata (name, symbol, decimals, logo)
- Current and historical prices
- Trading statistics (buy/sell counts)
- Fairly diluted valuation

### Market analytics
- Most traded tokens in the last 24h
- Top movers, gainers and losers (price variation)
- Price movement tracking

### Use cases
- Token monitoring dashboards
- Onchain data analysis
- DeFi application integration
- Wallet and transaction tracking
- Filter by secure tokens
- Automated trading bots

## Data sources

Data is collected and updated from multiple sources:

### Primary sources
- Onchain data (smart contract states)
- [CoinGecko](https://coingecko.com/en/api)
- MetaMask Token & Price API
- [Dune Analytics](https://dune.com/)
- [Nile](https://nile.build/)
- [Moralis](https://moralis.com/)

Please see the [Linea terms of use](https://linea.build/terms-of-service) about third party
information.

### Update frequencies
- Token detection and metadata: every two hours
- Historical prices: hourly
- Current prices: every five minutes

## Usage examples

### Filter tokens by security

Getting a raw list of tokens is good, but getting a list of tokens that are secure is even better.
You can filter tokens according to their security status using the `isSecure` query parameter.

For a token to be considered as secure,
it must have a Moralis security score greater than 70 and a market capitalization greater than $50k.

```typescript
async function getSecureTokens() {
  const BASE_URL = "https://token-api.linea.build";
  const tokens = await fetch(`${BASE_URL}/tokens?isSecure=true`).then(r => r.json());
  console.log('Secure tokens:', tokens);
}
```

### Get new gems

New gems are tokens that were recently deployed and may be the next big thing.
Adding an `isSecure` filter might be a good idea to avoid scams.

```typescript
async function getNewGems() {
  const BASE_URL = "https://token-api.linea.build";
  const tokens = await fetch(`${BASE_URL}/tokens?order=createdAt&sort=desc`).then(r => r.json());
  console.log('Recent tokens:', tokens);
}
```

### Get most-swapped tokens

You can get the most-swapped tokens in the last 24 hours using the `swaps` ordering parameter.


```typescript
async function getMostSwapped() {
  const BASE_URL = "https://token-api.linea.build";
  const tokens = await fetch(`${BASE_URL}/tokens?order=swaps&sort=desc`).then(r => r.json());
  console.log('Most swapped tokens:', tokens);
}
```

### Simple token price bot

```typescript
async function monitorPriceChange(contractAddress: string, threshold: number) {
  const BASE_URL = "https://token-api.linea.build";
  const { currentPrice: initialPrice } = await fetch(`${BASE_URL}/tokens/${contractAddress}`).then(r => r.json());

  setInterval(async () => {
    const { currentPrice } = await fetch(`${BASE_URL}/tokens/${contractAddress}`).then(r => r.json());
    const priceChange = (currentPrice - initialPrice) / initialPrice;

    if (Math.abs(priceChange) > threshold) {
      // Execute something, e.g. send a notification or trigger a trade
      console.log(`Price changed by ${priceChange}% - Trading signal`);
    }
  }, 60000); // Check every minute
}
```

## Best practices

1. **Rate limiting**
- This API has strict rate limits per IP:
  - Two requests per second
  - 60 requests per minute
- Cache static data
- Implement backoff strategies

2. **Error handling**
- Check HTTP status codes
- Implement retry with exponential backoff
- Validate token addresses

3. **Performance and security**
- Use pagination for large lists
- Use local caching when appropriate
- Validate and sanitize all inputs


==================== FILE: /workspace/docs/api/linea-smart-contracts/zkevmv2.mdx ====================

# `ZkEvmV2`

### MODULO_R

```solidity
uint256 MODULO_R
```

### OPERATOR_ROLE

```solidity
bytes32 OPERATOR_ROLE
```

### currentTimestamp

```solidity
uint256 currentTimestamp
```

_DEPRECATED in favor of currentFinalizedState hash._

### currentL2BlockNumber

```solidity
uint256 currentL2BlockNumber
```

The most recent finalized L2 block number.

### stateRootHashes

```solidity
mapping(uint256 => bytes32) stateRootHashes
```

The most recent L2 state root hash mapped by block number.

### verifiers

```solidity
mapping(uint256 => address) verifiers
```

The verifier address to use for a proof type when proving.

### _verifyProof

```solidity
function _verifyProof(uint256 _publicInput, uint256 _proofType, bytes _proof) internal
```

Verifies the proof with locally computed public inputs.

_If the verifier based on proof type is not found, it reverts with InvalidProofType._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _publicInput | uint256 | The computed public input hash cast as uint256. |
| _proofType | uint256 | The proof type to determine which verifier contract to use. |
| _proof | bytes | The proof to be verified with the proof type verifier contract. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/interfaces/ipermissionsmanager.mdx ====================

# `IPermissionsManager`

### RoleAddress

```solidity
struct RoleAddress {
  address addressWithRole;
  bytes32 role;
}
```



==================== FILE: /workspace/docs/api/linea-smart-contracts/interfaces/imessageservice.mdx ====================

# `IMessageService`

### MessageSent

```solidity
event MessageSent(address _from, address _to, uint256 _fee, uint256 _value, uint256 _nonce, bytes _calldata, bytes32 _messageHash)
```

Emitted when a message is sent.

__calldata has the _ because calldata is a reserved word.
We include the message hash to save hashing costs on the rollup.
This event is used on both L1 and L2._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _from | address | The indexed sender address of the message (msg.sender). |
| _to | address | The indexed intended recipient address of the message on the other layer. |
| _fee | uint256 | The fee being being paid to deliver the message to the recipient in Wei. |
| _value | uint256 | The value being sent to the recipient in Wei. |
| _nonce | uint256 | The unique message number. |
| _calldata | bytes | The calldata being passed to the intended recipient when being called on claiming. |
| _messageHash | bytes32 | The indexed hash of the message parameters. |

### MessageClaimed

```solidity
event MessageClaimed(bytes32 _messageHash)
```

Emitted when a message is claimed.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _messageHash | bytes32 | The indexed hash of the message that was claimed. |

### FeeTooLow

```solidity
error FeeTooLow()
```

_Thrown when fees are lower than the minimum fee._

### ValueSentTooLow

```solidity
error ValueSentTooLow()
```

_Thrown when the value sent is less than the fee.
Value to forward on is msg.value - _fee._

### MessageSendingFailed

```solidity
error MessageSendingFailed(address destination)
```

_Thrown when the destination address reverts._

### FeePaymentFailed

```solidity
error FeePaymentFailed(address recipient)
```

_Thrown when the recipient address reverts._

### sendMessage

```solidity
function sendMessage(address _to, uint256 _fee, bytes _calldata) external payable
```

Sends a message for transporting from the given chain.

_This function should be called with a msg.value = _value + _fee. The fee will be paid on the destination chain._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _to | address | The destination address on the destination chain. |
| _fee | uint256 | The message service fee on the origin chain. |
| _calldata | bytes | The calldata used by the destination message service to call the destination contract. |

### claimMessage

```solidity
function claimMessage(address _from, address _to, uint256 _fee, uint256 _value, address payable _feeRecipient, bytes _calldata, uint256 _nonce) external
```

Deliver a message to the destination chain.
Is called by the Postman, dApp or end user.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _from | address | The msg.sender calling the origin message service. |
| _to | address | The destination address on the destination chain. |
| _fee | uint256 | The message service fee on the origin chain. |
| _value | uint256 | The value to be transferred to the destination address. |
| _feeRecipient | address payable | Address that will receive the fees. |
| _calldata | bytes | The calldata used by the destination message service to call/forward to the destination contract. |
| _nonce | uint256 | Unique message number. |

### sender

```solidity
function sender() external view returns (address originalSender)
```

Returns the original sender of the message on the origin layer.

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| originalSender | address | The original sender of the message on the origin layer. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/interfaces/iratelimiter.mdx ====================

# `IRateLimiter`

### RateLimitInitialized

```solidity
event RateLimitInitialized(uint256 periodInSeconds, uint256 limitInWei, uint256 currentPeriodEnd)
```

Emitted when the Rate Limit is initialized.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| periodInSeconds | uint256 | The time period in seconds the rate limiter has been initialized to. |
| limitInWei | uint256 | The limit in Wei the rate limiter has been initialized to. |
| currentPeriodEnd | uint256 | The time the current rate limit period will end. |

### AmountUsedInPeriodReset

```solidity
event AmountUsedInPeriodReset(address resettingAddress)
```

Emitted when the amount in the period is reset to zero.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| resettingAddress | address | The indexed address of who reset the used amount back to zero. |

### LimitAmountChanged

```solidity
event LimitAmountChanged(address amountChangeBy, uint256 amount, bool amountUsedLoweredToLimit, bool usedAmountResetToZero)
```

Emitted when the limit is changed.

_If the current used amount is higher than the new limit, the used amount is lowered to the limit.
amountUsedLoweredToLimit and usedAmountResetToZero cannot be true at the same time._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| amountChangeBy | address | The indexed address of who changed the rate limit. |
| amount | uint256 | The rate limited amount in Wei that was set. |
| amountUsedLoweredToLimit | bool | Indicates if the amount used was lowered to the limit to avoid confusion. |
| usedAmountResetToZero | bool | Indicates if the amount used was set to zero because of the current period expiring. |

### RateLimitExceeded

```solidity
error RateLimitExceeded()
```

_Thrown when an amount breaches the limit in the period._

### PeriodIsZero

```solidity
error PeriodIsZero()
```

_Thrown when the period is initialised to zero._

### LimitIsZero

```solidity
error LimitIsZero()
```

_Thrown when the limit is initialised to zero._

### resetRateLimitAmount

```solidity
function resetRateLimitAmount(uint256 _amount) external
```

Resets the rate limit amount.

_If the used amount is higher, it is set to the limit to avoid confusion/issues.
Only the RATE_LIMIT_SETTER_ROLE is allowed to execute this function.
Emits the LimitAmountChanged event.
usedLimitAmountToSet will use the default value of zero if period has expired._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _amount | uint256 | The amount to reset the limit to. |

### resetAmountUsedInPeriod

```solidity
function resetAmountUsedInPeriod() external
```

Resets the amount used to zero.

_Only the USED_RATE_LIMIT_RESETTER_ROLE is allowed to execute this function.
Emits the AmountUsedInPeriodReset event._



==================== FILE: /workspace/docs/api/linea-smart-contracts/interfaces/l2/il2messagemanagerv1.mdx ====================

# `IL2MessageManagerV1`

### MinimumFeeChanged

```solidity
event MinimumFeeChanged(uint256 previousMinimumFee, uint256 newMinimumFee, address calledBy)
```

Emitted when L2 minimum fee is changed.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| previousMinimumFee | uint256 | The previous minimum fee in Wei. |
| newMinimumFee | uint256 | The new minimum fee in Wei. |
| calledBy | address | The indexed address who changed the minimum fee. |

### L1L2MessageHashesAddedToInbox

```solidity
event L1L2MessageHashesAddedToInbox(bytes32[] messageHashes)
```

Emitted when L1->L2 message hashes have been added to L2 storage.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| messageHashes | bytes32[] | The message hashes that were added to L2 for claiming. |

### MessageHashesListLengthHigherThanOneHundred

```solidity
error MessageHashesListLengthHigherThanOneHundred(uint256 length)
```

_Thrown when the message hashes list length is higher than one hundred._

### MessageDoesNotExistOrHasAlreadyBeenClaimed

```solidity
error MessageDoesNotExistOrHasAlreadyBeenClaimed(bytes32 messageHash)
```

_Thrown when the message does not exist or has already been claimed._



==================== FILE: /workspace/docs/api/linea-smart-contracts/interfaces/l2/il2messageservicev1.mdx ====================

# `IL2MessageServiceV1`

### setMinimumFee

```solidity
function setMinimumFee(uint256 _feeInWei) external
```

The Fee Manager sets a minimum fee to address DOS protection.

_MINIMUM_FEE_SETTER_ROLE is required to set the minimum fee._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _feeInWei | uint256 | New minimum fee in Wei. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/interfaces/l2/il2messagemanager.mdx ====================

# `IL2MessageManager`

### RollingHashUpdated

```solidity
event RollingHashUpdated(uint256 messageNumber, bytes32 rollingHash)
```

Emitted after all messages are anchored on L2 and the latest message index and rolling hash stored.

_NB: This event is used to provide data to the rollup. The last messageNumber and rollingHash,
emitted in a rollup will be used in the public input for validating the L1->L2 messaging state transition._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| messageNumber | uint256 | The indexed unique L1 computed indexed message number for the message. |
| rollingHash | bytes32 | The indexed L1 rolling hash computed for the current message number. |

### ServiceVersionMigrated

```solidity
event ServiceVersionMigrated(uint256 version)
```

_Emitted when the service switches over to a new version.
This is currently not in use, but left for existing consumers._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| version | uint256 | The indexed version. |

### MessageHashesListLengthIsZero

```solidity
error MessageHashesListLengthIsZero()
```

_Reverts when the message hashes array length is zero._

### L1MessageNumberSynchronizationWrong

```solidity
error L1MessageNumberSynchronizationWrong(uint256 expected, uint256 found)
```

_Reverts when message number synchronization is mismatched._

### L1RollingHashSynchronizationWrong

```solidity
error L1RollingHashSynchronizationWrong(bytes32 expected, bytes32 found)
```

_Reverts when rolling hash synchronization is mismatched._

### FinalRollingHashIsZero

```solidity
error FinalRollingHashIsZero()
```

_Reverts when final rolling hash is zero hash._

### anchorL1L2MessageHashes

```solidity
function anchorL1L2MessageHashes(bytes32[] _messageHashes, uint256 _startingMessageNumber, uint256 _finalMessageNumber, bytes32 _finalRollingHash) external
```

Add cross-chain L1->L2 message hashes in storage.

_Only address that has the role 'L1_L2_MESSAGE_SETTER_ROLE' are allowed to call this function.
NB: In the unlikely event of a duplicate anchoring, the lastAnchoredL1MessageNumber MUST NOT be incremented.
and the rolling hash not calculated, else synchronisation will break.
If starting number is zero, an underflow error is expected._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _messageHashes | bytes32[] | New message hashes to anchor on L2. |
| _startingMessageNumber | uint256 | The expected L1 message number to start when anchoring. |
| _finalMessageNumber | uint256 | The expected L1 message number to end on when anchoring. |
| _finalRollingHash | bytes32 | The expected L1 rolling hash to end on when anchoring. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/interfaces/igenericerrors.mdx ====================

# `IGenericErrors`

### ZeroAddressNotAllowed

```solidity
error ZeroAddressNotAllowed()
```

_Thrown when a parameter is the zero address._

### ZeroHashNotAllowed

```solidity
error ZeroHashNotAllowed()
```

_Thrown when a parameter is the zero hash._

### ArrayLengthsDoNotMatch

```solidity
error ArrayLengthsDoNotMatch()
```

_Thrown when array lengths are mismatched._



==================== FILE: /workspace/docs/api/linea-smart-contracts/interfaces/ipausemanager.mdx ====================

# `IPauseManager`

### PauseTypeRole

```solidity
struct PauseTypeRole {
  enum IPauseManager.PauseType pauseType;
  bytes32 role;
}
```

### PauseType

```solidity
enum PauseType {
  UNUSED,
  GENERAL,
  L1_L2,
  L2_L1,
  BLOB_SUBMISSION,
  CALLDATA_SUBMISSION,
  FINALIZATION,
  INITIATE_TOKEN_BRIDGING,
  COMPLETE_TOKEN_BRIDGING
}
```

### Paused

```solidity
event Paused(address messageSender, enum IPauseManager.PauseType pauseType)
```

Emitted when a pause type is paused.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| messageSender | address | The address performing the pause. |
| pauseType | enum IPauseManager.PauseType | The indexed pause type that was paused. |

### UnPaused

```solidity
event UnPaused(address messageSender, enum IPauseManager.PauseType pauseType)
```

Emitted when a pause type is unpaused.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| messageSender | address | The address performing the unpause. |
| pauseType | enum IPauseManager.PauseType | The indexed pause type that was unpaused. |

### PauseTypeRoleSet

```solidity
event PauseTypeRoleSet(enum IPauseManager.PauseType pauseType, bytes32 role)
```

Emitted when a pause type and its associated role are set in the `_pauseTypeRoles` mapping.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| pauseType | enum IPauseManager.PauseType | The indexed type of pause. |
| role | bytes32 | The indexed role associated with the pause type. |

### UnPauseTypeRoleSet

```solidity
event UnPauseTypeRoleSet(enum IPauseManager.PauseType unPauseType, bytes32 role)
```

Emitted when an unpause type and its associated role are set in the `_unPauseTypeRoles` mapping.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| unPauseType | enum IPauseManager.PauseType | The indexed type of unpause. |
| role | bytes32 | The indexed role associated with the unpause type. |

### IsPaused

```solidity
error IsPaused(enum IPauseManager.PauseType pauseType)
```

_Thrown when a specific pause type is paused._

### IsNotPaused

```solidity
error IsNotPaused(enum IPauseManager.PauseType pauseType)
```

_Thrown when a specific pause type is not paused and expected to be._

### pauseByType

```solidity
function pauseByType(enum IPauseManager.PauseType _pauseType) external
```

Pauses functionality by specific type.

_Requires the role mapped in pauseTypeRoles for the pauseType._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _pauseType | enum IPauseManager.PauseType | The pause type value. |

### unPauseByType

```solidity
function unPauseByType(enum IPauseManager.PauseType _pauseType) external
```

Unpauses functionality by specific type.

_Requires the role mapped in unPauseTypeRoles for the pauseType._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _pauseType | enum IPauseManager.PauseType | The pause type value. |

### isPaused

```solidity
function isPaused(enum IPauseManager.PauseType _pauseType) external view returns (bool pauseTypeIsPaused)
```

Check if a pause type is enabled.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _pauseType | enum IPauseManager.PauseType | The pause type value. |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| pauseTypeIsPaused | bool | Returns true if the pause type if paused, false otherwise. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/interfaces/l1/il1messageservice.mdx ====================

# `IL1MessageService`

### ClaimMessageWithProofParams

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |

```solidity
struct ClaimMessageWithProofParams {
  bytes32[] proof;
  uint256 messageNumber;
  uint32 leafIndex;
  address from;
  address to;
  uint256 fee;
  uint256 value;
  address payable feeRecipient;
  bytes32 merkleRoot;
  bytes data;
}
```

### L2MerkleRootDoesNotExist

```solidity
error L2MerkleRootDoesNotExist()
```

_Thrown when L2 Merkle root does not exist._

### InvalidMerkleProof

```solidity
error InvalidMerkleProof()
```

_Thrown when the Merkle proof is invalid._

### ProofLengthDifferentThanMerkleDepth

```solidity
error ProofLengthDifferentThanMerkleDepth(uint256 actual, uint256 expected)
```

_Thrown when Merkle depth doesn't match proof length._

### claimMessageWithProof

```solidity
function claimMessageWithProof(struct IL1MessageService.ClaimMessageWithProofParams _params) external
```

Claims and delivers a cross-chain message using a Merkle proof.

_if tree depth is empty, it will revert with L2MerkleRootDoesNotExist.
if tree depth is different than proof size, it will revert with ProofLengthDifferentThanMerkleDepth._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _params | struct IL1MessageService.ClaimMessageWithProofParams | Collection of claim data with proof and supporting data. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/interfaces/l1/il1messagemanager.mdx ====================

# `IL1MessageManager`

### RollingHashUpdated

```solidity
event RollingHashUpdated(uint256 messageNumber, bytes32 rollingHash, bytes32 messageHash)
```

Emitted when a new message is sent and the rolling hash updated.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| messageNumber | uint256 | The unique indexed message number for the message. |
| rollingHash | bytes32 | The indexed rolling hash computed for the current message number. |
| messageHash | bytes32 | The indexed hash of the message parameters. |

### L2MerkleRootAdded

```solidity
event L2MerkleRootAdded(bytes32 l2MerkleRoot, uint256 treeDepth)
```

Emitted when the L2 Merkle root has been anchored on L1.

_There may be more than one of these in a finalization depending on the amount of L2->L1 messages in the finalization._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| l2MerkleRoot | bytes32 | The indexed L2 Merkle root that has been anchored on L1 Ethereum. |
| treeDepth | uint256 | The indexed tree depth of the Merkle root. |

### L2MessagingBlockAnchored

```solidity
event L2MessagingBlockAnchored(uint256 l2Block)
```

Emitted when the L2 block contains L2 messages during finalization.

_This is used externally in the logic for determining which messages belong to which Merkle root when claiming._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| l2Block | uint256 | The indexed L2 block containing L2 to L1 messages. |

### MessageAlreadyClaimed

```solidity
error MessageAlreadyClaimed(uint256 messageIndex)
```

_Thrown when the message has already been claimed._

### L2MerkleRootAlreadyAnchored

```solidity
error L2MerkleRootAlreadyAnchored(bytes32 merkleRoot)
```

_Thrown when the L2 Merkle root has already been anchored on L1._

### BytesLengthNotMultipleOfTwo

```solidity
error BytesLengthNotMultipleOfTwo(uint256 bytesLength)
```

_Thrown when the L2 messaging blocks offsets bytes length is not a multiple of 2._

### isMessageClaimed

```solidity
function isMessageClaimed(uint256 _messageNumber) external view returns (bool isClaimed)
```

Checks if the L2->L1 message is claimed or not.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _messageNumber | uint256 | The message number on L2. |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| isClaimed | bool | Returns whether or not the message with _messageNumber has been claimed. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/interfaces/l1/ilinearollup.mdx ====================

# `ILineaRollup`

### InitializationData

Initialization data structure for the LineaRollup contract.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |

```solidity
struct InitializationData {
  bytes32 initialStateRootHash;
  uint256 initialL2BlockNumber;
  uint256 genesisTimestamp;
  address defaultVerifier;
  uint256 rateLimitPeriodInSeconds;
  uint256 rateLimitAmountInWei;
  struct IPermissionsManager.RoleAddress[] roleAddresses;
  struct IPauseManager.PauseTypeRole[] pauseTypeRoles;
  struct IPauseManager.PauseTypeRole[] unpauseTypeRoles;
  address fallbackOperator;
  address defaultAdmin;
}
```

### CompressedCalldataSubmission

Supporting data for compressed calldata submission including compressed data.

_finalStateRootHash is used to set state root at the end of the data.
snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.
compressedData is the compressed transaction data. It contains ordered data for each L2 block - l2Timestamps, the encoded transaction data._

```solidity
struct CompressedCalldataSubmission {
  bytes32 finalStateRootHash;
  bytes32 snarkHash;
  bytes compressedData;
}
```

### ShnarfData

Shnarf data for validating a shnarf.

_parentShnarf is the parent computed shnarf.
snarkHash is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input.
finalStateRootHash is the final state root hash.
dataEvaluationPoint is the data evaluation point.
dataEvaluationClaim is the data evaluation claim._

```solidity
struct ShnarfData {
  bytes32 parentShnarf;
  bytes32 snarkHash;
  bytes32 finalStateRootHash;
  bytes32 dataEvaluationPoint;
  bytes32 dataEvaluationClaim;
}
```

### BlobSubmission

Data structure for compressed blob data submission.

_submissionData The supporting data for blob data submission excluding the compressed data.
dataEvaluationClaim The data evaluation claim.
kzgCommitment The blob KZG commitment.
kzgProof The blob KZG point proof._

```solidity
struct BlobSubmission {
  uint256 dataEvaluationClaim;
  bytes kzgCommitment;
  bytes kzgProof;
  bytes32 finalStateRootHash;
  bytes32 snarkHash;
}
```

### FinalizationDataV3

Supporting data for finalization with proof.

_NB: the dynamic sized fields are placed last on purpose for efficient keccaking on public input.
parentStateRootHash is the expected last state root hash finalized.
endBlockNumber is the end block finalizing until.
shnarfData contains data about the last data submission's shnarf used in finalization.
lastFinalizedTimestamp is the expected last finalized block's timestamp.
finalTimestamp is the timestamp of the last block being finalized.
lastFinalizedL1RollingHash is the last stored L2 computed rolling hash used in finalization.
l1RollingHash is the calculated rolling hash on L2 that is expected to match L1 at l1RollingHashMessageNumber.
This value will be used along with the stored last finalized L2 calculated rolling hash in the public input.
lastFinalizedL1RollingHashMessageNumber is the last stored L2 computed message number used in finalization.
l1RollingHashMessageNumber is the calculated message number on L2 that is expected to match the existing L1 rolling hash.
This value will be used along with the stored last finalized L2 calculated message number in the public input.
l2MerkleTreesDepth is the depth of all l2MerkleRoots.
l2MerkleRoots is an array of L2 message Merkle roots of depth l2MerkleTreesDepth between last finalized block and finalSubmissionData.finalBlockNumber.
l2MessagingBlocksOffsets indicates by offset from currentL2BlockNumber which L2 blocks contain MessageSent events._

```solidity
struct FinalizationDataV3 {
  bytes32 parentStateRootHash;
  uint256 endBlockNumber;
  struct ILineaRollup.ShnarfData shnarfData;
  uint256 lastFinalizedTimestamp;
  uint256 finalTimestamp;
  bytes32 lastFinalizedL1RollingHash;
  bytes32 l1RollingHash;
  uint256 lastFinalizedL1RollingHashMessageNumber;
  uint256 l1RollingHashMessageNumber;
  uint256 l2MerkleTreesDepth;
  bytes32[] l2MerkleRoots;
  bytes l2MessagingBlocksOffsets;
}
```

### LineaRollupVersionChanged

```solidity
event LineaRollupVersionChanged(bytes8 previousVersion, bytes8 newVersion)
```

Emitted when the LineaRollup contract version has changed.

_All bytes8 values are string based SemVer in the format M.m - e.g. "6.0"._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| previousVersion | bytes8 | The previous version. |
| newVersion | bytes8 | The new version. |

### FallbackOperatorRoleGranted

```solidity
event FallbackOperatorRoleGranted(address caller, address fallbackOperator)
```

Emitted when the fallback operator role is granted.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| caller | address | The address that called the function granting the role. |
| fallbackOperator | address | The fallback operator address that received the operator role. |

### FallbackOperatorAddressSet

```solidity
event FallbackOperatorAddressSet(address caller, address fallbackOperator)
```

Emitted when the fallback operator role is set on the contract.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| caller | address | The address that set the fallback operator address. |
| fallbackOperator | address | The fallback operator address. |

### VerifierAddressChanged

```solidity
event VerifierAddressChanged(address verifierAddress, uint256 proofType, address verifierSetBy, address oldVerifierAddress)
```

Emitted when a verifier is set for a particular proof type.

_The verifier will be set by an account with the VERIFIER_SETTER_ROLE. Typically the Safe.
The oldVerifierAddress can be the zero address._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| verifierAddress | address | The indexed new verifier address being set. |
| proofType | uint256 | The indexed proof type/index that the verifier is mapped to. |
| verifierSetBy | address | The index address who set the verifier at the mapping. |
| oldVerifierAddress | address | Indicates the previous address mapped to the proof type. |

### DataSubmittedV3

```solidity
event DataSubmittedV3(bytes32 parentShnarf, bytes32 shnarf, bytes32 finalStateRootHash)
```

Emitted when compressed data is being submitted and verified successfully on L1.

_The block range is indexed and parent shnarf included for state reconstruction simplicity._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| parentShnarf | bytes32 | The parent shnarf for the data being submitted. |
| shnarf | bytes32 | The indexed shnarf for the data being submitted. |
| finalStateRootHash | bytes32 | The L2 state root hash that the current blob submission ends on. NB: The last blob in the collection. |

### DataFinalizedV3

```solidity
event DataFinalizedV3(uint256 startBlockNumber, uint256 endBlockNumber, bytes32 shnarf, bytes32 parentStateRootHash, bytes32 finalStateRootHash)
```

Emitted when L2 blocks have been finalized on L1.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| startBlockNumber | uint256 | The indexed L2 block number indicating which block the finalization the data starts from. |
| endBlockNumber | uint256 | The indexed L2 block number indicating which block the finalization the data ends on. |
| shnarf | bytes32 | The indexed shnarf being set as currentFinalizedShnarf in the current finalization. |
| parentStateRootHash | bytes32 | The parent L2 state root hash that the current finalization starts from. |
| finalStateRootHash | bytes32 | The L2 state root hash that the current finalization ends on. |

### LastFinalizationTimeNotLapsed

```solidity
error LastFinalizationTimeNotLapsed()
```

_Thrown when the last finalization time has not lapsed when trying to grant the OPERATOR_ROLE to the fallback operator address._

### PointEvaluationResponseInvalid

```solidity
error PointEvaluationResponseInvalid(uint256 fieldElements, uint256 blsCurveModulus)
```

_Thrown when the point evaluation precompile's call return data field(s) are wrong._

### PrecompileReturnDataLengthWrong

```solidity
error PrecompileReturnDataLengthWrong(uint256 expected, uint256 actual)
```

_Thrown when the point evaluation precompile's call return data length is wrong._

### PointEvaluationFailed

```solidity
error PointEvaluationFailed()
```

_Thrown when the point evaluation precompile call returns false._

### EmptyBlobDataAtIndex

```solidity
error EmptyBlobDataAtIndex(uint256 index)
```

_Thrown when the blobhash at an index equals to the zero hash._

### BlobSubmissionDataIsMissing

```solidity
error BlobSubmissionDataIsMissing()
```

_Thrown when the data for multiple blobs submission has length zero._

### BlobSubmissionDataEmpty

```solidity
error BlobSubmissionDataEmpty(uint256 emptyBlobIndex)
```

_Thrown when a blob has been submitted but there is no data for it._

### DataAlreadySubmitted

```solidity
error DataAlreadySubmitted(bytes32 currentDataHash)
```

_Thrown when the current data was already submitted._

### EmptySubmissionData

```solidity
error EmptySubmissionData()
```

_Thrown when submissionData is empty._

### L1RollingHashDoesNotExistOnL1

```solidity
error L1RollingHashDoesNotExistOnL1(uint256 messageNumber, bytes32 rollingHash)
```

_Thrown when finalizationData.l1RollingHash does not exist on L1 (Feedback loop)._

### FinalizationStateIncorrect

```solidity
error FinalizationStateIncorrect(bytes32 expected, bytes32 value)
```

_Thrown when finalization state does not match._

### FinalBlockNumberLessThanOrEqualToLastFinalizedBlock

```solidity
error FinalBlockNumberLessThanOrEqualToLastFinalizedBlock(uint256 finalBlockNumber, uint256 lastFinalizedBlock)
```

_Thrown when the final block number in finalization data is less than or equal to the last finalized block during finalization._

### FinalBlockStateEqualsZeroHash

```solidity
error FinalBlockStateEqualsZeroHash()
```

_Thrown when the final block state equals the zero hash during finalization._

### FinalizationInTheFuture

```solidity
error FinalizationInTheFuture(uint256 l2BlockTimestamp, uint256 currentBlockTimestamp)
```

_Thrown when final l2 block timestamp higher than current block.timestamp during finalization._

### MissingMessageNumberForRollingHash

```solidity
error MissingMessageNumberForRollingHash(bytes32 rollingHash)
```

_Thrown when a rolling hash is provided without a corresponding message number._

### MissingRollingHashForMessageNumber

```solidity
error MissingRollingHashForMessageNumber(uint256 messageNumber)
```

_Thrown when a message number is provided without a corresponding rolling hash._

### FirstByteIsNotZero

```solidity
error FirstByteIsNotZero()
```

_Thrown when the first byte is not zero.
This is used explicitly with the four bytes in assembly 0x729eebce._

### BytesLengthNotMultipleOf32

```solidity
error BytesLengthNotMultipleOf32()
```

_Thrown when bytes length is not a multiple of 32._

### FinalShnarfWrong

```solidity
error FinalShnarfWrong(bytes32 expected, bytes32 value)
```

_Thrown when the computed shnarf does not match what is expected._

### ParentBlobNotSubmitted

```solidity
error ParentBlobNotSubmitted(bytes32 shnarf)
```

_Thrown when a shnarf does not exist for a parent blob._

### FinalBlobNotSubmitted

```solidity
error FinalBlobNotSubmitted(bytes32 shnarf)
```

_Thrown when a shnarf does not exist for the final blob being finalized._

### OnlyNonFallbackOperator

```solidity
error OnlyNonFallbackOperator()
```

_Thrown when the fallback operator tries to renounce their operator role._

### setVerifierAddress

```solidity
function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external
```

Adds or updates the verifier contract address for a proof type.

_VERIFIER_SETTER_ROLE is required to execute._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _newVerifierAddress | address | The address for the verifier contract. |
| _proofType | uint256 | The proof type being set/updated. |

### setFallbackOperator

```solidity
function setFallbackOperator(uint256 _messageNumber, bytes32 _rollingHash, uint256 _lastFinalizedTimestamp) external
```

Sets the fallback operator role to the specified address if six months have passed since the last finalization.

_Reverts if six months have not passed since the last finalization._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _messageNumber | uint256 | Last finalized L1 message number as part of the feedback loop. |
| _rollingHash | bytes32 | Last finalized L1 rolling hash as part of the feedback loop. |
| _lastFinalizedTimestamp | uint256 | Last finalized L2 block timestamp. |

### unsetVerifierAddress

```solidity
function unsetVerifierAddress(uint256 _proofType) external
```

Unsets the verifier contract address for a proof type.

_VERIFIER_UNSETTER_ROLE is required to execute._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _proofType | uint256 | The proof type being set/updated. |

### submitBlobs

```solidity
function submitBlobs(struct ILineaRollup.BlobSubmission[] _blobSubmissions, bytes32 _parentShnarf, bytes32 _finalBlobShnarf) external
```

Submit one or more EIP-4844 blobs.

_OPERATOR_ROLE is required to execute.
This should be a blob carrying transaction._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _blobSubmissions | struct ILineaRollup.BlobSubmission[] | The data for blob submission including proofs and required polynomials. |
| _parentShnarf | bytes32 | The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation. |
| _finalBlobShnarf | bytes32 | The expected final shnarf post computation of all the blob shnarfs. |

### submitDataAsCalldata

```solidity
function submitDataAsCalldata(struct ILineaRollup.CompressedCalldataSubmission _submission, bytes32 _parentShnarf, bytes32 _expectedShnarf) external
```

Submit blobs using compressed data via calldata.

_OPERATOR_ROLE is required to execute._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _submission | struct ILineaRollup.CompressedCalldataSubmission | The supporting data for compressed data submission including compressed data. |
| _parentShnarf | bytes32 | The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation. |
| _expectedShnarf | bytes32 | The expected shnarf post computation of all the submission. |

### finalizeBlocks

```solidity
function finalizeBlocks(bytes _aggregatedProof, uint256 _proofType, struct ILineaRollup.FinalizationDataV3 _finalizationData) external
```

Finalize compressed blocks with proof.

_OPERATOR_ROLE is required to execute._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _aggregatedProof | bytes | The aggregated proof. |
| _proofType | uint256 | The proof type. |
| _finalizationData | struct ILineaRollup.FinalizationDataV3 | The full finalization data. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/interfaces/l1/izkevmv2.mdx ====================

# `IZkEvmV2`

### StartingRootHashDoesNotMatch

```solidity
error StartingRootHashDoesNotMatch()
```

_Thrown when the starting rootHash does not match the existing state._

### ProofIsEmpty

```solidity
error ProofIsEmpty()
```

_Thrown when zk proof is empty bytes._

### InvalidProofType

```solidity
error InvalidProofType()
```

_Thrown when zk proof type is invalid._

### InvalidProof

```solidity
error InvalidProof()
```

_Thrown when zk proof is invalid._

### InvalidProofOrProofVerificationRanOutOfGas

```solidity
error InvalidProofOrProofVerificationRanOutOfGas(string errorReason)
```

_Thrown when the call to the verifier runs out of gas or reverts internally._



==================== FILE: /workspace/docs/api/linea-smart-contracts/interfaces/l1/il1messagemanagerv1.mdx ====================

# `IL1MessageManagerV1`

### MessageDoesNotExistOrHasAlreadyBeenClaimed

```solidity
error MessageDoesNotExistOrHasAlreadyBeenClaimed(bytes32 messageHash)
```

_Thrown when the message has already been claimed._



==================== FILE: /workspace/docs/api/linea-smart-contracts/interfaces/l1/iplonkverifier.mdx ====================

# `IPlonkVerifier`

### Verify

```solidity
function Verify(bytes _proof, uint256[] _public_inputs) external returns (bool success)
```

Interface for verifier contracts.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _proof | bytes | The proof used to verify. |
| _public_inputs | uint256[] | The computed public inputs for the proof verification. |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| success | bool | Returns true if successfully verified. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/lib/linearolluppausemanager.mdx ====================

# `LineaRollupPauseManager`

### PAUSE_L1_L2_ROLE

```solidity
bytes32 PAUSE_L1_L2_ROLE
```

This is used to pause L1 to L2 communication.

### UNPAUSE_L1_L2_ROLE

```solidity
bytes32 UNPAUSE_L1_L2_ROLE
```

This is used to unpause L1 to L2 communication.

### PAUSE_L2_L1_ROLE

```solidity
bytes32 PAUSE_L2_L1_ROLE
```

This is used to pause L2 to L1 communication.

### UNPAUSE_L2_L1_ROLE

```solidity
bytes32 UNPAUSE_L2_L1_ROLE
```

This is used to unpause L2 to L1 communication.

### PAUSE_BLOB_SUBMISSION_ROLE

```solidity
bytes32 PAUSE_BLOB_SUBMISSION_ROLE
```

This is used to pause blob submission.

### UNPAUSE_BLOB_SUBMISSION_ROLE

```solidity
bytes32 UNPAUSE_BLOB_SUBMISSION_ROLE
```

This is used to unpause blob submission.

### PAUSE_FINALIZATION_ROLE

```solidity
bytes32 PAUSE_FINALIZATION_ROLE
```

This is used to pause finalization submission.

### UNPAUSE_FINALIZATION_ROLE

```solidity
bytes32 UNPAUSE_FINALIZATION_ROLE
```

This is used to unpause finalization submission.



==================== FILE: /workspace/docs/api/linea-smart-contracts/lib/mimc.mdx ====================

# `Mimc`

### DataMissing

```solidity
error DataMissing()
```

Thrown when the data is not provided

### DataIsNotMod32

```solidity
error DataIsNotMod32()
```

Thrown when the data is not purely in 32 byte chunks

### FR_FIELD

```solidity
uint256 FR_FIELD
```

### hash

```solidity
function hash(bytes _msg) external pure returns (bytes32 mimcHash)
```

Performs a MiMC hash on the data provided

_Only data that has length modulus 32 is hashed, reverts otherwise_

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _msg | bytes | The data to be hashed |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| mimcHash | bytes32 | The computed MiMC hash |



==================== FILE: /workspace/docs/api/linea-smart-contracts/lib/l2messageservicepausemanager.mdx ====================

# `L2MessageServicePauseManager`

### PAUSE_L1_L2_ROLE

```solidity
bytes32 PAUSE_L1_L2_ROLE
```

This is used to pause L1 to L2 communication.

### UNPAUSE_L1_L2_ROLE

```solidity
bytes32 UNPAUSE_L1_L2_ROLE
```

This is used to unpause L1 to L2 communication.

### PAUSE_L2_L1_ROLE

```solidity
bytes32 PAUSE_L2_L1_ROLE
```

This is used to pause L2 to L1 communication.

### UNPAUSE_L2_L1_ROLE

```solidity
bytes32 UNPAUSE_L2_L1_ROLE
```

This is used to unpause L2 to L1 communication.



==================== FILE: /workspace/docs/api/linea-smart-contracts/lib/utils.mdx ====================

# `Utils`

### _efficientKeccak

```solidity
function _efficientKeccak(bytes32 _left, bytes32 _right) internal pure returns (bytes32 value)
```

Performs a gas optimized keccak hash for two bytes32 values.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _left | bytes32 | Left value. |
| _right | bytes32 | Right value. |

### _efficientKeccak

```solidity
function _efficientKeccak(uint256 _left, address _right) internal pure returns (bytes32 value)
```

Performs a gas optimized keccak hash for uint256 and address.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _left | uint256 | Left value. |
| _right | address | Right value. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/lib/tokenbridgepausemanager.mdx ====================

# `TokenBridgePauseManager`

### PAUSE_INITIATE_TOKEN_BRIDGING_ROLE

```solidity
bytes32 PAUSE_INITIATE_TOKEN_BRIDGING_ROLE
```

### UNPAUSE_INITIATE_TOKEN_BRIDGING_ROLE

```solidity
bytes32 UNPAUSE_INITIATE_TOKEN_BRIDGING_ROLE
```

### PAUSE_COMPLETE_TOKEN_BRIDGING_ROLE

```solidity
bytes32 PAUSE_COMPLETE_TOKEN_BRIDGING_ROLE
```

### UNPAUSE_COMPLETE_TOKEN_BRIDGING_ROLE

```solidity
bytes32 UNPAUSE_COMPLETE_TOKEN_BRIDGING_ROLE
```



==================== FILE: /workspace/docs/api/linea-smart-contracts/lib/callforwardingproxy.mdx ====================

# `CallForwardingProxy`

### target

```solidity
address target
```

The underlying target address that is called.

### constructor

```solidity
constructor(address _target) public
```

### fallback

```solidity
fallback() external payable
```

Defaults to, and forwards all calls to the target address.



==================== FILE: /workspace/docs/api/linea-smart-contracts/lib/pausemanager.mdx ====================

# `PauseManager`

### PAUSE_ALL_ROLE

```solidity
bytes32 PAUSE_ALL_ROLE
```

This is used to pause all pausable functions.

### UNPAUSE_ALL_ROLE

```solidity
bytes32 UNPAUSE_ALL_ROLE
```

This is used to unpause all unpausable functions.

### pauseTypeStatuses

```solidity
mapping(bytes32 => bool) pauseTypeStatuses
```

### whenTypeAndGeneralNotPaused

```solidity
modifier whenTypeAndGeneralNotPaused(enum IPauseManager.PauseType _pauseType)
```

_Modifier to make a function callable only when the specific and general types are not paused._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _pauseType | enum IPauseManager.PauseType | The pause type value being checked. Requirements: - The type must not be paused. |

### whenTypeNotPaused

```solidity
modifier whenTypeNotPaused(enum IPauseManager.PauseType _pauseType)
```

_Modifier to make a function callable only when the type is not paused._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _pauseType | enum IPauseManager.PauseType | The pause type value being checked. Requirements: - The type must not be paused. |

### __PauseManager_init

```solidity
function __PauseManager_init(struct IPauseManager.PauseTypeRole[] _pauseTypeRoleAssignments, struct IPauseManager.PauseTypeRole[] _unpauseTypeRoleAssignments) internal
```

Initializes the pause manager with the given pause and unpause roles.

_This function is called during contract initialization to set up the pause and unpause roles._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _pauseTypeRoleAssignments | struct IPauseManager.PauseTypeRole[] | An array of PauseTypeRole structs defining the pause types and their associated roles. |
| _unpauseTypeRoleAssignments | struct IPauseManager.PauseTypeRole[] | An array of PauseTypeRole structs defining the unpause types and their associated roles. |

### _requireTypeAndGeneralNotPaused

```solidity
function _requireTypeAndGeneralNotPaused(enum IPauseManager.PauseType _pauseType) internal view virtual
```

_Throws if the specific or general types are paused.
Checks the specific and general pause types._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _pauseType | enum IPauseManager.PauseType | The pause type value being checked. |

### _requireTypeNotPaused

```solidity
function _requireTypeNotPaused(enum IPauseManager.PauseType _pauseType) internal view virtual
```

_Throws if the type is paused.
Checks the specific pause type._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _pauseType | enum IPauseManager.PauseType | The pause type value being checked. |

### pauseByType

```solidity
function pauseByType(enum IPauseManager.PauseType _pauseType) external
```

Pauses functionality by specific type.

_Requires the role mapped in `_pauseTypeRoles` for the pauseType._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _pauseType | enum IPauseManager.PauseType | The pause type value. |

### unPauseByType

```solidity
function unPauseByType(enum IPauseManager.PauseType _pauseType) external
```

Unpauses functionality by specific type.

_Requires the role mapped in `_unPauseTypeRoles` for the pauseType._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _pauseType | enum IPauseManager.PauseType | The pause type value. |

### isPaused

```solidity
function isPaused(enum IPauseManager.PauseType _pauseType) public view returns (bool pauseTypeIsPaused)
```

Check if a pause type is enabled.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _pauseType | enum IPauseManager.PauseType | The pause type value. |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| pauseTypeIsPaused | bool | Returns true if the pause type if paused, false otherwise. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/lib/sparsemerkleproof.mdx ====================

# `SparseMerkleProof`

### Account

The Account struct represents the state of the account including the storage root, nonce, balance and codesize

_This is mapped directly to the output of the storage proof_

```solidity
struct Account {
  uint64 nonce;
  uint256 balance;
  bytes32 storageRoot;
  bytes32 mimcCodeHash;
  bytes32 keccakCodeHash;
  uint64 codeSize;
}
```

### Leaf

Represents the leaf structure in both account and storage tries

_This is mapped directly to the output of the storage proof_

```solidity
struct Leaf {
  uint256 prev;
  uint256 next;
  bytes32 hKey;
  bytes32 hValue;
}
```

### WrongBytesLength

```solidity
error WrongBytesLength(uint256 expectedLength, uint256 bytesLength)
```

Thrown when expected bytes length is incorrect

### LengthNotMod32

```solidity
error LengthNotMod32()
```

Thrown when the length of bytes is not in exactly 32 byte chunks

### MaxTreeLeafIndexExceed

```solidity
error MaxTreeLeafIndexExceed()
```

Thrown when the leaf index is higher than the tree depth

### WrongProofLength

```solidity
error WrongProofLength(uint256 expectedLength, uint256 actualLength)
```

Thrown when the length of the unformatted proof is not provided exactly as expected (UNFORMATTED_PROOF_LENGTH)

### TREE_DEPTH

```solidity
uint256 TREE_DEPTH
```

### UNFORMATTED_PROOF_LENGTH

```solidity
uint256 UNFORMATTED_PROOF_LENGTH
```

### ZERO_HASH

```solidity
bytes32 ZERO_HASH
```

### MAX_TREE_LEAF_INDEX

```solidity
uint256 MAX_TREE_LEAF_INDEX
```

### verifyProof

```solidity
function verifyProof(bytes[] _rawProof, uint256 _leafIndex, bytes32 _root) external pure returns (bool)
```

Formats input, computes root and returns true if it matches the provided merkle root

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _rawProof | bytes[] | Raw sparse merkle tree proof |
| _leafIndex | uint256 | Index of the leaf |
| _root | bytes32 | Sparse merkle root |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| [0] | bool | If the computed merkle root matches the provided one |

### mimcHash

```solidity
function mimcHash(bytes _input) external pure returns (bytes32)
```

Hash a value using MIMC hash

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _input | bytes | Value to hash |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| [0] | bytes32 | bytes32 Mimc hash |

### getLeaf

```solidity
function getLeaf(bytes _encodedLeaf) external pure returns (struct SparseMerkleProof.Leaf)
```

Get leaf

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _encodedLeaf | bytes | Encoded leaf bytes (prev, next, hKey, hValue) |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| [0] | struct SparseMerkleProof.Leaf | Leaf Formatted leaf struct |

### getAccount

```solidity
function getAccount(bytes _encodedAccountValue) external pure returns (struct SparseMerkleProof.Account)
```

Get account

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _encodedAccountValue | bytes | Encoded account value bytes (nonce, balance, storageRoot, mimcCodeHash, keccakCodeHash, codeSize) |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| [0] | struct SparseMerkleProof.Account | Account Formatted account struct |

### hashAccountValue

```solidity
function hashAccountValue(bytes _value) external pure returns (bytes32)
```

Hash account value

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _value | bytes | Encoded account value bytes (nonce, balance, storageRoot, mimcCodeHash, keccakCodeHash, codeSize) |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| [0] | bytes32 | bytes32 Account value hash |

### hashStorageValue

```solidity
function hashStorageValue(bytes32 _value) external pure returns (bytes32)
```

Hash storage value

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _value | bytes32 | Encoded storage value bytes |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| [0] | bytes32 | bytes32 Storage value hash |



==================== FILE: /workspace/docs/api/linea-smart-contracts/linearollup.mdx ====================

# `LineaRollup`

### CONTRACT_VERSION

```solidity
string CONTRACT_VERSION
```

This is the ABI version and not the reinitialize version.

### VERIFIER_SETTER_ROLE

```solidity
bytes32 VERIFIER_SETTER_ROLE
```

The role required to set/add  proof verifiers by type.

### VERIFIER_UNSETTER_ROLE

```solidity
bytes32 VERIFIER_UNSETTER_ROLE
```

The role required to set/remove  proof verifiers by type.

### GENESIS_SHNARF

```solidity
bytes32 GENESIS_SHNARF
```

The default genesis shnarf using empty/default hashes and a default state.

### SHNARF_EXISTS_DEFAULT_VALUE

```solidity
uint256 SHNARF_EXISTS_DEFAULT_VALUE
```

_Value indicating a shnarf exists._

### EMPTY_HASH

```solidity
bytes32 EMPTY_HASH
```

_The default hash value._

### BLS_CURVE_MODULUS

```solidity
uint256 BLS_CURVE_MODULUS
```

_The BLS Curve modulus value used._

### POINT_EVALUATION_PRECOMPILE_ADDRESS

```solidity
address POINT_EVALUATION_PRECOMPILE_ADDRESS
```

_The well-known precompile address for point evaluation._

### POINT_EVALUATION_RETURN_DATA_LENGTH

```solidity
uint256 POINT_EVALUATION_RETURN_DATA_LENGTH
```

_The expected point evaluation return data length._

### POINT_EVALUATION_FIELD_ELEMENTS_LENGTH

```solidity
uint256 POINT_EVALUATION_FIELD_ELEMENTS_LENGTH
```

_The expected point evaluation field element length returned._

### SIX_MONTHS_IN_SECONDS

```solidity
uint256 SIX_MONTHS_IN_SECONDS
```

_In practice, when used, this is expected to be a close approximation to 6 months, and is intentional._

### dataFinalStateRootHashes

```solidity
mapping(bytes32 => bytes32) dataFinalStateRootHashes
```

_DEPRECATED in favor of the single blobShnarfExists mapping._

### dataParents

```solidity
mapping(bytes32 => bytes32) dataParents
```

_DEPRECATED in favor of the single blobShnarfExists mapping._

### dataShnarfHashes

```solidity
mapping(bytes32 => bytes32) dataShnarfHashes
```

_DEPRECATED in favor of the single blobShnarfExists mapping._

### dataStartingBlock

```solidity
mapping(bytes32 => uint256) dataStartingBlock
```

_DEPRECATED in favor of the single blobShnarfExists mapping._

### dataEndingBlock

```solidity
mapping(bytes32 => uint256) dataEndingBlock
```

_DEPRECATED in favor of the single blobShnarfExists mapping._

### currentL2StoredL1MessageNumber

```solidity
uint256 currentL2StoredL1MessageNumber
```

_DEPRECATED in favor of currentFinalizedState hash._

### currentL2StoredL1RollingHash

```solidity
bytes32 currentL2StoredL1RollingHash
```

_DEPRECATED in favor of currentFinalizedState hash._

### currentFinalizedShnarf

```solidity
bytes32 currentFinalizedShnarf
```

Contains the most recent finalized shnarf.

### blobShnarfExists

```solidity
mapping(bytes32 => uint256) blobShnarfExists
```

_NB: THIS IS THE ONLY MAPPING BEING USED FOR DATA SUBMISSION TRACKING.
NB: This was shnarfFinalBlockNumbers and is replaced to indicate only that a shnarf exists with a value of 1._

### currentFinalizedState

```solidity
bytes32 currentFinalizedState
```

Hash of the L2 computed L1 message number, rolling hash and finalized timestamp.

### fallbackOperator

```solidity
address fallbackOperator
```

The address of the fallback operator.

_This address is granted the OPERATOR_ROLE after six months of finalization inactivity by the current operators._

### constructor

```solidity
constructor() public
```

### initialize

```solidity
function initialize(struct ILineaRollup.InitializationData _initializationData) external
```

Initializes LineaRollup and underlying service dependencies - used for new networks only.

_DEFAULT_ADMIN_ROLE is set for the security council.
OPERATOR_ROLE is set for operators.
Note: This is used for new testnets and local/CI testing, and will not replace existing proxy based contracts._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _initializationData | struct ILineaRollup.InitializationData | The initial data used for proof verification. |

### reinitializeLineaRollupV6

```solidity
function reinitializeLineaRollupV6(struct IPermissionsManager.RoleAddress[] _roleAddresses, struct IPauseManager.PauseTypeRole[] _pauseTypeRoles, struct IPauseManager.PauseTypeRole[] _unpauseTypeRoles, address _fallbackOperator) external
```

Sets permissions for a list of addresses and their roles as well as initialises the PauseManager pauseType:role mappings and fallback operator.

_This function is a reinitializer and can only be called once per version. Should be called using an upgradeAndCall transaction to the ProxyAdmin._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _roleAddresses | struct IPermissionsManager.RoleAddress[] | The list of addresses and roles to assign permissions to. |
| _pauseTypeRoles | struct IPauseManager.PauseTypeRole[] | The list of pause types to associate with roles. |
| _unpauseTypeRoles | struct IPauseManager.PauseTypeRole[] | The list of unpause types to associate with roles. |
| _fallbackOperator | address | The address of the fallback operator. |

### renounceRole

```solidity
function renounceRole(bytes32 _role, address _account) public
```

Revokes `role` from the calling account.

_Fallback operator cannot renounce role. Reverts with OnlyNonFallbackOperator._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _role | bytes32 | The role to renounce. |
| _account | address | The account to renounce - can only be the _msgSender(). |

### setVerifierAddress

```solidity
function setVerifierAddress(address _newVerifierAddress, uint256 _proofType) external
```

Adds or updates the verifier contract address for a proof type.

_VERIFIER_SETTER_ROLE is required to execute._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _newVerifierAddress | address | The address for the verifier contract. |
| _proofType | uint256 | The proof type being set/updated. |

### setFallbackOperator

```solidity
function setFallbackOperator(uint256 _messageNumber, bytes32 _rollingHash, uint256 _lastFinalizedTimestamp) external
```

Sets the fallback operator role to the specified address if six months have passed since the last finalization.

_Reverts if six months have not passed since the last finalization._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _messageNumber | uint256 | Last finalized L1 message number as part of the feedback loop. |
| _rollingHash | bytes32 | Last finalized L1 rolling hash as part of the feedback loop. |
| _lastFinalizedTimestamp | uint256 | Last finalized L2 block timestamp. |

### unsetVerifierAddress

```solidity
function unsetVerifierAddress(uint256 _proofType) external
```

Unset the verifier contract address for a proof type.

_VERIFIER_UNSETTER_ROLE is required to execute._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _proofType | uint256 | The proof type being set/updated. |

### submitBlobs

```solidity
function submitBlobs(struct ILineaRollup.BlobSubmission[] _blobSubmissions, bytes32 _parentShnarf, bytes32 _finalBlobShnarf) external
```

Submit one or more EIP-4844 blobs.

_OPERATOR_ROLE is required to execute.
This should be a blob carrying transaction._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _blobSubmissions | struct ILineaRollup.BlobSubmission[] | The data for blob submission including proofs and required polynomials. |
| _parentShnarf | bytes32 | The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation. |
| _finalBlobShnarf | bytes32 | The expected final shnarf post computation of all the blob shnarfs. |

### submitDataAsCalldata

```solidity
function submitDataAsCalldata(struct ILineaRollup.CompressedCalldataSubmission _submission, bytes32 _parentShnarf, bytes32 _expectedShnarf) external
```

Submit blobs using compressed data via calldata.

_OPERATOR_ROLE is required to execute._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _submission | struct ILineaRollup.CompressedCalldataSubmission | The supporting data for compressed data submission including compressed data. |
| _parentShnarf | bytes32 | The parent shnarf used in continuity checks as it includes the parentStateRootHash in its computation. |
| _expectedShnarf | bytes32 | The expected shnarf post computation of all the submission. |

### _computeLastFinalizedState

```solidity
function _computeLastFinalizedState(uint256 _messageNumber, bytes32 _rollingHash, uint256 _timestamp) internal pure returns (bytes32 hashedFinalizationState)
```

Internal function to compute and save the finalization state.

_Using assembly this way is cheaper gas wise._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _messageNumber | uint256 | Is the last L2 computed L1 message number in the finalization. |
| _rollingHash | bytes32 | Is the last L2 computed L1 rolling hash in the finalization. |
| _timestamp | uint256 | The final timestamp in the finalization. |

### _computeShnarf

```solidity
function _computeShnarf(bytes32 _parentShnarf, bytes32 _snarkHash, bytes32 _finalStateRootHash, bytes32 _dataEvaluationPoint, bytes32 _dataEvaluationClaim) internal pure returns (bytes32 shnarf)
```

Internal function to compute the shnarf more efficiently.

_Using assembly this way is cheaper gas wise._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _parentShnarf | bytes32 | The shnarf of the parent data item. |
| _snarkHash | bytes32 | Is the computed hash for compressed data (using a SNARK-friendly hash function) that aggregates per data submission to be used in public input. |
| _finalStateRootHash | bytes32 | The final state root hash of the data being submitted. |
| _dataEvaluationPoint | bytes32 | The data evaluation point. |
| _dataEvaluationClaim | bytes32 | The data evaluation claim. |

### _verifyPointEvaluation

```solidity
function _verifyPointEvaluation(bytes32 _currentDataHash, uint256 _dataEvaluationPoint, uint256 _dataEvaluationClaim, bytes _kzgCommitment, bytes _kzgProof) internal view
```

Performs point evaluation for the compressed blob.

__dataEvaluationPoint is modular reduced to be lower than the BLS_CURVE_MODULUS for precompile checks._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _currentDataHash | bytes32 | The current blob versioned hash. |
| _dataEvaluationPoint | uint256 | The data evaluation point. |
| _dataEvaluationClaim | uint256 | The data evaluation claim. |
| _kzgCommitment | bytes | The blob KZG commitment. |
| _kzgProof | bytes | The blob KZG point proof. |

### finalizeBlocks

```solidity
function finalizeBlocks(bytes _aggregatedProof, uint256 _proofType, struct ILineaRollup.FinalizationDataV3 _finalizationData) external
```

Finalize compressed blocks with proof.

_OPERATOR_ROLE is required to execute._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _aggregatedProof | bytes | The aggregated proof. |
| _proofType | uint256 | The proof type. |
| _finalizationData | struct ILineaRollup.FinalizationDataV3 | The full finalization data. |

### _finalizeBlocks

```solidity
function _finalizeBlocks(struct ILineaRollup.FinalizationDataV3 _finalizationData, uint256 _lastFinalizedBlock) internal returns (bytes32 finalShnarf)
```

Internal function to finalize compressed blocks.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _finalizationData | struct ILineaRollup.FinalizationDataV3 | The full finalization data. |
| _lastFinalizedBlock | uint256 | The last finalized block. |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| finalShnarf | bytes32 | The final computed shnarf in finalizing. |

### _validateL2ComputedRollingHash

```solidity
function _validateL2ComputedRollingHash(uint256 _rollingHashMessageNumber, bytes32 _rollingHash) internal view
```

Internal function to validate l1 rolling hash.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _rollingHashMessageNumber | uint256 | Message number associated with the rolling hash as computed on L2. |
| _rollingHash | bytes32 | L1 rolling hash as computed on L2. |

### _calculateY

```solidity
function _calculateY(bytes _data, bytes32 _dataEvaluationPoint) internal pure returns (bytes32 compressedDataComputedY)
```

Internal function to calculate Y for public input generation.

_Each chunk of 32 bytes must start with a 0 byte.
The dataEvaluationPoint value is modulo-ed down during the computation and scalar field checking is not needed.
There is a hard constraint in the circuit to enforce the polynomial degree limit (4096), which will also be enforced with EIP-4844._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _data | bytes | Compressed data from submission data. |
| _dataEvaluationPoint | bytes32 | The data evaluation point. |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| compressedDataComputedY | bytes32 | The Y calculated value using the Horner method. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/messageservice/l2/v1/l2messageservicev1.mdx ====================

# `L2MessageServiceV1`

### MINIMUM_FEE_SETTER_ROLE

```solidity
bytes32 MINIMUM_FEE_SETTER_ROLE
```

The role required to set the minimum DDOS fee.

### _messageSender

```solidity
address _messageSender
```

_The temporary message sender set when claiming a message._

### nextMessageNumber

```solidity
uint256 nextMessageNumber
```

### minimumFeeInWei

```solidity
uint256 minimumFeeInWei
```

### REFUND_OVERHEAD_IN_GAS

```solidity
uint256 REFUND_OVERHEAD_IN_GAS
```

### DEFAULT_SENDER_ADDRESS

```solidity
address DEFAULT_SENDER_ADDRESS
```

_The default message sender address reset after claiming a message._

### constructor

```solidity
constructor() internal
```

### sendMessage

```solidity
function sendMessage(address _to, uint256 _fee, bytes _calldata) external payable
```

Adds a message for sending cross-chain and emits a relevant event.

_The message number is preset and only incremented at the end if successful for the next caller._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _to | address | The address the message is intended for. |
| _fee | uint256 | The fee being paid for the message delivery. |
| _calldata | bytes | The calldata to pass to the recipient. |

### claimMessage

```solidity
function claimMessage(address _from, address _to, uint256 _fee, uint256 _value, address payable _feeRecipient, bytes _calldata, uint256 _nonce) external
```

Claims and delivers a cross-chain message.

__feeRecipient Can be set to address(0) to receive as msg.sender.
messageSender Is set temporarily when claiming and reset post._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _from | address | The address of the original sender. |
| _to | address | The address the message is intended for. |
| _fee | uint256 | The fee being paid for the message delivery. |
| _value | uint256 | The value to be transferred to the destination address. |
| _feeRecipient | address payable | The recipient for the fee. |
| _calldata | bytes | The calldata to pass to the recipient. |
| _nonce | uint256 | The unique auto generated message number used when sending the message. |

### setMinimumFee

```solidity
function setMinimumFee(uint256 _feeInWei) external
```

The Fee Manager sets a minimum fee to address DOS protection.

_MINIMUM_FEE_SETTER_ROLE is required to set the minimum fee._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _feeInWei | uint256 | New minimum fee in Wei. |

### sender

```solidity
function sender() external view returns (address originalSender)
```

_The _messageSender address is set temporarily when claiming._

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| originalSender | address | The original sender stored temporarily at the _messageSender address in storage. |

### distributeFees

```solidity
modifier distributeFees(uint256 _feeInWei, address _to, bytes _calldata, address _feeRecipient)
```

The unspent fee is refunded if applicable.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _feeInWei | uint256 | The fee paid for delivery in Wei. |
| _to | address | The recipient of the message and gas refund. |
| _calldata | bytes | The calldata of the message. |
| _feeRecipient | address |  |



==================== FILE: /workspace/docs/api/linea-smart-contracts/messageservice/l2/v1/l2messagemanagerv1.mdx ====================

# `L2MessageManagerV1`

### INBOX_STATUS_UNKNOWN

```solidity
uint8 INBOX_STATUS_UNKNOWN
```

The 3 status constants for L1 to L2 message statuses.

### INBOX_STATUS_RECEIVED

```solidity
uint8 INBOX_STATUS_RECEIVED
```

### INBOX_STATUS_CLAIMED

```solidity
uint8 INBOX_STATUS_CLAIMED
```

### inboxL1L2MessageStatus

```solidity
mapping(bytes32 => uint256) inboxL1L2MessageStatus
```

_Mapping to store L1->L2 message hashes status.
messageHash => messageStatus (0: unknown, 1: received, 2: claimed)._

### _updateL1L2MessageStatusToClaimed

```solidity
function _updateL1L2MessageStatusToClaimed(bytes32 _messageHash) internal
```

Update the status of L1->L2 message when a user claims a message on L2.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _messageHash | bytes32 | Hash of the message. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/messageservice/l2/l2messageservice.mdx ====================

# `L2MessageService`

### CONTRACT_VERSION

```solidity
string CONTRACT_VERSION
```

_This is the ABI version and not the reinitialize version._

### constructor

```solidity
constructor() public
```

### initialize

```solidity
function initialize(uint256 _rateLimitPeriod, uint256 _rateLimitAmount, address _defaultAdmin, struct IPermissionsManager.RoleAddress[] _roleAddresses, struct IPauseManager.PauseTypeRole[] _pauseTypeRoles, struct IPauseManager.PauseTypeRole[] _unpauseTypeRoles) external
```

Initializes underlying message service dependencies.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _rateLimitPeriod | uint256 | The period to rate limit against. |
| _rateLimitAmount | uint256 | The limit allowed for withdrawing the period. |
| _defaultAdmin | address | The account to be given DEFAULT_ADMIN_ROLE on initialization. |
| _roleAddresses | struct IPermissionsManager.RoleAddress[] | The list of addresses to grant roles to. |
| _pauseTypeRoles | struct IPauseManager.PauseTypeRole[] | The list of pause type roles. |
| _unpauseTypeRoles | struct IPauseManager.PauseTypeRole[] | The list of unpause type roles. |

### reinitializePauseTypesAndPermissions

```solidity
function reinitializePauseTypesAndPermissions(struct IPermissionsManager.RoleAddress[] _roleAddresses, struct IPauseManager.PauseTypeRole[] _pauseTypeRoles, struct IPauseManager.PauseTypeRole[] _unpauseTypeRoles) external
```

Sets permissions for a list of addresses and their roles as well as initialises the PauseManager pauseType:role mappings.

_This function is a reinitializer and can only be called once per version. Should be called using an upgradeAndCall transaction to the ProxyAdmin._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _roleAddresses | struct IPermissionsManager.RoleAddress[] | The list of addresses and roles to assign permissions to. |
| _pauseTypeRoles | struct IPauseManager.PauseTypeRole[] | The list of pause types to associate with roles. |
| _unpauseTypeRoles | struct IPauseManager.PauseTypeRole[] | The list of unpause types to associate with roles. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/messageservice/l2/l2messagemanager.mdx ====================

# `L2MessageManager`

### L1_L2_MESSAGE_SETTER_ROLE

```solidity
bytes32 L1_L2_MESSAGE_SETTER_ROLE
```

The role required to anchor L1 to L2 message hashes.

### lastAnchoredL1MessageNumber

```solidity
uint256 lastAnchoredL1MessageNumber
```

Contains the last L1 message number anchored on L2.

### l1RollingHashes

```solidity
mapping(uint256 => bytes32) l1RollingHashes
```

Contains the L1 to L2 messaging rolling hashes mapped to message number computed on L2.

### anchorL1L2MessageHashes

```solidity
function anchorL1L2MessageHashes(bytes32[] _messageHashes, uint256 _startingMessageNumber, uint256 _finalMessageNumber, bytes32 _finalRollingHash) external
```

Add cross-chain L1->L2 message hashes in storage.

_Only address that has the role 'L1_L2_MESSAGE_SETTER_ROLE' are allowed to call this function.
NB: In the unlikely event of a duplicate anchoring, the lastAnchoredL1MessageNumber MUST NOT be incremented.
and the rolling hash not calculated, else synchronisation will break.
If starting number is zero, an underflow error is expected._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _messageHashes | bytes32[] | New message hashes to anchor on L2. |
| _startingMessageNumber | uint256 | The expected L1 message number to start when anchoring. |
| _finalMessageNumber | uint256 | The expected L1 message number to end on when anchoring. |
| _finalRollingHash | bytes32 | The expected L1 rolling hash to end on when anchoring. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/messageservice/messageservicebase.mdx ====================

# `MessageServiceBase`

### messageService

```solidity
contract IMessageService messageService
```

The message service address on the current chain.

### remoteSender

```solidity
address remoteSender
```

The token bridge on the alternate/remote chain.

### RemoteSenderSet

```solidity
event RemoteSenderSet(address remoteSender, address setter)
```

_Event emitted when the remote sender is set._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| remoteSender | address | The address of the new remote sender. |
| setter | address | The address of the account that set the remote sender. |

### CallerIsNotMessageService

```solidity
error CallerIsNotMessageService()
```

_Thrown when the caller address is not the message service address_

### SenderNotAuthorized

```solidity
error SenderNotAuthorized()
```

_Thrown when remote sender address is not authorized._

### onlyMessagingService

```solidity
modifier onlyMessagingService()
```

_Modifier to make sure the caller is the known message service.

Requirements:

- The msg.sender must be the message service._

### onlyAuthorizedRemoteSender

```solidity
modifier onlyAuthorizedRemoteSender()
```

_Modifier to make sure the original sender is allowed.

Requirements:

- The original message sender via the message service must be a known sender._

### __MessageServiceBase_init

```solidity
function __MessageServiceBase_init(address _messageService) internal
```

Initializes the message service

_Must be initialized in the initialize function of the main contract or constructor._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _messageService | address | The message service address, cannot be empty. |

### _setRemoteSender

```solidity
function _setRemoteSender(address _remoteSender) internal
```

Sets the remote sender

_This function sets the remote sender address and emits the RemoteSenderSet event._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _remoteSender | address | The authorized remote sender address, cannot be empty. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/messageservice/lib/timelock.mdx ====================

# `TimeLock`

This timelock contract will be the owner of all upgrades that gives users confidence and an ability to exit should they want to before an upgrade takes place

### constructor

```solidity
constructor(uint256 minDelay, address[] proposers, address[] executors, address admin) public
```



==================== FILE: /workspace/docs/api/linea-smart-contracts/messageservice/lib/transientstoragehelpers.mdx ====================

# `TransientStorageHelpers`

### tstoreUint256

```solidity
function tstoreUint256(bytes32 _key, uint256 _value) internal
```

Internal function that stores a uint256 value at a given key in the EVM's transient storage using the `tstore` opcode.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _key | bytes32 | The key in the EVM transient storage where the value should be stored. |
| _value | uint256 | The uint256 value to be stored at the specified key in the EVM transient storage. |

### tloadUint256

```solidity
function tloadUint256(bytes32 _key) internal view returns (uint256 value)
```

Internal function that retrieves a uint256 value from the EVM's transient storage using the `tload` opcode.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _key | bytes32 | The key in the EVM transient storage from which the value should be retrieved. |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| value | uint256 | The uint256 value retrieved from the specified key in the EVM transient storage. |

### tstoreAddress

```solidity
function tstoreAddress(bytes32 _key, address _addr) internal
```

Internal function that stores an address at a given key in the EVM's transient storage using the `tstore` opcode.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _key | bytes32 | The key in the EVM transient storage where the value should be stored. |
| _addr | address | The address to be stored at the specified key in the EVM transient storage. |

### tloadAddress

```solidity
function tloadAddress(bytes32 _key) internal view returns (address addr)
```

Internal function that retrieves an address from the EVM's transient storage using the `tload` opcode.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _key | bytes32 | The key in the EVM transient storage from which the value should be retrieved. |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| addr | address | The address retrieved from the specified key in the EVM transient storage. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/messageservice/lib/ratelimiter.mdx ====================

# `RateLimiter`

You can use this control numeric limits over a period using timestamp.

### RATE_LIMIT_SETTER_ROLE

```solidity
bytes32 RATE_LIMIT_SETTER_ROLE
```

### USED_RATE_LIMIT_RESETTER_ROLE

```solidity
bytes32 USED_RATE_LIMIT_RESETTER_ROLE
```

### periodInSeconds

```solidity
uint256 periodInSeconds
```

### limitInWei

```solidity
uint256 limitInWei
```

### currentPeriodEnd

```solidity
uint256 currentPeriodEnd
```

The time at which the current period ends at.

_Public for ease of consumption._

### currentPeriodAmountInWei

```solidity
uint256 currentPeriodAmountInWei
```

Amounts already withdrawn this period.

_Public for ease of consumption._

### __RateLimiter_init

```solidity
function __RateLimiter_init(uint256 _periodInSeconds, uint256 _limitInWei) internal
```

Initialises the limits and period for the rate limiter.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _periodInSeconds | uint256 | The length of the period in seconds. |
| _limitInWei | uint256 | The limit allowed in the period in Wei. |

### _addUsedAmount

```solidity
function _addUsedAmount(uint256 _usedAmount) internal
```

Increments the amount used in the period.

_The amount determining logic is external to this (e.g. fees are included when calling here).
Ignores the calculation if _usedAmount is zero.
Reverts if the limit is breached._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _usedAmount | uint256 | The amount used to be added. |

### resetRateLimitAmount

```solidity
function resetRateLimitAmount(uint256 _amount) external
```

Resets the rate limit amount.

_If the used amount is higher, it is set to the limit to avoid confusion/issues.
Only the RATE_LIMIT_SETTER_ROLE is allowed to execute this function.
Emits the LimitAmountChanged event.
usedLimitAmountToSet will use the default value of zero if period has expired._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _amount | uint256 | The amount to reset the limit to. |

### resetAmountUsedInPeriod

```solidity
function resetAmountUsedInPeriod() external
```

Resets the amount used to zero.

_Only the USED_RATE_LIMIT_RESETTER_ROLE is allowed to execute this function.
Emits the AmountUsedInPeriodReset event._



==================== FILE: /workspace/docs/api/linea-smart-contracts/messageservice/lib/sparsemerkletreeverifier.mdx ====================

# `SparseMerkleTreeVerifier`

### SafeCastOverflowedUintDowncast

```solidity
error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value)
```

_Value doesn't fit in a uint of `bits` size.
This is based on OpenZeppelin's SafeCast library._

### LeafIndexOutOfBounds

```solidity
error LeafIndexOutOfBounds(uint32 leafIndex, uint32 maxAllowedIndex)
```

_Custom error for when the leaf index is out of bounds._

### _verifyMerkleProof

```solidity
function _verifyMerkleProof(bytes32 _leafHash, bytes32[] _proof, uint32 _leafIndex, bytes32 _root) internal pure returns (bool proofIsValid)
```

Verify merkle proof

_The depth of the tree is expected to be validated elsewhere beforehand._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _leafHash | bytes32 | Leaf hash. |
| _proof | bytes32[] | Sparse merkle tree proof. |
| _leafIndex | uint32 | Index of the leaf. |
| _root | bytes32 | Merkle root. |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| proofIsValid | bool | Returns if the proof is valid or not. |

### safeCastToUint32

```solidity
function safeCastToUint32(uint256 _value) internal pure returns (uint32 castUint32)
```

Tries to safely cast to uint32.

_This is based on OpenZeppelin's SafeCast library._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _value | uint256 | The value being cast to uint32. |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| castUint32 | uint32 | Returns a uint32 safely cast. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/messageservice/lib/messagehashing.mdx ====================

# `MessageHashing`

### _hashMessage

```solidity
function _hashMessage(address _from, address _to, uint256 _fee, uint256 _valueSent, uint256 _messageNumber, bytes _calldata) internal pure returns (bytes32 messageHash)
```

Hashes messages using assembly for efficiency.

_Adding 0xc0 is to indicate the calldata offset relative to the memory being added to.
If the calldata is not modulus 32, the extra bit needs to be added on at the end else the hash is wrong._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _from | address | The from address. |
| _to | address | The to address. |
| _fee | uint256 | The fee paid for delivery. |
| _valueSent | uint256 | The value to be sent when delivering. |
| _messageNumber | uint256 | The unique message number. |
| _calldata | bytes | The calldata to be passed to the destination address. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/messageservice/l1/v1/l1messagemanagerv1.mdx ====================

# `L1MessageManagerV1`

### INBOX_STATUS_UNKNOWN

```solidity
uint8 INBOX_STATUS_UNKNOWN
```

The 2 legacy status constants for message statuses.

### INBOX_STATUS_RECEIVED

```solidity
uint8 INBOX_STATUS_RECEIVED
```

### OUTBOX_STATUS_UNKNOWN

```solidity
uint8 OUTBOX_STATUS_UNKNOWN
```

The 3 legacy status constants for message statuses.

### OUTBOX_STATUS_SENT

```solidity
uint8 OUTBOX_STATUS_SENT
```

### OUTBOX_STATUS_RECEIVED

```solidity
uint8 OUTBOX_STATUS_RECEIVED
```

### outboxL1L2MessageStatus

```solidity
mapping(bytes32 => uint256) outboxL1L2MessageStatus
```

_DEPRECATED in favor of the rollingHashes mapping on the L1MessageManager for L1 to L2 messaging._

### inboxL2L1MessageStatus

```solidity
mapping(bytes32 => uint256) inboxL2L1MessageStatus
```

_Mapping to store L2->L1 message hashes status.
messageHash => messageStatus (0: unknown, 1: received).
For the most part this has been deprecated. This is only used for messages received pre-AlphaV2._

### _updateL2L1MessageStatusToClaimed

```solidity
function _updateL2L1MessageStatusToClaimed(bytes32 _messageHash) internal
```

Update the status of L2->L1 message when a user claims a message on L1.

_The L2->L1 message is removed from storage.
Due to the nature of the rollup, we should not get a second entry of this._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _messageHash | bytes32 | Hash of the message. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/messageservice/l1/v1/l1messageservicev1.mdx ====================

# `L1MessageServiceV1`

### nextMessageNumber

```solidity
uint256 nextMessageNumber
```

### _messageSender

```solidity
address _messageSender
```

_DEPRECATED in favor of new transient storage with `MESSAGE_SENDER_TRANSIENT_KEY` key._

### REFUND_OVERHEAD_IN_GAS

```solidity
uint256 REFUND_OVERHEAD_IN_GAS
```

_adding these should not affect storage as they are constants and are stored in bytecode._

### MESSAGE_SENDER_TRANSIENT_KEY

```solidity
bytes32 MESSAGE_SENDER_TRANSIENT_KEY
```

_The transient storage key to set the message sender against while claiming._

### DEFAULT_MESSAGE_SENDER_TRANSIENT_VALUE

```solidity
address DEFAULT_MESSAGE_SENDER_TRANSIENT_VALUE
```

The default value for the message sender reset to post claiming using the MESSAGE_SENDER_TRANSIENT_KEY.

### distributeFees

```solidity
modifier distributeFees(uint256 _feeInWei, address _to, bytes _calldata, address _feeRecipient)
```

The unspent fee is refunded if applicable.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _feeInWei | uint256 | The fee paid for delivery in Wei. |
| _to | address | The recipient of the message and gas refund. |
| _calldata | bytes | The calldata of the message. |
| _feeRecipient | address |  |

### claimMessage

```solidity
function claimMessage(address _from, address _to, uint256 _fee, uint256 _value, address payable _feeRecipient, bytes _calldata, uint256 _nonce) external
```

Claims and delivers a cross-chain message.

__feeRecipient can be set to address(0) to receive as msg.sender.
The original message sender address is temporarily set in transient storage,
while claiming. This address is used in sender()._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _from | address | The address of the original sender. |
| _to | address | The address the message is intended for. |
| _fee | uint256 | The fee being paid for the message delivery. |
| _value | uint256 | The value to be transferred to the destination address. |
| _feeRecipient | address payable | The recipient for the fee. |
| _calldata | bytes | The calldata to pass to the recipient. |
| _nonce | uint256 | The unique auto generated nonce used when sending the message. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/messageservice/l1/l1messagemanager.mdx ====================

# `L1MessageManager`

### rollingHashes

```solidity
mapping(uint256 => bytes32) rollingHashes
```

Contains the L1 to L2 messaging rolling hashes mapped to message number computed on L1.

### _messageClaimedBitMap

```solidity
struct BitMaps.BitMap _messageClaimedBitMap
```

This maps which message numbers have been claimed to prevent duplicate claiming.

### l2MerkleRootsDepths

```solidity
mapping(bytes32 => uint256) l2MerkleRootsDepths
```

Contains the L2 messages Merkle roots mapped to their tree depth.

### _addRollingHash

```solidity
function _addRollingHash(uint256 _messageNumber, bytes32 _messageHash) internal
```

Take an existing message hash, calculates the rolling hash and stores at the message number.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _messageNumber | uint256 | The current message number being sent. |
| _messageHash | bytes32 | The hash of the message being sent. |

### _setL2L1MessageToClaimed

```solidity
function _setL2L1MessageToClaimed(uint256 _messageNumber) internal
```

Set the L2->L1 message as claimed when a user claims a message on L1.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _messageNumber | uint256 | The message number on L2. |

### _addL2MerkleRoots

```solidity
function _addL2MerkleRoots(bytes32[] _newRoots, uint256 _treeDepth) internal
```

Add the L2 Merkle roots to the storage.

_This function is called during block finalization.
The _treeDepth does not need to be checked to be non-zero as it is,
already enforced to be non-zero in the circuit, and used in the proof's public input._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _newRoots | bytes32[] | New L2 Merkle roots. |
| _treeDepth | uint256 |  |

### _anchorL2MessagingBlocks

```solidity
function _anchorL2MessagingBlocks(bytes _l2MessagingBlocksOffsets, uint256 _currentL2BlockNumber) internal
```

Emit an event for each L2 block containing L2->L1 messages.

_This function is called during block finalization._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _l2MessagingBlocksOffsets | bytes | Is a sequence of uint16 values, where each value plus the last finalized L2 block number. indicates which L2 blocks have L2->L1 messages. |
| _currentL2BlockNumber | uint256 | Last L2 block number finalized on L1. |

### isMessageClaimed

```solidity
function isMessageClaimed(uint256 _messageNumber) external view returns (bool isClaimed)
```

Checks if the L2->L1 message is claimed or not.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _messageNumber | uint256 | The message number on L2. |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| isClaimed | bool | Returns whether or not the message with _messageNumber has been claimed. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/messageservice/l1/l1messageservice.mdx ====================

# `L1MessageService`

### systemMigrationBlock

```solidity
uint256 systemMigrationBlock
```

_This is currently not in use, but is reserved for future upgrades._

### __MessageService_init

```solidity
function __MessageService_init(uint256 _rateLimitPeriod, uint256 _rateLimitAmount) internal
```

Initialises underlying message service dependencies.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _rateLimitPeriod | uint256 | The period to rate limit against. |
| _rateLimitAmount | uint256 | The limit allowed for withdrawing the period. |

### sendMessage

```solidity
function sendMessage(address _to, uint256 _fee, bytes _calldata) external payable
```

Adds a message for sending cross-chain and emits MessageSent.

_The message number is preset (nextMessageNumber) and only incremented at the end if successful for the next caller.
This function should be called with a msg.value = _value + _fee. The fee will be paid on the destination chain._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _to | address | The address the message is intended for. |
| _fee | uint256 | The fee being paid for the message delivery. |
| _calldata | bytes | The calldata to pass to the recipient. |

### claimMessageWithProof

```solidity
function claimMessageWithProof(struct IL1MessageService.ClaimMessageWithProofParams _params) external
```

Claims and delivers a cross-chain message using a Merkle proof.

_if tree depth is empty, it will revert with L2MerkleRootDoesNotExist.
if tree depth is different than proof size, it will revert with ProofLengthDifferentThanMerkleDepth._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _params | struct IL1MessageService.ClaimMessageWithProofParams | Collection of claim data with proof and supporting data. |

### sender

```solidity
function sender() external view returns (address originalSender)
```

Claims and delivers a cross-chain message.

_The message sender address is set temporarily in the transient storage when claiming._

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| originalSender | address | The message sender address that is stored temporarily in the transient storage when claiming. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/tokenbridge/interfaces/itokenbridge.mdx ====================

# `ITokenBridge`

### InitializationData

```solidity
struct InitializationData {
  address defaultAdmin;
  address messageService;
  address tokenBeacon;
  uint256 sourceChainId;
  uint256 targetChainId;
  address[] reservedTokens;
  struct IPermissionsManager.RoleAddress[] roleAddresses;
  struct IPauseManager.PauseTypeRole[] pauseTypeRoles;
  struct IPauseManager.PauseTypeRole[] unpauseTypeRoles;
}
```

### TokenReserved

```solidity
event TokenReserved(address token)
```

Emitted when the token address is reserved.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| token | address | The indexed token address. |

### ReservationRemoved

```solidity
event ReservationRemoved(address token)
```

Emitted when the token address reservation is removed.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| token | address | The indexed token address. |

### CustomContractSet

```solidity
event CustomContractSet(address nativeToken, address customContract, address setBy)
```

Emitted when the custom token address is set.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| nativeToken | address | The indexed nativeToken token address. |
| customContract | address | The indexed custom contract address. |
| setBy | address | The indexed address of who set the custom contract. |

### BridgingInitiated

```solidity
event BridgingInitiated(address sender, address recipient, address token, uint256 amount)
```

Emitted when token bridging is initiated.

_DEPRECATED in favor of BridgingInitiatedV2._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| sender | address | The indexed sender address. |
| recipient | address | The recipient address. |
| token | address | The indexed token address. |
| amount | uint256 | The indexed token amount. |

### BridgingInitiatedV2

```solidity
event BridgingInitiatedV2(address sender, address recipient, address token, uint256 amount)
```

Emitted when token bridging is initiated.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| sender | address | The indexed sender address. |
| recipient | address | The indexed recipient address. |
| token | address | The indexed token address. |
| amount | uint256 | The token amount. |

### BridgingFinalized

```solidity
event BridgingFinalized(address nativeToken, address bridgedToken, uint256 amount, address recipient)
```

Emitted when token bridging is finalized.

_DEPRECATED in favor of BridgingFinalizedV2._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| nativeToken | address | The indexed native token address. |
| bridgedToken | address | The indexed bridged token address. |
| amount | uint256 | The indexed token amount. |
| recipient | address | The recipient address. |

### BridgingFinalizedV2

```solidity
event BridgingFinalizedV2(address nativeToken, address bridgedToken, uint256 amount, address recipient)
```

Emitted when token bridging is finalized.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| nativeToken | address | The indexed native token address. |
| bridgedToken | address | The indexed bridged token address. |
| amount | uint256 | The token amount. |
| recipient | address | The indexed recipient address. |

### NewToken

```solidity
event NewToken(address token)
```

Emitted when a new token is seen being bridged on the origin chain for the first time.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| token | address | The indexed token address. |

### NewTokenDeployed

```solidity
event NewTokenDeployed(address bridgedToken, address nativeToken)
```

Emitted when a new token is deployed.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| bridgedToken | address | The indexed bridged token address. |
| nativeToken | address | The indexed native token address. |

### RemoteTokenBridgeSet

```solidity
event RemoteTokenBridgeSet(address remoteTokenBridge, address setBy)
```

Emitted when the remote token bridge is set.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| remoteTokenBridge | address | The indexed remote token bridge address. |
| setBy | address | The indexed address that set the remote token bridge. |

### TokenDeployed

```solidity
event TokenDeployed(address token)
```

Emitted when the token is set as deployed.

_This can be triggered by anyone calling confirmDeployment on the alternate chain._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| token | address | The indexed token address. |

### DeploymentConfirmed

```solidity
event DeploymentConfirmed(address[] tokens, address confirmedBy)
```

Emitted when the token deployment is confirmed.

_This can be triggered by anyone provided there is correctly mapped token data._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| tokens | address[] | The token address list. |
| confirmedBy | address | The indexed address confirming deployment. |

### MessageServiceUpdated

```solidity
event MessageServiceUpdated(address newMessageService, address oldMessageService, address setBy)
```

Emitted when the message service address is set.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| newMessageService | address | The indexed new message service address. |
| oldMessageService | address | The indexed old message service address. |
| setBy | address | The indexed address setting the new message service address. |

### ReservedToken

```solidity
error ReservedToken(address token)
```

_Thrown when attempting to bridge a reserved token._

### RemoteTokenBridgeAlreadySet

```solidity
error RemoteTokenBridgeAlreadySet(address remoteTokenBridge)
```

_Thrown when the remote token bridge is already set._

### AlreadyBridgedToken

```solidity
error AlreadyBridgedToken(address token)
```

_Thrown when attempting to reserve an already bridged token._

### InvalidPermitData

```solidity
error InvalidPermitData(bytes4 permitData, bytes4 permitSelector)
```

_Thrown when the permit data is invalid._

### PermitNotFromSender

```solidity
error PermitNotFromSender(address owner)
```

_Thrown when the permit is not from the sender._

### PermitNotAllowingBridge

```solidity
error PermitNotAllowingBridge(address spender)
```

_Thrown when the permit does not grant spending to the bridge._

### ZeroAmountNotAllowed

```solidity
error ZeroAmountNotAllowed(uint256 amount)
```

_Thrown when the amount being bridged is zero._

### NotReserved

```solidity
error NotReserved(address token)
```

_Thrown when trying to unreserve a non-reserved token._

### TokenNotDeployed

```solidity
error TokenNotDeployed(address token)
```

_Thrown when trying to confirm deployment of a non-deployed token._

### AlreadyBrigedToNativeTokenSet

```solidity
error AlreadyBrigedToNativeTokenSet(address token)
```

_Thrown when trying to set a custom contract on a bridged token._

### NativeToBridgedTokenAlreadySet

```solidity
error NativeToBridgedTokenAlreadySet(address token)
```

_Thrown when trying to set a custom contract on an already set token._

### StatusAddressNotAllowed

```solidity
error StatusAddressNotAllowed(address token)
```

_Thrown when trying to set a token that is already either native, deployed or reserved._

### DecimalsAreUnknown

```solidity
error DecimalsAreUnknown(address token)
```

_Thrown when the decimals for a token cannot be determined._

### TokenListEmpty

```solidity
error TokenListEmpty()
```

_Thrown when the token list is empty._

### bridgeTokenWithPermit

```solidity
function bridgeTokenWithPermit(address _token, uint256 _amount, address _recipient, bytes _permitData) external payable
```

Similar to `bridgeToken` function but allows to pass additional
  permit data to do the ERC20 approval in a single transaction.

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _token | address | The address of the token to be bridged. |
| _amount | uint256 | The amount of the token to be bridged. |
| _recipient | address | The address that will receive the tokens on the other chain. |
| _permitData | bytes | The permit data for the token, if applicable. |

### completeBridging

```solidity
function completeBridging(address _nativeToken, uint256 _amount, address _recipient, uint256 _chainId, bytes _tokenMetadata) external
```

_It can only be called from the Message Service. To finalize the bridging
  process, a user or postmen needs to use the `claimMessage` function of the
  Message Service to trigger the transaction._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _nativeToken | address | The address of the token on its native chain. |
| _amount | uint256 | The amount of the token to be received. |
| _recipient | address | The address that will receive the tokens. |
| _chainId | uint256 | The source chainId or target chaindId for this token |
| _tokenMetadata | bytes | Additional data used to deploy the bridged token if it   doesn't exist already. |

### confirmDeployment

```solidity
function confirmDeployment(address[] _tokens) external payable
```

_Change the status to DEPLOYED to the tokens passed in parameter
   Will call the method setDeployed on the other chain using the message Service_

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _tokens | address[] | Array of bridged tokens that have been deployed. |

### setMessageService

```solidity
function setMessageService(address _messageService) external
```

_Change the address of the Message Service._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _messageService | address | The address of the new Message Service. |

### setDeployed

```solidity
function setDeployed(address[] _nativeTokens) external
```

_It can only be called from the Message Service. To change the status of
  the native tokens to DEPLOYED meaning they have been deployed on the other chain
  a user or postman needs to use the `claimMessage` function of the
  Message Service to trigger the transaction._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _nativeTokens | address[] | The addresses of the native tokens. |

### setReserved

```solidity
function setReserved(address _token) external
```

Make sure that _token is native to the current chain
  where you are calling this function from

_Linea can reserve tokens. In this case, the token cannot be bridged.
  Linea can only reserve tokens that have not been bridged before._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _token | address | The address of the token to be set as reserved. |

### setRemoteTokenBridge

```solidity
function setRemoteTokenBridge(address _remoteTokenBridge) external
```

_Sets the address of the remote token bridge. Can only be called once._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _remoteTokenBridge | address | The address of the remote token bridge to be set. |

### removeReserved

```solidity
function removeReserved(address _token) external
```

_Removes a token from the reserved list._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _token | address | The address of the token to be removed from the reserved list. |

### setCustomContract

```solidity
function setCustomContract(address _nativeToken, address _targetContract) external
```

_Linea can set a custom ERC20 contract for specific ERC20.
  For security purpose, Linea can only call this function if the token has
  not been bridged yet._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _nativeToken | address | address of the token on the source chain. |
| _targetContract | address | address of the custom contract. |



==================== FILE: /workspace/docs/api/linea-smart-contracts/tokenbridge/tokenbridge.mdx ====================

# `TokenBridge`

Contract to manage cross-chain ERC20 bridging.

### CONTRACT_VERSION

```solidity
string CONTRACT_VERSION
```

_This is the ABI version and not the reinitialize version._

### SET_MESSAGE_SERVICE_ROLE

```solidity
bytes32 SET_MESSAGE_SERVICE_ROLE
```

Role used for setting the message service address.

### SET_REMOTE_TOKENBRIDGE_ROLE

```solidity
bytes32 SET_REMOTE_TOKENBRIDGE_ROLE
```

Role used for setting the remote token bridge address.

### SET_RESERVED_TOKEN_ROLE

```solidity
bytes32 SET_RESERVED_TOKEN_ROLE
```

Role used for setting a reserved token address.

### REMOVE_RESERVED_TOKEN_ROLE

```solidity
bytes32 REMOVE_RESERVED_TOKEN_ROLE
```

Role used for removing a reserved token address.

### SET_CUSTOM_CONTRACT_ROLE

```solidity
bytes32 SET_CUSTOM_CONTRACT_ROLE
```

Role used for setting a custom token contract address.

### EMPTY

```solidity
address EMPTY
```

EMPTY means a token is not present in the mapping.

### RESERVED_STATUS

```solidity
address RESERVED_STATUS
```

RESERVED means a token is reserved and cannot be bridged.

### NATIVE_STATUS

```solidity
address NATIVE_STATUS
```

NATIVE means a token is native to the current local chain.

### DEPLOYED_STATUS

```solidity
address DEPLOYED_STATUS
```

DEPLOYED means the bridged token contract has been deployed on the remote chain.

### _PERMIT_SELECTOR

```solidity
bytes4 _PERMIT_SELECTOR
```

_The permit selector to be used when decoding the permit._

### tokenBeacon

```solidity
address tokenBeacon
```

The token beacon for deployed tokens.

### nativeToBridgedToken

```solidity
mapping(uint256 => mapping(address => address)) nativeToBridgedToken
```

The chainId mapped to a native token address which is then mapped to the bridged token address.

### bridgedToNativeToken

```solidity
mapping(address => address) bridgedToNativeToken
```

The bridged token address mapped to the native token address.

### sourceChainId

```solidity
uint256 sourceChainId
```

The current layer's chainId from where the bridging is triggered.

### targetChainId

```solidity
uint256 targetChainId
```

The targeted layer's chainId where the bridging is received.

### isNewToken

```solidity
modifier isNewToken(address _token)
```

_Ensures the token has not been bridged before._

### nonZeroAddress

```solidity
modifier nonZeroAddress(address _addr)
```

_Ensures the address is not address(0)._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _addr | address | Address to check. |

### nonZeroAmount

```solidity
modifier nonZeroAmount(uint256 _amount)
```

_Ensures the amount is not 0._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _amount | uint256 | amount to check. |

### constructor

```solidity
constructor() public
```

_Disable constructor for safety_

### initialize

```solidity
function initialize(struct ITokenBridge.InitializationData _initializationData) external
```

Initializes TokenBridge and underlying service dependencies - used for new networks only.

_Contract will be used as proxy implementation._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _initializationData | struct ITokenBridge.InitializationData | The initial data used for initializing the TokenBridge contract. |

### reinitializePauseTypesAndPermissions

```solidity
function reinitializePauseTypesAndPermissions(address _defaultAdmin, struct IPermissionsManager.RoleAddress[] _roleAddresses, struct IPauseManager.PauseTypeRole[] _pauseTypeRoles, struct IPauseManager.PauseTypeRole[] _unpauseTypeRoles) external
```

Sets permissions for a list of addresses and their roles as well as initialises the PauseManager pauseType:role mappings.

_This function is a reinitializer and can only be called once per version. Should be called using an upgradeAndCall transaction to the ProxyAdmin._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _defaultAdmin | address | The default admin account's address. |
| _roleAddresses | struct IPermissionsManager.RoleAddress[] | The list of addresses and roles to assign permissions to. |
| _pauseTypeRoles | struct IPauseManager.PauseTypeRole[] | The list of pause types to associate with roles. |
| _unpauseTypeRoles | struct IPauseManager.PauseTypeRole[] | The list of unpause types to associate with roles. |

### bridgeToken

```solidity
function bridgeToken(address _token, uint256 _amount, address _recipient) public payable
```

This function is the single entry point to bridge tokens to the
  other chain, both for native and already bridged tokens. You can use it
  to bridge any ERC20. If the token is bridged for the first time an ERC20
  (BridgedToken.sol) will be automatically deployed on the target chain.

_User should first allow the bridge to transfer tokens on his behalf.
  Alternatively, you can use BridgeTokenWithPermit to do so in a single
  transaction. If you want the transfer to be automatically executed on the
  destination chain. You should send enough ETH to pay the postman fees.
  Note that Linea can reserve some tokens (which use a dedicated bridge).
  In this case, the token cannot be bridged. Linea can only reserve tokens
  that have not been bridged yet.
  Linea can pause the bridge for security reason. In this case new bridge
  transaction would revert.
Note: If, when bridging an unbridged token and decimals are unknown,
the call will revert to prevent mismatched decimals. Only those ERC20s,
with a decimals function are supported._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _token | address | The address of the token to be bridged. |
| _amount | uint256 | The amount of the token to be bridged. |
| _recipient | address | The address that will receive the tokens on the other chain. |

### bridgeTokenWithPermit

```solidity
function bridgeTokenWithPermit(address _token, uint256 _amount, address _recipient, bytes _permitData) external payable
```

Similar to `bridgeToken` function but allows to pass additional
  permit data to do the ERC20 approval in a single transaction.
_permit can fail silently, don't rely on this function passing as a form
  of authentication

_There is no need for validation at this level as the validation on pausing,
and empty values exists on the "bridgeToken" call._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _token | address | The address of the token to be bridged. |
| _amount | uint256 | The amount of the token to be bridged. |
| _recipient | address | The address that will receive the tokens on the other chain. |
| _permitData | bytes | The permit data for the token, if applicable. |

### completeBridging

```solidity
function completeBridging(address _nativeToken, uint256 _amount, address _recipient, uint256 _chainId, bytes _tokenMetadata) external
```

_It can only be called from the Message Service. To finalize the bridging
  process, a user or postman needs to use the `claimMessage` function of the
  Message Service to trigger the transaction._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _nativeToken | address | The address of the token on its native chain. |
| _amount | uint256 | The amount of the token to be received. |
| _recipient | address | The address that will receive the tokens. |
| _chainId | uint256 | The token's origin layer chaindId |
| _tokenMetadata | bytes | Additional data used to deploy the bridged token if it   doesn't exist already. |

### setMessageService

```solidity
function setMessageService(address _messageService) external
```

_Change the address of the Message Service.
SET_MESSAGE_SERVICE_ROLE is required to execute._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _messageService | address | The address of the new Message Service. |

### confirmDeployment

```solidity
function confirmDeployment(address[] _tokens) external payable
```

_Change the status to DEPLOYED to the tokens passed in parameter
   Will call the method setDeployed on the other chain using the message Service_

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _tokens | address[] | Array of bridged tokens that have been deployed. |

### setDeployed

```solidity
function setDeployed(address[] _nativeTokens) external
```

_Change the status of tokens to DEPLOYED. New bridge transaction will not
  contain token metadata, which save gas.
  Can only be called from the Message Service. A user or postman needs to use
  the `claimMessage` function of the Message Service to trigger the transaction._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _nativeTokens | address[] | Array of native tokens for which the DEPLOYED status must be set. |

### setRemoteTokenBridge

```solidity
function setRemoteTokenBridge(address _remoteTokenBridge) external
```

_Sets the address of the remote token bridge. Can only be called once.
SET_REMOTE_TOKENBRIDGE_ROLE is required to execute._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _remoteTokenBridge | address | The address of the remote token bridge to be set. |

### deployBridgedToken

```solidity
function deployBridgedToken(address _nativeToken, bytes _tokenMetadata, uint256 _chainId) internal returns (address bridgedTokenAddress)
```

_Deploy a new EC20 contract for bridged token using a beacon proxy pattern.
  To adapt to future requirements, Linea can update the implementation of
  all (existing and future) contracts by updating the beacon. This update is
  subject to a delay by a time lock.
  Contracts are deployed using CREATE2 so deployment address is deterministic._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _nativeToken | address | The address of the native token on the source chain. |
| _tokenMetadata | bytes | The encoded metadata for the token. |
| _chainId | uint256 | The chain id on which the token will be deployed, used to calculate the salt |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| bridgedTokenAddress | address | The address of the newly deployed BridgedToken contract. |

### setReserved

```solidity
function setReserved(address _token) external
```

Make sure that _token is native to the current chain
  where you are calling this function from

_Linea can reserve tokens. In this case, the token cannot be bridged.
  Linea can only reserve tokens that have not been bridged before.
SET_RESERVED_TOKEN_ROLE is required to execute._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _token | address | The address of the token to be set as reserved. |

### removeReserved

```solidity
function removeReserved(address _token) external
```

_Removes a token from the reserved list.
REMOVE_RESERVED_TOKEN_ROLE is required to execute._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _token | address | The address of the token to be removed from the reserved list. |

### setCustomContract

```solidity
function setCustomContract(address _nativeToken, address _targetContract) external
```

_Linea can set a custom ERC20 contract for specific ERC20.
  For security purpose, Linea can only call this function if the token has
  not been bridged yet.
SET_CUSTOM_CONTRACT_ROLE is required to execute._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _nativeToken | address | The address of the token on the source chain. |
| _targetContract | address | The address of the custom contract. |

### _safeName

```solidity
function _safeName(address _token) internal view returns (string tokenName)
```

_Provides a safe ERC20.name version which returns 'NO_NAME' as fallback string._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _token | address | The address of the ERC-20 token contract |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| tokenName | string | Returns the string of the token name. |

### _safeSymbol

```solidity
function _safeSymbol(address _token) internal view returns (string symbol)
```

_Provides a safe ERC20.symbol version which returns 'NO_SYMBOL' as fallback string_

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _token | address | The address of the ERC-20 token contract |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| symbol | string | Returns the string of the symbol. |

### _safeDecimals

```solidity
function _safeDecimals(address _token) internal view returns (uint8)
```

Provides a safe ERC20.decimals version which reverts when decimals are unknown
  Note Tokens with (decimals > 255) are not supported

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _token | address | The address of the ERC-20 token contract |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| [0] | uint8 | Returns the token's decimals value. |

### _returnDataToString

```solidity
function _returnDataToString(bytes _data) internal pure returns (string decodedString)
```

_Converts returned data to string. Returns 'NOT_VALID_ENCODING' as fallback value._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _data | bytes | returned data. |

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| decodedString | string | The decoded string data. |

### _permit

```solidity
function _permit(address _token, bytes _permitData) internal
```

Call the token permit method of extended ERC20
Only support tokens implementing ERC-2612

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _token | address | ERC20 token address |
| _permitData | bytes | Raw data of the call `permit` of the token |



==================== FILE: /workspace/docs/api/linea-smart-contracts/tokenbridge/bridgedtoken.mdx ====================

# `BridgedToken`

ERC20 token created when a native token is bridged to a target chain.

### bridge

```solidity
address bridge
```

### _decimals

```solidity
uint8 _decimals
```

### OnlyBridge

```solidity
error OnlyBridge(address bridgeAddress)
```

### constructor

```solidity
constructor() public
```

_Disable constructor for safety_

### initialize

```solidity
function initialize(string _tokenName, string _tokenSymbol, uint8 _tokenDecimals) external
```

### onlyBridge

```solidity
modifier onlyBridge()
```

_Ensures call come from the bridge._

### mint

```solidity
function mint(address _recipient, uint256 _amount) external
```

_Called by the bridge to mint tokens during a bridge transaction._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _recipient | address | The address to receive the minted tokens. |
| _amount | uint256 | The amount of tokens to mint. |

### burn

```solidity
function burn(address _account, uint256 _amount) external
```

_Called by the bridge to burn tokens during a bridge transaction.
User should first have allowed the bridge to spend tokens on their behalf._

#### Parameters

| Name | Type | Description |
| ---- | ---- | ----------- |
| _account | address | The account from which tokens will be burned. |
| _amount | uint256 | The amount of tokens to burn. |

### decimals

```solidity
function decimals() public view returns (uint8)
```

_Overrides ERC20 default function to support tokens with different decimals._

#### Return Values

| Name | Type | Description |
| ---- | ---- | ----------- |
| [0] | uint8 | The number of decimal. |



==================== FILE: /workspace/docs/api/linea-sdk.mdx ====================

---
title: Linea SDK
image: /img/socialCards/linea-sdk.jpg
---

The SDK focuses on interacting with smart contracts on both Ethereum and Linea networks and provides 
custom functions to obtain message information, including claiming bridge messages. You can also use 
the SDK to get:

- Contract instances and addresses
- Message information, by message hash
- Messages by transaction hash
- Getting a message status by message hash

:::info[New features]

The updated Linea SDK package enhances the L1 contract interaction and adds support for the new L1 claiming system, which is based on a Merkle tree and requires a Merkle proof for claiming.

There are three important things to note:

- The previous L1 claiming and all associated functions are still supported.
- The L2 claiming remains unaltered, and all SDK features for interacting with L2 will remain unchanged.
- The previous L1 claiming function and code samples provided here cater to the transition period where pre-transition messages are claimed without the Merkle proof and post-transition with proof. If this SDK is being used after the transition, using the logic that switches between Merkle and non-Merkle proof claiming is suboptimal.

The updated SDK introduces several new features for L1 interactions:

- A new L1ClaimingService class that includes the following functions:
  - `getMessageProof`: This function retrieves the message Merkle tree proof required for new message claims on L1.
  - `isClaimingNeedingProof`: This function determines whether a proof is needed to claim a message.
  - `getMessageStatus`: This function retrieves a message's status, returning the status of both old and new messages.
  - `estimateClaimMessageGas`: This function provides an estimate of the gas cost for both old and new claim transactions.
  - `claimMessage`: This function enables a message to be claimed using either the old or new function.
- Two new functions in the L1 contract:
  - `estimateClaimWithProofGas`: This function estimates the gas cost for new claim transactions.
  - `claimWithProof`: This function claims a message using the new claimMessageWithProof function.

:::

## Usage

:::note

The SDK does not currently support sending messages. This feature will be added in a future release.

:::

To install the package, run:

```bash
npm install @consensys/linea-sdk
```

Then initialize the SDK: 

```typescript
const sdk = new LineaSDK({
  network: 'linea-mainnet', // or 'linea-sepolia' or 'custom'
  mode: 'read-write',
  l1RpcUrlOrProvider: 'YOUR_L1_RPC_URL',
  l2RpcUrlOrProvider: 'YOUR_L2_RPC_URL',
  l1SignerPrivateKeyOrWallet: 'YOUR_L1_PRIVATE_KEY',
  l2SignerPrivateKeyOrWallet: 'YOUR_L2_PRIVATE_KEY'
});

// Get L1 and L2 contract instances
const l1Contract = sdk.getL1Contract();
const l2Contract = sdk.getL2Contract();
```

The SDK supports two `mode`s: 
- `read-only`: The client operates without the ability to send transactions; it can only read data 
from the blockchain and does not require private keys.
- `read-write`: The client can read data and also send transactions, which means you must include
signing credentials with `l1SignerPrivateKeyOrWallet` and `l2SignerPrivateKeyOrWallet`, depending
on which layer you need.

See the [SDK README](https://github.com/Consensys/linea-monorepo/tree/main/sdk#field-explanations) 
for a full list of configuration options.

### Claim

Regardless of the layer you need to claim on, you'll need the message hash of the message sent 
from the origin layer. You can find this in the transaction logs of the message sending transaction
on the block explorer as a `MessageSent` event.

<Tabs className="my-tabs">
  <TabItem value="L1" label="Claim on L1">
    The contract function for claiming on L1, `claimMessageWithProof`, is complex and requires a Merkle 
    proof, Merkle root, and leaf index for the message. The SDK simplifies this by using its [`L1ClaimingService`](https://github.com/Consensys/linea-monorepo/blob/c6550573d3e1840fcfb97c00fc8697933c7b373f/sdk/src/clients/ethereum/L1ClaimingService.ts) 
    to handle the complex logic, meaning you only need to call `claimMessage`. 

    For example:

    ```typescript

    const message = await l2Contract.getMessageByMessageHash("messageHash");

    const messageStatus = await l1ClaimingService.getMessageStatus("messageHash"); 

    if (messageStatus == OnChainMessageStatus.CLAIMABLE) {
      await l1ClaimingService.claimMessage(message);
    }

    ```

    This code checks to locate the message from L2, then whether it's claimable yet on L1. If it is,
    it calls `claimMessage` to claim the message.
  </TabItem>
  <TabItem value="L2" label="Claim on L2">
    In most situations, messages _to_ L2 will be automatically retrieved by the Postman service, and 
    manually claiming with the SDK will not be necessary. Most Postman fees are automatically sponsored 
    by Linea on L2, and therefore do not require a transaction and an accompanying fee to claim,
    and are claimed automatically.

    Since claiming on L2 requires fewer and less complex parameters, we can use the `claim` function:

    ```typescript

    const message = await l1Contract.getMessageByMessageHash("messageHash");

    const messageStatus = await l2Contract.getMessageStatus("messageHash");

    if (messageStatus == OnChainMessageStatus.CLAIMABLE) {
      await l2Contract.claim(message);
    }

    ```

    This code checks to locate the message from L1, then whether it's claimable yet on L2. If it is,
    it calls `claim` to claim the message.

    See the [`L2MessageServiceClient`](https://github.com/Consensys/linea-monorepo/blob/c6550573d3e1840fcfb97c00fc8697933c7b373f/sdk/src/clients/linea/L2MessageServiceClient.ts) 
    for the source code.
  </TabItem>
</Tabs>

## Examples

import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';

<Tabs className="my-tabs" defaultValue="new" values={[ {label: 'v0.2.0-rc.1', value: 'new'}, {label: 'v0.1.6', value: 'old'}, ] }> 
  <TabItem value="old">

  ```typescript
  import * as dotenv from "dotenv";
  import { LineaSDK } from "@consensys/linea-sdk";
  import { BigNumber } from "ethers";

  dotenv.config();

  const sdk = new LineaSDK({
    l1RpcUrl: process.env.L1_RPC_URL ?? "", // L1 rpc url
    l2RpcUrl: process.env.L2_RPC_URL ?? "", // L2 rpc url
    l1SignerPrivateKey: process.env.L1_SIGNER_PRIVATE_KEY ?? "", // L1 account private key (optional if you use mode = read-only)
    l2SignerPrivateKey: process.env.L2_SIGNER_PRIVATE_KEY ?? "", // L2 account private key (optional if you use mode = read-only)
    network: "linea-mainnet", // network you want to interact with (either linea-mainnet or linea-sepolia)
    mode: "read-write", // contract wrapper class mode (read-only or read-write), read-only: only read contracts state, read-write: read contracts state and claim messages
  });

  const l1Contract = sdk.getL1Contract(); // get the L1 contract wrapper instance
  const l2Contract = sdk.getL2Contract(); // get the L2 contract wrapper instance
  const l1ClaimingService = sdk.getL1ClaimingService();

  console.log(
    await l2Contract.getMessageStatus(
      "0x13dd0f5e3611b44c88e80f5206bbe1ce1c6996514cef1e209e9eb06d9f5b9a2d",
    ),
  ); //  returns on-chain message status by message hash
  console.log(
    await l1Contract.getMessageStatus(
      "0x28e9e11b53d624500f7610377c97877bb1ecb3127a88f7eba84dd7a146891946",
    ),
  ); // returns on-chain message status by message hash

  console.log(
    await l2Contract.getMessageByMessageHash(
      "0x13dd0f5e3611b44c88e80f5206bbe1ce1c6996514cef1e209e9eb06d9f5b9a2d",
    ),
  ); // returns message by message hash
  console.log(await l1Contract.getMessageByMessageHash("")); // returns message by message hash

  console.log(
    await l2Contract.getMessagesByTransactionHash(
      "0x4b72c6abacd3e2372a32e2797c41cab08df8d5e6fb2eb453e896e52fe7b70a27",
    ),
  ); // returns message by transaction hash
  console.log(await l1Contract.getMessagesByTransactionHash("")); // returns message by transaction hash

  console.log(
    await l2Contract.getTransactionReceiptByMessageHash(
      "0x13dd0f5e3611b44c88e80f5206bbe1ce1c6996514cef1e209e9eb06d9f5b9a2d",
    ),
  ); // returns transaction receipt by message hash
  console.log(
    await l1Contract.getTransactionReceiptByMessageHash(
      "0x13dd0f5e3611b44c88e80f5206bbe1ce1c6996514cef1e209e9eb06d9f5b9a2d",
    ),
  ); // returns transaction receipt by message hash

  const claimMessage = await l2Contract.claim({
    // claims message by message
    messageSender: "", // address of message sender
    messageHash: "", // message hash
    fee: BigNumber.from(1), // fee
    destination: "", // destination address of message
    value: BigNumber.from(2), // value of message
    calldata: "0x", // call data
    messageNonce: BigNumber.from(1), // message nonce
    feeRecipient: "0x", // address that will receive fees. by default it is the message sender
  });
  ```

  </TabItem> 
  <TabItem value="new">

  ```typescript
  import * as dotenv from "dotenv";
  import { LineaSDK } from "@consensys/linea-sdk";
  import { BigNumber } from 'ethers';


  dotenv.config();

  const sdk = new LineaSDK({
      l1RpcUrl: process.env.L1_RPC_URL ?? "",
      l2RpcUrl: process.env.L2_RPC_URL ?? "",
      l1SignerPrivateKey: process.env.L1_SIGNER_PRIVATE_KEY ?? "",
      l2SignerPrivateKey: process.env.L2_SIGNER_PRIVATE_KEY ?? "",
      network: "linea-mainnet",
      mode: "read-write",
    });

    const l1Contract = sdk.getL1Contract();
    const l2Contract = sdk.getL2Contract();
    const l1ClaimingService = sdk.getL1ClaimingService();

    /********************* Three approaches to claim on L1 *********************/

    // 1. The L1 Claiming service manages all the necessary logic for you.
    const message = await l2Contract.getMessageByMessageHash("messageHash");

    const messageStatus = await l1ClaimingService.getMessageStatus("messageHash");

    if (messageStatus == OnChainMessageStatus.CLAIMABLE) {
      const estimatedGas = await l1ClaimingService.estimateClaimMessageGas(message); // Optional
      await l1ClaimingService.claimMessage(message);
    }

    // 2. You can handle the logic on your side
    const message = await l2Contract.getMessageByMessageHash("messageHash");

    const messageStatus = await l1ClaimingService.getMessageStatus("messageHash");

    if (messageStatus == OnChainMessageStatus.CLAIMABLE) {
      const isProofNeeded = await l1ClaimingService.isClaimingNeedingProof("messageHash");
      if (!isProofNeeded) {
        const estimatedGas = await l1Contract.estimateClaimGas(message) // Optional
        await l1Contract.claim(message);
      } else {
        const proofInfo = await l1ClaimingService.getMessageProof("messageHash");
        const estimatedGas = await l1Contract.estimateClaimWithProofGas({
          ...message,
          proof: proofInfo.proof,
          leafIndex: proofInfo.leafIndex,
          merkleRoot: proofInfo.root,
        }); // Optional

        await l1Contract.claimWithProof({
          ...message,
          proof: proofInfo.proof,
          leafIndex: proofInfo.leafIndex,
          merkleRoot: proofInfo.root,
        });
      }
    }

    // 3. You can implement your own logic to get a merkle proof
    const message = await l2Contract.getMessageByMessageHash("messageHash");

    const messageStatus = await l1ClaimingService.getMessageStatus("messageHash");

    if (messageStatus == OnChainMessageStatus.CLAIMABLE) {
      const isProofNeeded = await l1ClaimingService.isClaimingNeedingProof("messageHash");
      if (!isProofNeeded) {
        const estimatedGas = await l1Contract.estimateClaimGas(message) // Optional
        await l1Contract.claim(message);
      } else {
        const proofInfo = // Implement your own function to get a merkle proof
          // The L1ClaimingService exposes some utility functions to assist you: getFinalizationMessagingInfo, getL2MessageHashesInBlockRange, getMessageSiblings

          // Follow these steps:
          // 1. Retrieve the MessageSent event on L2 by messageHash
          // 2. Retrieve the L2MessagingBlockAnchored event on L1 using the MessageSent.blockNumber you acquired in step 1. This is used to get the finalization transaction hash where the L2 block number associated with your message has been finalized.
          // 3. Invoke the getFinalizationMessagingInfo function using the L2MessagingBlockAnchored.transactionHash you obtained in step 2.
          // This will return all merkle roots anchored during this finalization transaction, the depth of trees, and the first and the last L2 block containing messages finalized on L1 in this transaction.
          // 4. Invoke the getL2MessageHashesInBlockRange function using the first and last L2 block number that you obtained in step 3. This will return all l2 messages hashes in this L2 block range.
          // 5. Invoke the getMessageSiblings function to obtain all message siblings
          // 6. Construct a SparseMerkleTree, add all message siblings you obtained at step 5 to the tree, and return a merkle proof

          // NOTE: You can create your own functions that encompass all steps. Utility functions are merely provided as a helper.

          const estimatedGas = await l1Contract.estimateClaimWithProofGas({
            ...message,
            proof: proofInfo.proof,
            leafIndex: proofInfo.leafIndex,
            merkleRoot: proofInfo.root,
          }); // Optional
          await l1Contract.claimWithProof({
            ...message,
            proof: proofInfo.proof,
            leafIndex: proofInfo.leafIndex,
            merkleRoot: proofInfo.root,
          });
      }
    }

  ```
  </TabItem> 
</Tabs>


==================== FILE: /workspace/docs/get-started/build/network-info.mdx ====================

---
title: Network information
description: Key network details for Linea Mainnet and Linea Sepolia.
image: /img/socialCards/network-information.jpg
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

**Status**: [https://linea.statuspage.io/](https://linea.statuspage.io/)

<Tabs groupId="Mainnet-Testnet" className="my-tabs">
  <TabItem 
  value="Mainnet" label="Mainnet" default>
  <table>
      <tr>
          <td align="left"><b>Network Name</b></td>
          <td align="left">Linea</td>
      </tr>
      <tr>
          <td align="left"><b>RPC URL</b></td>
          <td align="left">https://rpc.linea.build or via <a href="https://support.linea.build/hc/en-us/articles/15752713253147">Infura</a> (recommended)</td>
      </tr>
      <tr>
          <td align="left"><b>Chain ID</b></td>
          <td align="left">59144</td>
      </tr>
      <tr>
          <td align="left"><b>Currency Symbol</b></td>
          <td align="left">ETH</td>
      </tr>
      <tr>
          <td align="left"><b>Block Explorer URL</b></td>
          <td align="left"> <a href="https://lineascan.build/">Lineascan</a>  </td>
      </tr>
  </table>
  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
  <table>
      <tr>
          <td align="left"><b>Network</b></td>
          <td align="left">Linea</td>
      </tr>
      <tr>
          <td align="left"><b>RPC URL</b></td>
          <td align="left">https://rpc.sepolia.linea.build or via <a href="https://support.linea.build/hc/en-us/articles/15752713253147">Infura</a> (recommended)</td>
      </tr>
      <tr>
          <td align="left"><b>Chain ID</b></td>
          <td align="left">59141</td>
      </tr>
      <tr>
          <td align="left"><b>Symbol</b></td>
          <td align="left">ETH</td>
      </tr>
      <tr>
          <td align="left"><b>Block explorer</b></td>
          <td align="left"> <a href="https://sepolia.lineascan.build">Lineascan</a> </td>
      </tr>
  </table>
  </TabItem> 
</Tabs>

## Connect with node providers

If your dapp is using public endpoints, it may encounter rate limiting. You can find Linea node providers
[here](../tooling/node-providers/index.mdx).

We recommend connecting to Linea via [private RPCs](../tooling/node-providers/index.mdx#private-rpc-endpoints).


==================== FILE: /workspace/docs/get-started/build/dapp-support.mdx ====================

---
title: Get support for your project
description: Find out what support is available to help your project grow.
image: /img/socialCards/get-support-for-your-project.jpg
---

Whether you're here to learn, build, or experiment, you're welcome. 

Our developer docs and active Discord are open to all, and we're excited to support your journey. 
That said, Linea operates on a performance-based model. We don't currently offer grants or stipends 
if your app isn't live or generating onchain activity. We won't provide financial support at this 
stage but we'll still cheer you on and help however we can through community resources.

Once your app is audited, live on Linea, and driving real usage, you'll unlock a range of 
opportunities designed to accelerate your growth:

- Promotion on the Linea Hub
- Featured placement on the Hub homepage as a new app
- Shoutouts on X and newsletter highlights
- Promotion of your live campaigns and reward programs on the Linea Hub
- For the most successful apps, potential financial rewards (including Linea co-funding your user 
incentive programs, introductions to top VCs and ecosystem partners, etc.)

We're here to champion builders who ship and scale. If you're creating value, we'll do everything 
we can to help amplify it and make you succeed.


==================== FILE: /workspace/docs/get-started/build/block-explorers.mdx ====================

---
title: Block explorers
description: Block explorers available for Linea Mainnet and Linea Sepolia.
image: /img/socialCards/block-explorers.jpg
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

If you're new to public blockchain networks, you might not be familiar with _block explorers_. It's helpful to remember that the network is keeping track of a _ledger_ of accounts, with tokens attributed to them, sent between them, created by them, etc.

As users take actions on the network, there are changes to those accounts and tokens. A block explorer is an interface through which you can look at that information in all its raw, gritty detail.

> If you want to learn more about explorers and how to use them, check out the [MetaMask help center](https://support.metamask.io/managing-my-wallet/how-to-check-my-wallet-activity-on-the-blockchain-explorer/)

<Tabs groupId="Mainnet-Testnet" className="my-tabs">
  <TabItem value="Mainnet" label="Mainnet" default>
    <table>
      <thead>
        <tr>
          <th>Explorer name</th>
          <th>URL</th>
          <th>API URL</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Lineascan</td>
          <td>https://lineascan.build</td>
          <td>`https://api.lineascan.build/api`</td>
        </tr>
        <tr>
          <td>Lineaplorer</td>
          <td>https://lineaplorer.build/</td>
          <td>`https://lineaplorer.build/api`</td>
        </tr>
        {/* It would appear that L2Scan, as of Aug 14, 2025, only supports the Merlin and B2 networks.
        Removing this entry.*/}
        <tr> 
          <td>Blockscout</td>
          <td>https://explorer.linea.build</td>
          <td>`https://explorer.linea.build/api`</td>
        </tr>
        <tr>
          <td>OKLink</td>
          <td>https://oklink.com/linea</td>
          <td>`https://oklink.com/docs/en/#welcome-to-oklink-api`</td>
        </tr>
        <tr>
          <td>Chainlens</td>
          <td>https://linea.chainlens.com/</td>
          <td>`https://linea.chainlens.com/api`</td>
        </tr>
        {/* It would appear that, as of August 14, 2025, Socialscan has deprecated the Linea explorer.
        However, manta.socialscan.io for example still exists; leaving this here for now in case the Linea instance is fixed. */}
        {/* <tr>
          <td>Socialscan</td>
          <td>https://linea.socialscan.io/</td>
          <td>`https://api.socialscan.io/linea`</td>
        </tr> */}
        <tr>
          <td>Linea for Humans</td>
          <td>https://linea.forhumans.app/</td>
          <td>n/a</td>
        </tr>
        <tr>
          <td>0xPPL</td>
          <td>https://0xppl.com/Linea/overview</td>
          <td>n/a</td>
        </tr>
        <tr>
          <td>Arkham</td>
          <td>https://platform.arkhamintelligence.com/</td>
          <td>n/a</td>
        </tr>
        {/* As of August 14, 2025, it would appear NFTScan no longer supports Linea.
        Removing their entry. */}
      </tbody>
    </table>
  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia" default>
    <table>
      <thead>
        <tr>
          <th>Explorer name</th>
          <th>URL</th>
          <th>API URL</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Lineascan</td>
          <td>https://sepolia.lineascan.build</td>
          <td>`https://api-sepolia.lineascan.build/api`</td>
        </tr>
        <tr>
          <td>Blockscout</td>
          <td>https://explorer.sepolia.linea.build/</td>
          <td>`https://explorer.sepolia.linea.build/api`</td>
        </tr>
      </tbody>
    </table>
  </TabItem>
</Tabs>


==================== FILE: /workspace/docs/get-started/build/quickstart/hub.mdx ====================

---
title: List your app on the Linea Hub
sidebar_position: 3
description: >-
  A guide to listing your app on the Linea hub, and tips for optimizing your
  listing
image: /img/socialCards/list-your-app-on-the-linea-hub.jpg
---

import Banner from "../../../../static/img/get_started/build/quickstart/hub/banner_example.svg";
import LabelledBanner from "../../../../static/img/get_started/build/quickstart/hub/labelled_banner.svg";
import SubmissionButton from "../../../../src/components/SubmissionButton";

Publishing your app on the [Linea Hub](https://linea.build/hub) is the easiest way to reach users, grow your traffic, and get 
discovered in the Linea ecosystem. This is where the journey begins for production-ready apps. 

<SubmissionButton />

A great listing boosts your visibility. A verified contract builds trust. And the more usage you get, 
the more we'll support and amplify your project.

Here's what your listing will look like on the Hub:

<div className="img-large" style={{ display: 'flex', justifyContent: 'center' }}>
   <Banner alt="Example banner" />
</div>

:::info[What you'll need]

- A [deployed app](./app) live on Linea Mainnet
- A clear project name and short description
- A logo and banner image
- Verified [smart contract](./deploy)
- Accurate URLs (website, app, socials, etc.)

:::

Here's how the information you'll need matches up to the elements in your listing:


<div className="img-medium">
   <LabelledBanner alt="Labelled banner" />
</div>

## Checklist: Create a great app page on the Linea Hub

Your app page is the gateway for your new users on Linea. Every section should help visitors understand what your app does, why it’s worth trying, and how it will add value to their onchain experience. If you have all the elements below for your app, you're on the right track:


### 1. Name
**Choose a simple, distinctive name that’s easy to read and remember.**

- It should hint at what your app does, while standing out among others.
  - **Protip:** Avoid using generic terms or names that are too close to existing apps!

### 2. Icon
**Your icon is your app's "visual handshake" with your users.**

- Keep it visually clean, on-brand, and easily recognizable even at small sizes (think favicon).
  - Avoid unnecessary details that clutter the design.

### 3. Tagline
**Think of your tagline as your app’s elevator pitch, in a single line.**
  
- Highlight a clear, tangible benefit, *not* vague superlatives.
  - Readers should **immediately grasp your app’s core value**.

### 4. Banner
**Your banner is the visual anchor of your app page.**

- Use a high-quality, uncluttered image that conveys your app’s feel and purpose.
- Avoid adding text; your app's name and tagline already appear above the banner.
- **Avoid light background colors**
- Keep important visual elements in **the top right section** to avoid cropping.
  
### App button
**Your app button should take users directly into the most engaging part of your app.**

- The Linea Hub is used across mobile and desktop, so **ensure your app is fully optimized for mobile use**.
- We automatically append UTM parameters to the button's URL, so you can track traffic coming from the Hub within your analytics stack. This helps to track conversions from the Hub, and provides insight to improve your app.

### 6. Screenshots
**Add up to three clear screenshots that capture the core features and user experience of your app.**

- Use these images to tell a visual story of what users can expect when they try your app.

### 7. Overview
**This is a compelling written introduction to your app.**

- The first sentence of your description is the most important: it’s what will make users decide to read more!
- Explain the problem your app solves, and why users will benefit from it.
- Follow this with a concise list of your key features
- Use a tone that aligns with your brand, and speaks in the language of your audience.

### 8. Ratings
**Users can leave ratings on your app; use that to your advantage.**

- From within your app, encourage your users to leave positive ratings on the Linea Hub. Higher ratings from others will improve your app’s discoverability across the Hub, and increase users' trust in your app.

### 9. Category
**Where would users look to find your app?**

- Select the most relevant category for your app to ensure it is discoverable to the right audience. 
- Consider multiple flows; users may be simply browsing, or filtering by interest.

### 10. Smart contracts
**Register your smart contract entry points on Lineascan.** 

- This helps improve your app’s discoverability across the Hub, and increase user safety
- We require all contracts to be verified on Lineascan.
  - If your are using a proxy pattern, include both proxy and implementation addresses; this allows us and power users to review the source code and identify issues eary. 
- Include **all deployed contracts users interact with, *directly or indirectly*.**

### 11. Final checks
**Are you camera-ready?**

- Make sure all URLs work (website, app, docs, socials, etc.)
- Link to your GitHub, if public
- Triple-check spelling, formatting, and clarity

## Checklist: Create a great event page on the Linea Hub

Your event page helps drive excitement and participation by showcasing engaging, time-limited experiences in your app. **Events are displayed directly on your app page, increasing visibility and conversion** by giving users a reason to engage with your app while the event is live.

If you include all the following elements for your event, you're setting yourself up for success:

### 1. Name
**Choose a clear, unique name under 30 characters that captures the essence of your event.**

- Use title case for consistency across events

### 2. Tagline
**Add a short tagline that communicates what makes your event unique and worth joining**.

### 3. Banner
**Use a high-quality image that is visually distinct from your app banner to avoid confusion and signal that this is a specific event**

- Avoid adding text: your event's name and tagline already appear above it.
- As with your app banner, **avoid light background colors**, and keep important visual elements in the top right section to avoid cropping.

### 4. Event button
**Ensure your event’s view button takes users directly into the event within your app**

- This minimizes friction and gets them to the experience quickly.
- Avoid directing users to another event page in your app that repeats the same thing.

### 5. Overview
**Craft a clear, engaging paragraph outlining what users will experience, followed by a short list of key activities, challenges, or rewards that will excite your audience.**

### 6. Availability
**Clearly specify your event’s start and end dates, and promote it up to 14 days in advance to maximize interest and visibility.**

### 7. Category
** Choose the appropriate event category to help users quickly understand the nature of your event**.

### 8. Performance tracking
**Use analytics in your Developer Hub to monitor impressions, views, and user engagement with your event.**

- Analyze these insights to refine and improve your future event strategies.

### 10. Promotion
**Promote your event on your social media channels and within your app.**

- Always link directly to your Linea Hub event page; this helps users trust the event:
  - It shows the event is **officially listed and verified within the Linea ecosystem**, which signals it’s real and safe.


## Submission

Access the [submission form](https://2urwb.share.hsforms.com/2M7Q9cFIWQxyZgLdocN3Smg?submissionGuid=07ed5477-53c1-498a-a5e7-41b12999d66c) 
to submit your app. 


## What happens next

Once you submit the form:

1. We review your listing
   - We check if your app meets the base requirements
   - If anything's missing, we'll reach out to the email you have entered with suggested fixes
2. You'll receive a confirmation email
   - If approved, your app will go live on the Hub
3. As your app gains traffic, you may unlock extra perks like:
   - "Linea Verified" badge
   - Featured listing
   - Promotion in newsletters or social posts
   - Access to special campaigns and reward programs

Learn more about how [reviews work on Linea Hub](./hub-reviews).


==================== FILE: /workspace/docs/get-started/build/quickstart/hub-reviews.mdx ====================

---
title: Understanding reviews on Linea Hub
sidebar_position: 4
description: A guide to how reviews work on the Linea Hub
image: /img/socialCards/understanding-reviews-on-linea-hub.jpg
---

We review every **app, token, and event** submitted to the Linea Hub to ensure they are safe, high quality, and ready to deliver value to users while protecting the ecosystem.

## Why we review

Reviews protect users and ensure that apps, tokens, and events on the Hub meet security, usability, and quality standards. This helps users trust the projects they discover on the Hub, which ultimately brings in more users to your app.

## What we check

- That all smart contracts your users interact with are publicly verified on Lineascan and meet security and technical standards
- The app functions as described, without crashes or critical bugs
- Design meets quality standards
- Screenshots and descriptions accurately reflect the app experience
{/* - Privacy policies exist and are publicly shared with users (No needed for now) */}

## How long it takes

Most reviews are completed within 48 hours if submissions are complete. You will receive updates by email.

## What you need to submit

- A **tested, working app or event** without placeholder content and/or a token **deployed on Linea Mainnet**
- Verification, on Lineascan, of **all smart contract addresses your users will interact with through your app or token**
- **Accurate** descriptions and visuals
- Link to demo environment with credentials allowing for full app functionality testing
- **The best way to contact you** to share feedback on your submission (don't forget your specific email address, handle + platform, etc!)
- A **publicly accessible link to your privacy policy** explaining data collection and use

## What happens if changes are needed

If we do not approve your submission, we will share feedback through your preferred contact methods so you can adjust and resubmit quickly.

## After approval

Once approved, your app, token, or event will go live on [the Hub](https://linea.build/hub), and you can track performance and user engagement in your Developer Hub.


==================== FILE: /workspace/docs/get-started/build/quickstart/app.mdx ====================

---
title: Build your app
description: Build and deploy a frontend app to interact with your contract
sidebar_position: 2
pagination_next: null
pagination_prev: get-started/build/quickstart/deploy
image: /img/socialCards/build-your-app.jpg
---

Now that you've deployed and verified your smart contract in [part one](./deploy.mdx), the next step 
is to create a frontend app that enables users to connect their wallet and interact with the 
smart contract.

In this guide, we will:
1. Set up a Next.js app 
2. Configure our app to connect to Linea Sepolia and your MetaMask wallet
3. Add buttons to the app to interact with your smart contract.

> _Estimated time to complete: ~25 minutes._

## Prerequisites

A wallet that can connect to Linea Sepolia. We recommend [MetaMask](https://metamask.io/).

[Get some Linea Sepolia ETH](../../how-to/get-testnet-eth.mdx).

## Set up a Next.js app using Dynamic

There are many frameworks out there for building web apps. We're going to focus on [Next.js](https://nextjs.org/),
a React framework.

Conveniently, [Dynamic](https://dynamic.xyz/) have created the `create-dynamic-app` which 
quickly creates a web3-enabled Next.js app which already has important packages like [Wagmi](../../tooling/libraries/wagmi.mdx) 
and [Viem](../../tooling/libraries/viem.mdx) (which Wagmi depends on) installed.

Run it like this:

```bash
npx create-dynamic-app@latest 
```

You'll also be prompted in the terminal to confirm a few project settings. Select Next.js as the 
framework, then make sure to enable Viem and Wagmi—libraries that we'll be using later.

Once you confirm the configuration, the `create-dynamic-app` package will install the necessary 
dependencies and your project will be ready to access in the new directory.

## Setup

The app needs a few adjustments before it will run.

Head to your `package.json` and adjust `react` and `react-dom` to `^18.0.0`. 
`create-dynamic-app` automatically installs `react` and `react-dom` `^19.0.0`, which are 
incompatible with the Dynamic SDK:

```json
  "dependencies": {
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    // other dependencies
  }
```

And also adjust the `devDependencies`: 

```json
  "devDependencies": {
    "@types/react": "^18",
    "@types/react-dom": "^18",
    // other dependencies
  }
```

Afterwards, run `npm install` to install the dependencies.

You can now run `npm run dev` to start the app locally. You can already connect your wallet, but 
you'll be unable to connect on Linea or Linea Sepolia until we configure our Dynamic dashboard, 
which we'll cover in the next step.

### Add a "Connect wallet" button

The first step to making the app usable is enabling visitors to connect their wallet. To do so,
we're going to use Dynamic's `DynamicWidget` component. Although we're just going to use the 
conventional "Connect wallet" usage—connecting an externally owned account (EOA)—the component has 
the advantage of allowing you to enable other sign-in methods and embedded wallet features with a few
minor changes on the Dynamic dashboard. This isn't something we're going cover here, but it's 
worth considering for your own app. 

To set up the widget, you'll need to sign up for a free [Dynamic](https://dynamic.xyz/get-started) 
account, which enables you to access your own Dynamic dashboard. You can sign in with your wallet, 
so you don't have to worry about handing over personal information.

#### Get your environment ID

Now you've signed up and have access to your Dynamic dashboard, we can access an environment ID,
and then use the dashboard to configure the `DynamicWidget`.

On the dashboard, copy your `environmentId` from Developers > SDK & API Keys. 

Back in your project directory, head to `lib/providers` and find the `DynamicContextProvider` 
component. Insert your `environmentId` into the `settings`:

```tsx
  return (
    <DynamicContextProvider
      theme="auto"
      settings={{
        environmentId: "YOUR_ENVIRONMENT_ID", // Add your environment ID here
           walletConnectors: [EthereumWalletConnectors],
      }}
    >
  )
```

#### Enable Linea wallet connectors

Connecting your local app to the dashboard means you can now configure the behaviour of the 
`DynamicWidget` component that is used in `app/page.tsx`.

On the dashboard, go to Chains & Networks in the sidebar. In the code snippet above, you can see 
that the `EthereumWalletConnectors` are already enabled; this means you should see the EVM button on
this dashboard page. Click it, then scroll and enable Linea and Linea Sepolia:

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/build/quickstart/app/enable_linea_networks.png"
      alt="Toggles for the Linea and Linea Sepolia networks"
    />
  </div>
</div>

If you now run `npm run dev`, you'll be able to connect your wallet on Linea and Linea Sepolia. 
We now have the barebones of a web3 app: a frontend web app to which you can connect your wallet.

## Interact with your contract

Given the functionality of the contract we deployed in [part one](./deploy.mdx), we'll need a 
button to interact with the contract, prompting a transaction that will call our smart contract's 
`increment()` function and increment the counter. It'll also be helpful to display the current 
counter value in the app. 

To implement these features, we'll be using Wagmi hooks:
- [`useReadContract`](https://wagmi.sh/react/api/hooks/useReadContract) to read the current counter 
value, and;
- [`useWriteContract`](https://wagmi.sh/react/api/hooks/useWriteContract) to call the smart 
contract's `increment()` function, and increase the counter.

### Display the counter value 

To display the counter value, we'll use the Wagmi `useReadContract` hook to retrieve the value
from the contract and display it in the app.

#### Configure Wagmi

To enable Wagmi to interact with Linea Sepolia, head to `lib/wagmi.ts` to find the Wagmi 
configuration file. Here, we need to replace `mainnet` with `lineaSepolia` and `linea` in a few 
places:
1. The import statement
2. The `chains` settings
3. The `transports` settings

Your Wagmi configuration should look like this:

```ts
// lib/wagmi.ts
import { http, createConfig } from "wagmi";
import { lineaSepolia, linea } from "wagmi/chains"; // Add this

export const config = createConfig({
  chains: [lineaSepolia, linea], // Add this
  multiInjectedProviderDiscovery: false,
  ssr: true,
  transports: {
    [lineaSepolia.id]: http(), // Add this
    [linea.id]: http(), // and this
  },
});

declare module "wagmi" {
  interface Register {
    config: typeof config;
  }
}
```

With these changes, Wagmi hooks will now be able to interact with Linea Sepolia.

#### Get the ABI

Next, we'll need the smart contract's application binary interface (ABI)—a kind of standardized data 
structure that defines the inputs and outputs necessary for other programs to interact with the smart 
contract. This is a necessary step to ensure the Wagmi hooks work.

You can find it by pasting the smart contract address into the [Linea Sepolia block explorer](https://sepolia.lineascan.build/).
Find the "Contract" tab and scroll down to "Contract ABI". Copy the code:

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/build/quickstart/app/abi.png"
      alt="The ABI of the smart contract"
    />
  </div>
</div>

Head back to your project repo and paste the code into a new file in your `lib` directory called 
`abi.ts`, adjusting the formatting:

```tsx
// lib/abi.ts
export const abi = [
    {
        "inputs":[],
        "name":"increment",
        "outputs":[],
        "stateMutability":"nonpayable",
        "type":"function"
    },
    {
        "inputs":[],
        "name":"number",
        "outputs":[{"internalType":"uint256","name":"","type":"uint256"}],
        "stateMutability":"view",
        "type":"function"
    },
    {
        "inputs":[{"internalType":"uint256","name":"newNumber","type":"uint256"}],
        "name":"setNumber",
        "outputs":[],
        "stateMutability":"nonpayable",
        "type":"function"
    }
]
```

#### Create counter component

Fetching the counter value from the smart contract and displaying it in the app requires more code 
than we could neatly place in `page.tsx`. Instead, we'll create a React component in 
`app/components` and import it into `page.tsx`.

Head to `app/components` in your project and create a new file, `Counter.js`, and add the below
code:

```js
// app/components/Counter.js
import { useReadContract } from "wagmi";
import { abi } from "@/lib/abi";

export default function Counter() {
  const { 
    data: counterValue, 
    error,
    isPending,
    refetch 
  } = useReadContract({
    address: "YOUR_CONTRACT_ADDRESS", // Add your deployed smart contract address here
    abi: abi,
    functionName: "number",
  });

  const statusText = isPending 
    ? "Loading..." 
    : error 
      ? "Error: " + error.shortMessage 
      : `Counter: ${counterValue?.toString() ?? "?"}`;

  return (
    <button 
      className="docs-button" 
      onClick={() => refetch()}
    >
      {statusText} • Click to refresh
    </button>
  );
}
```

:::note

Make sure to insert the address of your deployed smart contract.

:::

The component imports the `useReadContract` hook and the ABI you added previously. It then calls our
contract's `number()` function using `useReadContract` and displays the result in a button in the
app. We've also added some logic that displays "Loading..." while the data is being fetched, an 
error handling message that displays errors that are built into `useReadContract`, and the ability
to click the button to refresh the data.

#### Add counter component your app

Go back to your `page.tsx` and, alongside the existing import statements, add a statement to import 
the component you just created:

```tsx
import Counter from './components/Counter.js';
```

Now we can insert the component into the page:

```tsx
<div className="modal">
  <DynamicWidget />
  <Counter />
</div>
```

:::note

The Dynamic template app comes with a `<DynamicMethods />` component. We've removed it so we can
focus on the counter functionality, but you can leave it if you prefer.

:::

You can test the component works by heading to Lineascan and calling the `increment()` function on 
the Contract > Write Contract page. Click the "Connect to Web3" button to connect your wallet, and
then "Write" to prompt a transaction from your wallet that will increment the counter. If you head
back to your app and retrieve new data, you'll see that the counter has been incremented by 1.

Here's how it looks:

<div class="center-container">
  <div class="img-small">
    <img
      src="/img/get_started/build/quickstart/app/counter.png"
      alt="The counter component"
    />
  </div>
</div>

### Add a button to increment the counter

Our method for calling the `increment()` function in our smart contract is to use the Wagmi hook 
`useWriteContract`. Instead of reading data this time, we're asking the smart contract to do some
computation—incrementing the counter—which means we need to send a transaction with gas to pay for
the computation.

Since we've already configured `wagmi.ts` file and created `abi.ts`, we can move straight to adding
the component.

### Create increment component

Head to `app/components` and add a new file called `Increment.js`. Paste in this code, making sure
to replace `YOUR_CONTRACT_ADDRESS` with the address of your deployed smart contract:

```js
import { useWriteContract } from "wagmi";
import { abi } from "@/lib/abi";

export default function Increment() {
  const { writeContract, isPending } = useWriteContract();

  const handleIncrement = () => {
    writeContract({
      address: "YOUR_CONTRACT_ADDRESS", // Add your deployed smart contract address here
      abi: abi,
      functionName: "increment",
    });
  };

  return (
    <button 
      className="docs-button" 
      onClick={handleIncrement}
      disabled={isPending}
    >
      {isPending ? "Incrementing..." : "Increment Counter"}
    </button>
  );
}
```

### Add the increment component to your app

Go back to your `page.tsx` and, alongside the existing import statements, add a statement to import 
the component you just created:

```tsx
import Increment from './components/Increment.js';
```

Now we can insert the component into the page:  

```tsx
<div className="modal">
  <DynamicWidget />
  <Counter />
  <Increment />
</div>
```

## Test your app

Now that everything is in place, we can test the app. 

Run `npm run dev` to run your app locally. 

The counter button should display the counter value already, and you can click to fetch the latest 
value at any time without sending a transaction. With your wallet connected and some Linea Sepolia
ETH, you should be able to click the "Increment Counter" button to add +1 to the counter value:

<div class="center-container">
  <div class="img-small">
    <img
      src="/img/get_started/build/quickstart/app/increment_button.png"
      alt="The increment button"
    />
  </div>
</div>

There you have it! A functioning web3-enabled app that interacts with a smart contract. 

## Deploy your app

Now that you have a working app, you can deploy it to make it publicly accessible. As we've been 
using Next.js, a framework developed by Vercel, we can easily use Vercel to deploy our app for free.

Since we're working on Linea Sepolia, we don't have the usual security concerns we'd need for a 
production app, so we can go straight ahead. 

### Add your repository to GitHub

The `create-dynamic-app` package we used at the start of this guide automatically created a git
repository for your project. This means your changes have been tracked. 

Firstly, run `npm run build` to build the app. This should surface any errors in your code that 
may prevent it from being deployed. If you need help resolving any, head to the #developer-chat
channel in our [Discord server](https://discord.gg/linea).

When you're ready, make sure you've staged your changes with `git add .` and then committed them:

```bash
git commit -m "Initial commit"
```

Now you're ready to publish your repository to GitHub. The easiest method is to [download and use
GitHub Desktop](https://docs.github.com/en/desktop/adding-and-cloning-repositories/adding-a-repository-from-your-local-computer-to-github-desktop),
though if you're comfortable with git, you might prefer [using the command line](https://docs.github.com/en/migrations/importing-source-code/using-the-command-line-to-import-source-code/adding-locally-hosted-code-to-github#importing-a-git-repository-with-the-command-line).

You can set your repository to public or private depending on your preference. You'll be able to 
deploy it either way.

### Deploy using Vercel

Now that your repository is on GitHub, you can deploy it using Vercel. [See the Vercel guide for
instructions](https://nextjs.org/learn-pages-router/basics/deploying-nextjs-app/deploy).

You'll need to create a Vercel account and link it to your GitHub account. Once you've done that,
you can deploy, and manage your app from Vercel.

## Next steps

Now that you have a grasp of the basics, you can start to experiment and build innovative apps that 
solve real-world problems and attract users. Here are some ideas for taking your app to the next 
level:

- Build in [account abstraction](../../tooling/account-abstraction/index.mdx) features to make your
app more accessible and user-friendly. The Dynamic widget that we used in this guide already 
enables you to use some of these features, configurable via the Dynamic dashboard.
- Accelerate development by using audited, reliable [contract templates](../../tooling/contracts-templates/index.mdx).
- Leverage an [oracle](../../tooling/oracles/index.mdx) to fetch data, such as token prices, and
display it in your app.

## Help and resources

If you get stuck at any point in this guide, head to our [Discord](https://discord.gg/linea) and 
visit the `#developer-chat` channel.

- [Dynamic documentation](https://docs.dynamic.xyz/introduction/welcome)
- [Wagmi documentation](https://wagmi.sh/)
  - [`useReadContract`](https://wagmi.sh/react/api/hooks/useReadContract)
  - [`useWriteContract`](https://wagmi.sh/react/api/hooks/useWriteContract)
- [Linea Sepolia block explorer](https://sepolia.lineascan.build/)


==================== FILE: /workspace/docs/get-started/build/quickstart/deploy.mdx ====================

---
title: Deploy your contract
description: Create a new project and deploy and verify your contracts using Foundry
sidebar_position: 1
pagination_next: get-started/build/quickstart/app
pagination_prev: null
image: /img/socialCards/deploy-your-contract.jpg
---

Building apps on Linea needn't be complicated. Linea is Ethereum Virtual Machine (EVM)-equivalent,
providing a development experience identical to Ethereum, and allowing you to leverage the many 
smart contracts, tools, and libraries created for EVM chains. 

In this guide, we'll walk you through using [Foundry](https://book.getfoundry.sh/) to create a new 
project from scratch. 

This involves:
1. [Creating a project](#create-your-project)
2. [Deploying](#deploy-your-contract) and then [verifying](#verify-your-contract) your contract.

> _Estimated time to complete: ~20 minutes._

:::note Hardhat

If you'd prefer to deploy your contract using Hardhat rather than Foundry, see our [guide](../../how-to/deploy-smart-contract/hardhat.mdx).

:::

## Prerequisites

A Linea-compatible wallet with some Linea Sepolia ETH. We recommend using [MetaMask](https://metamask.io/).

[Get some Linea Sepolia ETH](../../how-to/get-testnet-eth.mdx).

## Create your project

To get started, we're going to use Foundry's `forge init` command to create a new project. [`forge`](https://book.getfoundry.sh/forge/)
is the Foundry CLI tool.

Firstly, let's [install Foundry](https://book.getfoundry.sh/getting-started/installation):

```bash
curl -L https://foundry.paradigm.xyz | bash
```

Then initiate the new project, choosing whatever name you prefer. Make sure you're in the 
directory you want to create your project in:

```bash
forge init linea_test_project
```

Foundry will build out the file structure and create a git repository. It also installs one 
dependency: `forge-std`, the Forge Standard Library, which enables you to test your project.
To get more familiar with your new project, it might help to open it in a code editor and inspect
the files.

You can also run `forge build` to compile your project, and then `forge test` to use the `forge-std`
testing library.

:::note

If you already have a project set up, clone the project and run `forge install` in the directory to
use Foundry.

:::

## Deploy your contract

The default Foundry template comes with a simple placeholder contract, `Counter.sol`. You're likely 
going to need something with a bit more functionality. You probably already have an idea of what 
you want your app to do, and you might have the skills to write your own contract from scratch. 

For simplicity, we're going to stick with `Counter.sol`, but you can use any template you want, or 
refer to our [contract templates section](../../tooling/contracts-templates/index.mdx) for more inspiration. 

We'll use the `forge create` command to deploy the contract. First, we must get an RPC endpoint and
ensure we have a secure method for using a private key.

### RPC endpoints

#### Get your RPC endpoint

To deploy a contract, you need to interact with the blockchain, which means you need an [RPC  endpoint](../../tooling/node-providers/index.mdx) 
to send those calls to. 

To keep things simple, we're going to use the default public RPC endpoint for Linea Sepolia: 
`https://rpc.sepolia.linea.build`.

Public endpoints such as this one are rate limited, and if you intend to deploy your app for public
use, you'll need an endpoint better equipped to handle the load. We recommend heading to the 
MetaMask Developer Dashboard to get a private RPC endpoint ([instructions](https://docs.metamask.io/developer-tools/dashboard/get-started/create-api/)).

You can also find alternative public and private RPC endpoints on our [node providers page](../../tooling/node-providers/index.mdx).

#### Update `foundry.toml`

Add the RPC endpoint to the `foundry.toml` file:

```toml
[profile.rpc-endpoints]
sepolia = "https://rpc.sepolia.linea.build"
```

### Store your private key

Deploying a contract requires an account's private key, which means you need to either provide it in
the command line when running the deployment command (not recommended) or store it securely and 
access it with alternative methods. See the [MetaMask support guide to finding your private key](https://support.metamask.io/managing-my-wallet/secret-recovery-phrase-and-private-keys/how-to-export-an-accounts-private-key/).

:::tip[Private key security best practices]

We recommend [creating a new account in MetaMask](https://support.metamask.io/managing-my-wallet/accounts-and-addresses/how-to-add-accounts-in-your-wallet/)
specifically for this project, and [naming it](https://support.metamask.io/managing-my-wallet/accounts-and-addresses/how-do-i-change-my-account-name-/)
something appropriate, such as "linea-project".

Even though we're working on a testnet, it's best to behave as if real assets were at stake, and
work in a sandboxed context with a somewhat expendable account.

:::

A standard approach is to store your private key as an environment variable in a `.env` file that 
is only stored locally (i.e. listed in `.gitignore` file). However, we're going to use Foundry's
keystore system to encrypt and store the private key, and then access it with a password. This 
ensures that you won't accidentally expose your private key—for example, in a GitHub repository.

To do this, we'll use Foundry's [`cast`](https://book.getfoundry.sh/cast/) CLI tool; specifically,
the [`cast wallet import`](https://book.getfoundry.sh/reference/cast/cast-wallet-import) command.

```bash
cast wallet import --interactive test-account
```

The `--interactive` flag means that you'll be prompted to enter your private key in the terminal,
followed by a corresponding password. `test-account` is the name you want to give the account in 
the keystore; choose whatever is suitable for your purposes here.

When you enter the private key and then your password, you'll get confirmation that it has been 
stored successfully:

```
`test-account` keystore was saved successfully. Address: <YOUR_PUBLIC_ADDRESS>
```

Run `cast wallet list` to see accounts in your keystore.

### Deploy

#### Adjust Solidity version

By default, the `forge init` command we used originally creates the `Counter.sol` contract with the 
following Solidity compiler version:

```
pragma solidity ^0.8.13;
```

This enables the compiler to use any version newer than Solidity v0.8.13. [Linea is only compatible 
with Solidity 0.8.19 or lower](../../build/ethereum-differences.mdx), so we need to make some 
adjustments.

Add this line to `[profile.default]` in your `foundry.toml` file:

```toml
solc-version = 0.8.19
```

So that your `[profile.default]`, which is applied universally, now looks like this:

```toml
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
solc-version = "0.8.19"
```

#### Run `forge create`

With your RPC endpoint to hand and your private key stored more securely, you're ready to deploy 
using `forge create`.

Execute this command, then enter your password to use the private key when prompted:

```bash
forge create --rpc-url https://rpc.sepolia.linea.build --account test-account --broadcast src/Counter.sol:Counter
```

- `--rpc-url` is the RPC endpoint you want to use.
- `--account` is the keystore account you want to use to deploy the contract.
- `--broadcast` tells Forge to send the transaction to the network. You can test the command by 
omitting this flag, but you won't actually deploy the contract.

The format of the contract you want to deploy is `path/to/contract.sol:ContractName`; in this case,
we want the `Counter` contract from `src/Counter.sol`. 

If successful, you'll see this in the terminal:

```
Deployer: 0x ... // The address of the account used to deploy the contract
Deployed to: 0x ... // The address of the deployed contract
Transaction hash: 0x ... // The deployment transaction itself
```

You can copy each of these addresses and head to the [block explorer](https://sepolia.lineascan.build/) 
to see the deployed contract.

Make sure to copy the `Deployed to` address, as you'll need it to verify the contract. It'll also
be useful in part two of this quickstart, where we'll need it to interact with the contract in our
app.

## Verify your contract

Verifying a contract makes the source code publicly visible, and also confirms to others that it 
originated from a genuine source.

Verifying can be done with the `forge verify-contract` command, and requires a Lineascan API key.

### Get a Lineascan API key

Get a Lineascan API key by [creating an account](https://lineascan.build/myapikey).

Since it's best practice to avoid using API keys in the command line, add the API key to your 
`.env` file:

```
LINEASCAN_API_KEY=YOUR_LINEASCAN_API_KEY
```

Then modify the `foundry.toml` configuration file to include the Lineascan API key, pulling it from
the `.env` file:

```toml
[etherscan]
linea-sepolia = { key = "${LINEASCAN_API_KEY}" }
```

#### Run `forge verify-contract`

Execute this command: 

```bash
forge verify-contract --chain linea-sepolia YOUR_CONTRACT_ADDRESS path_to_contract:contract_name --watch
```

`--watch` automatically runs the `forge verify-check` command to report verification status in the
terminal until verification is complete.

:::note

You can also complete verification at the same time as deployment by adding the `--verify` and
`--verifier-url` flags to the `forge create` command, and providing your Lineascan API key. 

For example:

```bash
forge create --rpc-url https://rpc.sepolia.linea.build --account test-account --broadcast --verify --verifier-url https://api-sepolia.lineascan.build/api --etherscan-api-key LINEASCAN_API_KEY src/Counter.sol:Counter
```

:::

Now you've successfully deployed and verified your contract! It's recorded on the blockchain and
ready to receive calls from your app. 

## Next steps 

Proceed to [part two](./app.mdx) of this quickstart, where we'll build a simple web app for 
interacting with the counter contract.

## Help and resources

If you get stuck at any point in this guide, head to our [Discord](https://discord.gg/linea) and 
visit the `#developer-chat` channel.

- [Foundry documentation](https://book.getfoundry.sh/)
  - [Foundry CLI](https://book.getfoundry.sh/forge/)
  - [Foundry Cast](https://book.getfoundry.sh/cast/)
- [Linea Sepolia block explorer](https://sepolia.lineascan.build/)
- [Node providers](../../tooling/node-providers/index.mdx)


==================== FILE: /workspace/docs/get-started/build/contracts.mdx ====================

---
title: Contracts
description: Important contracts on Linea Mainnet and Linea Sepolia.
image: /img/socialCards/contracts.jpg
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

## Deployed contracts

<Tabs groupId="Mainnet-Testnet" className="my-tabs">
  <TabItem value="Mainnet" label="Mainnet" default>
    <table>
      <tr>
        <th>Contract</th>
        <th>Address</th>
      </tr>
      <tr>
        <td>Linea Rollup and L1 Message Service</td>
        <td>
          <a href="https://etherscan.io/address/0xd19d4B5d358258f05D7B411E21A1460D11B0876F">
            0xd19d4B5d358258f05D7B411E21A1460D11B0876F
          </a>
        </td>
      </tr>
      <tr>
        <td>L2 Message Service</td>
        <td>
          <a href="https://lineascan.build/address/0x508Ca82Df566dCD1B0DE8296e70a96332cD644ec">
            0x508Ca82Df566dCD1B0DE8296e70a96332cD644ec
          </a>
        </td>
      </tr>
      <tr>
        <td>L1 Token bridge</td>
        <td>
          <a href="https://etherscan.io/address/0x051F1D88f0aF5763fB888eC4378b4D8B29ea3319">
            0x051F1D88f0aF5763fB888eC4378b4D8B29ea3319
          </a>
        </td>
      </tr>
      <tr>
        <td>L2 Token bridge</td>
        <td>
          <a href="https://lineascan.build/address/0x353012dc4a9A6cF55c941bADC267f82004A8ceB9">
            0x353012dc4a9A6cF55c941bADC267f82004A8ceB9
          </a>
        </td>
      </tr>
      <tr>
        <td>L1 Security Council safe</td>
        <td>
          <a href="https://etherscan.io/address/0x892bb7EeD71efB060ab90140e7825d8127991DD3">
            0x892bb7EeD71efB060ab90140e7825d8127991DD3
          </a>
        </td>
      </tr>
      <tr>
        <td>L2 Security Council safe</td>
        <td>
          <a href="https://lineascan.build/address/0xf5cc7604a5ef3565b4D2050D65729A06B68AA0bD">
            0xf5cc7604a5ef3565b4D2050D65729A06B68AA0bD
          </a>
        </td>
      </tr>
    </table>
  </TabItem>
    <TabItem value="Linea Sepolia" label="Linea Sepolia">
    <table>
      <tr>
        <th>Contract</th>
        <th>Address</th>
      </tr>
      <tr>
        <td>L1 Message Service</td>
        <td>
          <a href="https://sepolia.etherscan.io/address/0xB218f8A4Bc926cF1cA7b3423c154a0D627Bdb7E5">
          0xB218f8A4Bc926cF1cA7b3423c154a0D627Bdb7E5
          </a>
        </td>
      </tr>
      <tr>
        <td>L2 Message Service</td>
        <td>
          <a href="https://sepolia.lineascan.build/address/0x971e727e956690b9957be6d51ec16e73acac83a7">
          0x971e727e956690b9957be6d51Ec16E73AcAC83A7
          </a>
        </td>
      </tr>
      <tr>
        <td>L1 Token bridge</td>
        <td>
          <a href="https://sepolia.etherscan.io/address/0x5A0a48389BB0f12E5e017116c1105da97E129142">
            0x5A0a48389BB0f12E5e017116c1105da97E129142
          </a>
        </td>
      </tr>
      <tr>
        <td>L2 Token bridge</td>
        <td>
          <a href="https://sepolia.lineascan.build/address/0x93DcAdf238932e6e6a85852caC89cBd71798F463">
            0x93DcAdf238932e6e6a85852caC89cBd71798F463
          </a>
        </td>
      </tr>
    </table>
  </TabItem>
</Tabs>

## Token contract addresses and bridges

### LINEA token

The LINEA token address is [`0x1789e0043623282D5DCc7F213d703C6D8BAfBB04`](https://lineascan.build/address/0x1789e0043623282D5DCc7F213d703C6D8BAfBB04).

The address is the same on Linea Mainnet and Ethereum Mainnet.

### Other tokens

<Tabs groupId="Mainnet-Testnet" className="my-tabs">
  <TabItem value="Mainnet" label="Mainnet" default>

To see **the most up-to-date list of tokens on Linea**, see
[the token explorer here](https://consensys.github.io/linea-token-list/), which is derived from the
official lists in [this repo](https://github.com/Consensys/linea-token-list/blob/main/json/linea-mainnet-token-shortlist.json). 

To **get your own token included**, please follow the instructions on this [repository](https://github.com/Consensys/linea-token-list).

To see **which third-party bridges are available**, consult our [Ecosystem Portal's list](https://linea.build/hub/apps/category/bridge).

If you're **looking to bridge tokens to or from Linea**, head to the [Linea bridge page](https://linea.build/hub/bridge/)
to access the various options.

  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
    Sepolia token contract addresses are available in the [official token list repository](https://github.com/Consensys/linea-token-list/blob/main/json/linea-sepolia-token-shortlist.json).
  </TabItem>
</Tabs>

## Important contracts

For both mainnet and testnet:

<table>
  <tr>
    <th>Contracts</th>
  </tr>
  <tr>
    <td>
      <a href="/files/testnet/IBridge.sol">IBridge.sol</a>
    </td>
  </tr>
  <tr>
    <td>
      <a href="/files/testnet/IL1Bridge.sol">IL1Bridge.sol</a>
    </td>
  </tr>
  <tr>
    <td>
      <a href="/files/testnet/IMessageService.sol">IMessageService.sol</a>
    </td>
  </tr>
  <tr>
    <td>
      <a href="/files/testnet/MessageServiceBase.sol">MessageServiceBase.sol</a>
    </td>
  </tr>
  <tr>
    <td>
      <a href="/files/testnet/ITokenBridge.sol">ITokenBridge.sol</a>
    </td>
  </tr>
</table>

## Audits

You can view a complete list of Linea audits in the [Linea monorepo](https://github.com/Consensys/linea-monorepo/blob/2a8288f75a347104442f015b71262ab06a1e62f0/docs/audits.md).


==================== FILE: /workspace/docs/get-started/build/ethereum-differences.mdx ====================

---
title: Differences between Ethereum and Linea
description: Learn about the key differences between Ethereum and Linea.
image: /img/socialCards/differences-between-ethereum-and-linea.jpg
---

This page outlines Ethereum Mainnet functionality that differs on Linea, or is not yet available on 
Linea. Absence from this page indicates that the functionality is available on Linea and identical to 
behavior on Ethereum Mainnet; if you're experiencing otherwise, please get in touch via Discord.

## EVM opcodes

:::info important 

Linea uses the London version of the Ethereum Virtual Machine (EVM). All EVM opcodes are managed 
identically to Ethereum London unless presented in the following table.

Solidity 8.23 and later compiles newer versions of the EVM by default. Use the `solc --evm-version london` 
command to ensure compatibility with Linea. 

:::

Check out [Ethereum's history](https://ethereum.org/en/history/) to learn about
major milestones, forks, and updates to the blockchain.

<table>
  <tr>
    <th>Opcode</th>
    <th>Ethereum</th>
    <th>Linea: current state</th>
    <th>Linea: Pectra upgrade (Beta v4)</th>
  </tr>
  <tr>
    <td>`BLOBBASEFEE`</td>
    <td>Returns the value of the blob base-fee of the current block.</td>
    <td>Not supported.</td>
    <td>Will always return the minimum value.</td>
  </tr>
  <tr>
    <td>`BLOBHASH`</td>
    <td>
      Given an an input in the form of an `index`, indicating the position of a
      particular blob within an array of blobs associated with a transaction,
      returns the hash of the corresponding blob.
      <br /> <br /> If the index is out of bounds, returns `0`.
    </td>
    <td>Not supported.</td>
    <td>Will always return `0`.</td>
  </tr>
  <tr>
    <td>`BLOCKHASH`</td>
    <td>
      Returns the hash of a requested block from the 256 most recent blocks.
    </td>
    <td>Not supported.</td>
    <td>Returns the correct value, but the value is not guaranteed by the proof
      (Linea is a [type 2 zkEVM](https://vitalik.eth.limo/general/2022/08/04/zkevm.html), and
      uses/proves an L2-specific state representation).</td>
  </tr>
  <tr>
    <td>`MCOPY`</td>
    <td>
      Copies memory areas, allowing the destination and source to overlap.
    </td>
    <td>Not supported.</td>
    <td>Available on Linea Beta v4.</td>
  </tr>
  <tr>
    <td>`PREVRANDAO`</td>
    <td>Returns the RANDAO value from the previous block.</td>
    <td>Not supported.</td>
    <td>
      Use a formula similar to Ethereum, e.g. `L2_prevrandao XOR
      hash(signed(slot_id))`.
    </td>
  </tr>
  <tr>
    <td>`PUSH0`</td>
    <td>Pushes the constant value 0 onto the stack.</td>
    <td>Not supported.</td>
    <td>
      PUSH0 was introduced in the Ethereum Mainnet Shanghai upgrade and became
      available in Solidity compiler version 0.8.20, which came after the London
      release. Available on Linea Beta v4.
    </td>
  </tr>
  <tr>
    <td>`TLOAD`</td>
    <td>Load word from transient storage.</td>
    <td>Not supported.</td>
    <td>Available on Linea Beta v4.</td>
  </tr>
  <tr>
    <td>`TSTORE`</td>
    <td>Save word to transient storage.</td>
    <td>Not supported</td>
    <td>Available on Linea Beta v4.</td>
  </tr>
</table>

_Consult the Ethereum Foundation's [Opcode Reference](https://ethereum.org/en/developers/docs/evm/opcodes/) 
for more._

[Evmdiff](https://evmdiff.com) is also a useful resource for comparing Linea with Ethereum, and 
[evm.codes](https://evm.codes/) is useful for information about specific opcodes on Ethereum.

## Precompiles

<table>
  <tr>
    <th>Precompile</th>
    <th>Ethereum</th>
    <th>Linea: current state</th>
    <th>Linea: Pectra upgrade (Beta v4)</th>
  </tr>
  <tr>
    <td>`BLAKE2f`</td>
    <td>
      Compression function F used in the BLAKE2 cryptographic hashing algorithm.
    </td>
    <td>Not supported.</td>
    <td>Not supported.</td>
  </tr>
  <tr>
    <td>`MODEXP`</td>
    <td>Arbitrary-precision exponentiation under modulo.</td>
    <td>
      Only supports arguments (base, exponent, modulus) that do not exceed
      512-byte integers.
    </td>
    <td>Only supports arguments (base, exponent, modulus) that do not exceed
      512-byte integers.</td>
  </tr>
  <tr>
    <td>Point evaluation</td>
    <td>
      Verify that specific points in a polynomial (blobs) match the expected
      values.
    </td>
    <td>Not supported.</td>
    <td>Available with Linea Beta v4.</td>
  </tr>
  <tr>
    <td>Precompiles as transaction recipients</td>
    <td>Applicable to various use cases.</td>
    <td>
      Not supported. A transaction `to` address cannot be a precompile, i.e. an
      address in the range `0x01`-`0x09`.
    </td>
    <td>Not supported. A transaction `to` address cannot be a precompile, i.e. an
      address in the range `0x01`-`0x09`.</td>
  </tr>
  <tr>
    <td>`RIPEMD-160`</td>
    <td>A hash function.</td>
    <td>Not supported.</td>
    <td>TBD.</td>
  </tr>
</table>

## Beacon root

[EIP-4788](https://eips.ethereum.org/EIPS/eip-4788), included in Ethereum's Dencun upgrade, 
introduced a smart contract that enables the caller to `get` or `set` the hash tree root of a 
beacon chain block.

This functionality is available with Linea Beta v4. However, due to the difference in block time
when compared to Ethereum Mainnet, only the root of the previous block is available.

## Call data

Linea's sequencer limits the size of call data, so that transactions can fit into the corresponding 
blob. The current limit is 60000 bytes.

## JSON-RPC API

Linea uses the standard Ethereum JSON RPC API methods. However, in a few cases, methods differ from 
those on Ethereum. These methods are documented in the [reference section](../../api/reference/index.mdx), 
and include:

- `linea_estimateGas`
- `linea_getProof`
- `linea_getTransactionExclusionStatusV1`
- `eth_sendRawTransaction`


==================== FILE: /workspace/docs/get-started/connect.mdx ====================

---
title: Connect to Linea
description: Learn how to connect wallets to Linea.
image: /img/socialCards/connect-to-linea.jpg
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## MetaMask

### Infura

Linea is available by default in MetaMask through an Infura RPC endpoint. 

<Tabs className="my-tabs">
    <TabItem value="extension" label="MetaMask Extension">

        **Linea Mainnet**

        Find the network selector in the top-left of MetaMask, and click to see your available 
        networks. From here, select Linea Mainnet:

        <div class="center-container">
          <div class="img-small">
            <img
              src="/img/get_started/connect/MetaMask_change_network_to_Linea_extension.gif"
              alt="MetaMask change network to Linea extension"
            />
          </div>
        </div>

        If you don't see Linea Mainnet in the "Enabled networks" list, scroll to the "Additional
        networks" section, and click "Add". 

        **Linea Sepolia**

        In the networks menu, scroll until you see the "Show test networks" toggle. If it's off,
        switch it on; you should see Linea Sepolia in the list. Select it to get started.

        <div class="center-container">
          <div class="img-small">
            <img
              src="/img/get_started/connect/MetaMask_show_test_network_Linea_Sepolia_extension.png"
              alt="MetaMask change network to Linea Sepolia extension"
            />
          </div>
        </div>

    </TabItem>
    <TabItem value="mobile" label="MetaMask Mobile">
        **Linea Mainnet**

        Find the network selector at the top of the screen. Tap it to open the networks menu.

        Select "Linea Mainnet" to switch to it. If you don't see it in the list, scroll "Additional
        networks" list and tap "Add" to add Linea Mainnet to your wallet.

        <div class="center-container">
          <div class="img-small">
            <img
              src="/img/get_started/connect/MetaMask_change_network_to_Linea_mobile.gif"
              alt="MetaMask change network to Linea mobile"
            />
          </div>
        </div>

        **Linea Sepolia**

        Scroll until you see the "Show test networks" toggle. If it's off, switch it on; you should
        see Linea Sepolia in the list. Select it to get started.

        <div class="center-container">
          <div class="img-small">
            <img
              src="/img/get_started/connect/MetaMask_show_test_network_Linea_Sepolia_mobile.png"
              alt="MetaMask change network to Linea Sepolia mobile"
            />
          </div>
        </div>

    </TabItem>
</Tabs>

:::note

See the [MetaMask support article](https://support.metamask.io/networks-and-sidechains/managing-networks/how-to-connect-to-linea-on-metamask/) 
for further information.

:::

### Custom RPC endpoint

You can configure MetaMask to connect to Linea Mainnet or Linea Sepolia with any RPC endpoint. 

Refer to the [MetaMask Support site](https://support.metamask.io/networks-and-sidechains/managing-networks/how-to-add-a-custom-network-rpc/#adding-or-editing-rpc-urls) 
for instructions on how to add RPC endpoints.

## Other wallets

- [Coinbase Wallet](https://help.coinbase.com/en/wallet/layer2-networks/layer2-networks-and-sidechains)
- [Ledger](https://support.ledger.com/article/17822826153757-zd)
- [Trust Wallet](https://community.trustwallet.com/t/how-to-add-a-custom-network-on-the-trust-wallet-mobile-app/626781)
- [Rainbow](https://rainbow.me/support/extension/custom-networks-on-the-browser-extension)


==================== FILE: /workspace/docs/get-started/tooling/cross-chain/arcana.mdx ====================

---
title: Arcana
image: /img/socialCards/arcana.jpg
---

import ArcanaCAGraphic from "/img/get_started/tooling/cross_chain/arcana/chain_abstraction.png";
import ArcanaUBGraphic from "/img/get_started/tooling/cross_chain/arcana/unified_balance.png";

The [Arcana Network](https://arcana.network) [Chain Abstraction](https://docs.arcana.network/ca/introduction/ca/) (CA) SDK integrates with any web3 app and enables app users to beat liquidity fragmentation. Users can view a [unified balance](https://docs.arcana.network/concepts/ca/unified-balance/) associated with their EoA and spend it on any chain using any third-party wallet.

<div class="center-container">
  <div class="img-large">
      <img
        src="/img/get_started/tooling/cross_chain/arcana/chain_abstraction.png"
        alt="Chain Abstraction with Arcana SDK"
      />
  </div>
</div>

Unified balance allows users to spend the consolidated multi-chain balance of supported tokens (for example, ETH, USDC, USDT) within the app context on any [chain](https://docs.arcana.network/web3-stack/ca_stack#chains) including Linea. This allows web3 apps to onboard users from any ecosystem effortlessly.

<div class="center-container">
  <div class="img-large">
      <img
        src="/img/get_started/tooling/cross_chain/arcana/unified_balance.png"
        alt="Unified Balance"
      />
  </div>
</div>

## Linea integration

To enable chain abstraction on Linea, web3 apps must install and integrate with the [Arcana Chain Abstraction SDK](https://npmjs.com/package/@arcana/ca-sdk). See the [quick start guide](https://docs.arcana.network/quick-start/ca-quick-start/) and the CA [API](https://ca-sdk-ref-guide.netlify.app/) for details. Check out web3 app [integration examples](https://docs.arcana.network/ca/examples/). 

## CA SDK demonstration

Try the [CA SDK demo app](https://sdk.arcana.network/) to see how it works for Linea. Use any third-party browser-based wallet and connect to the app. 

## Use cases

Arcana's Chain Abstraction (CA) is designed to onboard users across a wide range of applications. It is particularly impactful for DeFi applications that depend on deposits in stablecoins like USDC or USDT and native tokens like ETH.

Key benefits of using Arcana's Chain Abstraction include:

- Removes friction of bridging with a unified multi-chain balance
- Allows larger transaction values 
- Helps launch apps on emerging chains while onboarding users from established ecosystems.

### Swaps

Allow users to execute token swaps on a single chain DEX while using funds held across multiple chains as a unified balance. For example, a user holding USDC on Ethereum and an L2 can seamlessly swap tokens on Linea without needing to bridge or consolidate assets manually. This removes friction for users, ensuring smoother transactions and higher conversion rates for swap protocols.

### Bridges

Bridges enable users to move funds from Chain A to Chain B, but when users hold assets across multiple chains, they face the challenge of tracking and transferring funds chain by chain. With Arcana's CA, users can bridge their entire multi-chain balance to the desired chain in one step.

For example, let us consider a case where a user holds USDC on Ethereum, Polygon, and Optimism and wants to consolidate their funds on Linea. Instead of manually bridging USDC from each chain one at a time, users can bridge their total USDC balance from all three chains to Linea in a single step.

### Decentralized exchanges (DEXs)

For liquidity providers and traders, fragmented funds across chains often hinder participation in DEXs. With Arcana's CA, users can trade or provide liquidity on a single-chain DEX using their unified balance from multiple chains. This enables more efficient capital utilization, increases trading volumes, and expands access to liquidity for DEX platforms.

### Perpetuals trading

Arcana's CA allows users to trade on a perpetual protocol on one chain using a unified balance of funds held on other chains. This is particularly useful for protocols that need users to deposit stable coins to a particular address on a specific chain. Arcana's CA removes the need for manual bridging and ensures traders can respond quickly to market changes without delays in fund transfers.

### Prediction markets

Prediction markets often have strong user bases tied to specific chains. Arcana's CA allows users to stake or wager assets on a prediction market hosted on a single chain using funds held across multiple chains, ensuring greater cross-chain participation and deeper liquidity for these markets.

### Lending

Borrowers and lenders often face challenges when their assets are distributed across chains and they want to access new yield products on specific chains. With Arcana's CA, a user can supply liquidity to a lending protocol on one chain, such as Ethereum, using their unified balance aggregated from other chains. This leads to larger deposit and borrow transactions with access to a larger pool of capital.

### Staking/restaking

Restaking requires users to bring assets or derivatives to specific chains. Arcana CA enables users to stake or restake assets on a protocol running on a single chain by leveraging their unified balance across multiple chains. For instance, a user with ETH on Ethereum and Linea can stake and restake seamlessly on another chain without manual transfers.

This allows users from multiple EVM ecosystems to participate in the protocol.

## Resources

- [Get Started with Arcana CA SDK](https://docs.arcana.network/quick-start/ca-quick-start/)
- [SDK Demo](https://sdk.arcana.network/)
- [Arcana CA Blogs](https://blog.arcana.network/)


==================== FILE: /workspace/docs/get-started/tooling/cross-chain/index.mdx ====================

---
title: Cross-chain tooling
image: /img/socialCards/cross-chain-tooling.jpg
---


import DocCardList from '@theme/DocCardList';

<DocCardList />


==================== FILE: /workspace/docs/get-started/tooling/cross-chain/shortcuts.mdx ====================

---
title: Onthis Shortcuts
description: No-code tool for executing multiple DeFi actions in one transaction
image: /img/socialCards/onthis-shortcuts.jpg
---

import ShortcutsDiagram from "/img/get_started/tooling/cross_chain/shortcuts/Shortcuts.svg"

A Shortcut allows users to execute onchain actions by sending funds to a 
contract address.

Each Shortcut is a unique smart contract designed to carry out the desired 
function. Shortcuts are represented by ENS domains, making addresses 
human-readable.

:::note

Shortcuts currently only supports Ethereum Mainnet as the source chain, unless 
explicitly specified by the Shortcut description. Shortcut addresses are not 
chain-agnostic, but are different from network to network. Sending ETH (or other 
tokens) to the wrong network may result in a loss of funds.

:::

## How it works: user flow

A simple use case for a Shortcut could involve a user who wants to streamline 
the process of bridging ETH to Linea:

1. A user sends ETH to a Shortcut address 
2. The ETH is automatically bridged to Linea via [Across](https://across.to/)
3. The ETH is returned as native Linea ETH to the sender on the destination 
chain (Linea).

More complex Shortcuts can do additional things: bridge and swap, bridge and 
deposit to a liquidity pool, bridge and stake/restake. The developer's 
imagination is the only limit.

<div className="img-large">
  <ShortcutsDiagram alt="Shortcuts Diagram" />
</div>

## How it works: technical

Shortcuts trigger actions using a fallback function in the smart contract called 
`receive()`. This allows users to initiate a transaction without approvals. The 
contract engages with Across intent-based listeners and paths that will execute 
the action on the destination chain. 

The output token(s) from the automation are returned to `msg.sender` (the 
account that called the function; in this case, the person using the Shortcut).

## Onthis Snap

A MetaMask Snap has been built specifically to help you verify that a Shortcut 
is behaving as intended.

:::info[MetaMask Snaps]

MetaMask Snaps is a system that enables third-party developers to add features 
and functionality to MetaMask. Read more in the [MetaMask Help Center](https://support.metamask.io/metamask-snaps), 
or visit the [Snaps directory](https://snaps.metamask.io/) to browse what's 
available.

:::

Before you send funds to the Shortcut, the Snap automatically recognizes that 
the transaction involves an Onthis Shortcut, and provides a breakdown of:
- The contract address, enabling you to confirm it is correct
- A description of what will happen once you send funds to the Shortcut. 

Install the Snap by heading either to the [Snaps Directory](https://snaps.metamask.io/snap/npm/onthis-snap/) 
or the [dedicated Onthis page](https://onthis.xyz/snap), and then hitting 
'Add to MetaMask'.

## Fees

Shortcuts are provided by [onthis.xyz](https://onthis.xyz/) and are built on 
top of [Across](https://across.to/). Both services charge users a fee on the 
origin network. This fee covers the bridging costs and automation costs and is 
shared between the two providers. The fee is calculated as a percentage of the 
amount transferred, and is on top of the network gas fee paid to execute the 
origin chain.

Here is an example of the Shortcuts fee model:

<table>
  <thead>
    <tr>
      <th>Amount ($)</th>
      <th>Swap + bridge fees</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>100</td>
      <td>5.4% ($5.40)</td>
    </tr>
    <tr>
      <td>500</td>
      <td>0.5% ($0.50)</td>
    </tr>
    <tr>
      <td>1,000</td>
      <td>0.5% ($5.00)</td>
    </tr>
    <tr>
      <td>10,000</td>
      <td>0.5% ($50.00)</td>
    </tr>
    <tr>
      <td>100,000</td>
      <td>0.5% ($500.00)</td>
    </tr>
  </tbody>
</table>

## Risks

Shortcuts do not store value, so the smart contract risk is lower than a 
traditional dapp. Since they are built on Across, they share its risk profile.

There are several other risks inherent in Shortcuts: 

### Chain-dependent addressing

Every Shortcut has a different contract address. Even the same Shortcut deployed 
on two different networks (Ethereum Mainnet and Arbitrum, for example) will have 
a different address. Moreover, Shortcuts only work with ETH. Sending tokens 
(ERC-20, ERC-721, or others) to a Shortcut may result in a loss of funds, as 
will sending ETH to a Shortcut deployed on a different network.

Linea addresses this risk by clearly identifying the Shortcut's network in its 
name. If a network is specified, it means that the Shortcut can only accept 
ETH on that specific network. The naming convention for Shortcut ENS names 
curated by Linea is as follows:

`[network].[usecase/partner].onlinea.eth`

In practice, this could look something like:

`arbitrum.bridge.onlinea.eth`

The omission of the `[network]` prefix indicates that the Shortcut relates to 
Ethereum Mainnet; `bridge.onlinea.eth`, for example, only works on Ethereum 
Mainnet.

### Naming system

The easy UX of sending ETH to an ENS name can present a risk for the user. An 
attacker can obtain access to the owner key of the ENS name and change the 
address record, pointing it to their own wallet and collecting the funds sent 
there. 

Linea addresses this risk by controlling the ENS name with a multisig wallet and 
assigning the manager role to the Linea Security Council (the maximum grade of 
security). We also have monitors in place that listen for role changes for the 
ENS name.

### Upgradability of contracts 

Shortcuts can be upgraded by the creator. An attacker can upgrade the contract 
and change its behavior. Linea addresses this risk by requiring trusted creators 
(like the [onthis.xyz](https://onthis.xyz/) team) to hold the owner keys in 
a secure multisig or asking the creators to hand over the ownership of the 
contracts to the Linea multisig.

### Contract security 

Even though Shortcuts contracts do not store value, security audits are still 
important. Shortcuts created via the [Creator Tool](https://create.onthis.xyz/) 
have a deterministic output that is included in the audit scope of the 
Creator Tool itself. Custom built shortcuts require an independent audit. 

Linea addresses this risk by including a third-party audit of the Shortcuts 
listed under [onlinea.eth](https://app.ens.domains/onlinea.eth) as part of the curation 
process. 

## Further information

Refer to the official [onthis.xyz documentation](https://docs.onthis.xyz) for 
more information.


==================== FILE: /workspace/docs/get-started/tooling/cross-chain/ccip.mdx ====================

---
title: Chainlink Cross-Chain Interoperability Protocol (CCIP)
sidebar_label: Chainlink CCIP
image: /img/socialCards/chainlink-cross-chain-interoperability-protocol-ccip.jpg
---

Chainlink CCIP is a blockchain interoperability protocol that enables developers to build secure 
applications that can transfer tokens, messages (data), or both tokens and messages across chains.

CCIP enables three main actions:
- **Arbitrary messaging**: Send arbitrary data (encoded as bytes) to a receiving smart contract on 
a different chain.
- **Token transfers**: Transfer tokens to a smart contract or an externally owned account (EOA).
- **Programmable token transfers**: Simultaneously transfer tokens and arbitrary data in a single
transaction.

To use CCIP services, you need to have LINK available to pay node operators, a cost referred to as
CCIP fees. [See the token contracts for LINK on Linea](https://docs.chain.link/resources/link-token-contracts#linea). 

## Resources

- [CCIP documentation](https://docs.chain.link/ccip)
- [Linea CCIP directory](https://docs.chain.link/ccip/directory/mainnet/chain/ethereum-mainnet-linea-1)
- [LINK token contracts on Linea](https://docs.chain.link/resources/link-token-contracts#linea)
- [Chainlink Builder's Quick Links](https://docs.chain.link/builders-quick-links), showing all 
Chainlink services available on Linea 


==================== FILE: /workspace/docs/get-started/tooling/cross-chain/thirdweb.mdx ====================

---
title: Thirdweb Universal Bridge
description: >-
  Learn how to use the Thirdweb Universal Bridge to enable onramps, swapping,
  and bridging on any EVM chain.
image: /img/socialCards/thirdweb-universal-bridge.jpg
---

[Universal Bridge](https://thirdweb.com/connect/universal-bridge) is a comprehensive web3 payment 
solution to help you monetize any app or game.  

With Universal Bridge, your users can onramp, bridge, and swap on any EVM chain — with any EVM token 
or fiat — thanks to its automatic cross-chain routing.  

Plus, developers can earn from day one using the fee-sharing mechanism and its easy implementation.

## Features

- Let users pay for assets in any EVM token on any EVM chain  
- Automatic cross-chain routing for seamless transactions  
- Earn from day one with the fee-sharing mechanism  
- Access a ready-made UI component for easy implementation  

Learn more in the [Universal Bridge documentation](https://portal.thirdweb.com/connect/pay/overview).

## Get started

See the [thirdweb documentation](https://portal.thirdweb.com/connect/pay/get-started) to get started 
with Universal Bridge.

## See Universal Bridge in action

Want to see how Universal Bridge works? Check it out under the hood with this example:

```jsx
import { createThirdwebClient } from "thirdweb";
import { PayEmbed } from "thirdweb/react";

import { createWallet } from "thirdweb/wallets";
import { linea } from "thirdweb/chains";

const client = createThirdwebClient({
  clientId: "....",
});

function Example() {
  return (
    <PayEmbed
      client={client}
      payOptions={{
        mode: "fund_wallet",
        prefillBuy: {
          chain: linea,
          amount: "0.01",
        },
      }}
    />
  );
}

```

[See how the Buy Crypto flow works in the playground](https://playground.thirdweb.com/connect/pay).


==================== FILE: /workspace/docs/get-started/tooling/cross-chain/ccip-read.mdx ====================

---
title: CCIP Read
description: Use a CCIP Read gateway to query data on Linea from L1
image: /img/socialCards/ccip-read.jpg
---

import LineaCCIPGraphic from "/img/get_started/tooling/cross_chain/ccip_read_gateway/Linea_ENS_CCIP_read.svg"

[CCIP Read](https://eips.ethereum.org/EIPS/eip-3668) is a protocol developed by ENS that introduces
functionality for cross-chain data retrieval through a gateway server. It extends the [Cross-Chain
Interoperability Protocol (CCIP)](./ccip.mdx) developed by Chainlink, who funded its development 
through a [Chainlink Community Grant](https://blog.chain.link/ens-grant-for-ccip-read-development/). 

Ethereum Name Service (ENS) implements CCIP Read so that it can resolve domains on Ethereum even if 
the relevant data and records are stored on an L2 chain—an offchain resolver framework. The 
process is trust-minimal, as the gateway returns a storage proof that can be verified on L1, and 
which is immune from any intervention or tampering.

Linea adapted the functionality of the relevant ENS contract, [`evm-gateway`](https://github.com/ensdomains/evmgateway),
so that it would function correctly with Linea's sparse Merkle tree design. The 
Linea Names repository therefore adds support for CCIP Read to Linea.

:::info 

Read more about sparse Merkle trees in our [architecture documentation](../../../technology/state-manager.mdx).

:::

## CCIP 

The Chainlink CCIP is middleware designed to enable traditional backends to securely interact with 
blockchains, preventing the need for organizations to devote resources to developing case-by-case
solutions to this problem. This enables applications to transfer assets and data between chains,
allowing developers to access different chains for their relative strengths, and also access a 
larger audience.

Read more about CCIP in the [Chainlink documentation](https://docs.chain.link/ccip).

## Linea Names

Linea Names allows Linea users to register human-readable domains for considerably 
lower fees than on Ethereum Mainnet, it also leverages smart contracts with 
considerable utility for developers by enabling CCIP Read. See the user guide 
[here](https://support.linea.build/explore/ens).

The [Linea Names repository](https://github.com/Consensys/linea-ens) contains a 
frontend and associated contracts for ENS to work on Linea, including 
functionality that enables any L1 application to query L2 data using CCIP Read. 

However, Linea Names is just one example use case; CCIP Read is beneficial in any 
scenario where it's advantageous to store data on L2. In addition to ENS-like 
systems, the library enables L1 applications to create allowlists that use 
cross-chain Verax attestations to determine eligibility for NFT mints or 
governance voting, for example. 

:::tip[Deploy a subdomain on Linea]

You can use the building blocks of Linea Names to [deploy your own subdomain on Linea](../../how-to/deploy-subdomain.mdx).

:::

## Use CCIP Read on Linea

While the repository was created to bring ENS to Linea, its component libraries 
can be applied in other contexts. 

The two main contracts are: 
- The [Linea CCIP Gateway](https://github.com/Consensys/linea-ens/tree/main/packages/linea-ccip-gateway), 
  which implements the gateway required for L1 protocols to query data on Linea,    
- The [Linea State Verifier](https://github.com/Consensys/linea-ens/tree/main/packages/linea-state-verifier), 
  which verifies the state proofs generated by the gateway.  

Together, they can be used to retrieve data on Linea in a trustless way. They 
are 'generic' in the sense that they can be applied to any use case.

The basic outline for using these contracts in a read capacity is as follows:

<div className="img-large" style={{ padding: '25px 0' }}>
  <LineaCCIPGraphic alt="Diagram of using CCIP Read to query L2 data on Linea" />
</div>

1. Your L1 contract, which we'll refer to as the client contract, requires data 
   from L2. To do this, it builds a request to the `EVMFetcher` contract (part 
   of the Linea State Verifier).

2. The `EVMFetcher` contract uses CCIP Read to call the offchain gateway. 

3. The gateway retrieves the requested information from your associated L2 
contract. 

4. The gateway returns data and proofs to the [`IEVMVerifier`](https://github.com/Consensys/linea-ens/blob/main/packages/linea-state-verifier/contracts/IEVMVerifier.sol) 
contract.

5. `IEVMVerifier` and [`LineaSparseProofVerifier`](https://github.com/Consensys/linea-ens/blob/main/packages/linea-state-verifier/contracts/LineaSparseProofVerifier.sol) 
verify the proofs and return the data to the L1 client contract. 

## Example

The below contract fetches another contract's storage value, `testUint`. 

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import { EVMFetcher } from '@ensdomains/evm-verifier/contracts/EVMFetcher.sol';
import { EVMFetchTarget } from '@ensdomains/evm-verifier/contracts/EVMFetchTarget.sol';
import { IEVMVerifier } from '@ensdomains/evm-verifier/contracts/IEVMVerifier.sol';

contract TestL2 {
    uint256 testUint; // Slot 0

    constructor() {
        testUint = 42;
    }
}

contract TestL1 is EVMFetchTarget {
    using EVMFetcher for EVMFetcher.EVMFetchRequest;

    IEVMVerifier verifier;
    address target;

    constructor(IEVMVerifier _verifier, address _target) {
        verifier = _verifier;
        target = _target;
    }

    function getTestUint() public view returns(uint256) {
        EVMFetcher.newFetchRequest(verifier, target)
            .getStatic(0)
            .fetch(this.getSingleStorageSlotCallback.selector, "");
    }

    function getSingleStorageSlotCallback(bytes[] memory values, bytes memory) public pure returns(uint256) {
        return uint256(bytes32(values[0]));
    }
}
```


==================== FILE: /workspace/docs/get-started/tooling/cross-chain/axelar.mdx ====================

---
title: Axelar
image: /img/socialCards/axelar.jpg
---

[Axelar](https://docs.axelar.dev/) is a blockchain of blockchains that allows 
for universal web3 interoperability. By integrating with Axelar, your 
Linea-based application now has access to the [45+ chains](https://axelarscan.io/) 
that are also connected via Axelar. As Axelar is a blockchain of blockchains, it 
overcomes many of the challenges of more centralized interoperability solutions;
transactions that go through the Axelar network cannot be censored by any oracle, 
relayer, or sequencer.

## Functionality

Axelar enables interchain features for builders on Linea:

1. [Send tokens](https://docs.axelar.dev/dev/send-tokens/overview) across 
blockchains
2. [Send general messages](https://docs.axelar.dev/dev/general-message-passing/overview) 
across blockchains

## Linea integration

When integrating with Axelar there are two key contracts you must use:

1. The [Axelar Gateway](https://docs.axelar.dev/learn#gateway-smart-contracts)
   - On the source chain, this contract exposes the functions which you will use 
   to initiate an interchain transaction.
   - On the destination chain, this contract enables messages to be executed 
   automatically to complete the interchain transaction.
1. The [Axelar Gas Service](https://docs.axelar.dev/dev/general-message-passing/gas-services/intro)
   - This contract is the entrypoint into Axelar's gas service, which handles 
   gas payment for your transaction on both the Axelar network and the 
   destination chain. You, as the caller, now only need to cover gas on the 
   source chain.

### Contract addresses

<table>
  <thead>
    <tr>
      <th>Contract</th>
      <th>Network</th>
      <th>Address</th>
      <th>networkId</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Gateway</td>
      <td>Mainnet</td>
      <td><a href="https://lineascan.build/address/0xe432150cce91c13a887f7D836923d5597adD8E31">0xe432150cce91c13a887f7D836923d5597adD8E31</a></td>
      <td>59144</td>
    </tr>
    <tr>
      <td>Gateway</td>
      <td>Testnet</td>
      <td><a href="https://sepolia.lineascan.build/address/0xe432150cce91c13a887f7D836923d5597adD8E31">0xe432150cce91c13a887f7D836923d5597adD8E31</a></td>
      <td>59141</td>
    </tr>
    <tr>
      <td>Gas Service</td>
      <td>Mainnet</td>
      <td><a href="https://lineascan.build/address/0x2d5d7d31F671F86C782533cc367F14109a082712">0x2d5d7d31F671F86C782533cc367F14109a082712</a></td>
      <td>59144</td>
    </tr>
    <tr>
      <td>Gas Service</td>
      <td>Testnet</td>
      <td><a href="https://sepolia.lineascan.build/address/0xbE406F0189A0B4cf3A05C286473D23791Dd44Cc6">0xbE406F0189A0B4cf3A05C286473D23791Dd44Cc6</a></td>
      <td>59141</td>
    </tr>
  </tbody>
</table>

Once you have submitted your transaction, you can view it on the [Axelarscan 
block explorer](https://axelarscan.io/). The Axelarscan explorer is specifically 
tailored to show your interchain transaction step-by-step as it passes from the 
source chain, via the Axelar network, to the destination chain.

## Linea-Axelar example

For a full end-to-end example of a Linea-Axelar integration, check out our 
[video walkthrough](https://youtube.com/watch?v=-KgJZmq8Umc&t=1s) of the 
process. The complementary code can be found [here](https://github.com/Olanetsoft/linea-interchain-workshop-with-axelar).

## Axelar use cases

For inspiration, here are some live use cases demonstrating the kind of 
interchain applications that can be built on top of Axelar:

1. Interchain token swaps (e.g. [Squid](https://app.squidrouter.com/))

   - Squid is a new protocol built on top of Axelar that allows users to swap 
   tokens with a Uniswap-like experience, leveraging Axelar for swaps between 
   tokens across different blockchains. Squid reduces the need to revert to 
   centralized exchanges or multiple different exchanges to swap tokens across 
   chains.

2. Interchain lending (e.g. [Prime Protocol](https://primeprotocol.xyz/))

   - A chain-agnostic prime brokerage that allows users to deposit assets from 
   any connected chain and use their aggregate value as collateral for loans on 
   any other connected chain. Prime offers the ability to build interchain 
   applications that connect from any blockchain to any other blockchain, rather 
   than just connecting a series of blockchains to Ethereum. This interchain 
   design allows for a variety of new DeFi use cases, including cross-chain 
   margining.

3. Interchain gaming (e.g. [Junkyard](https://junkyard.wtf/))

   - Web3 gaming is heavily reliant on NFTs, and enabling NFTs to be passed 
   between blockchains is a critical next step for NFT-based games. Junkyard 
   leverages Axelar for interchain NFTs: players can deposit their NFTs to the 
   Junkyard contract. The NFT can come from any chain connected to the Axelar 
   ecosystem, including Linea.

## Get involved

1. Meet the community on [Discord](http://discord.gg/axelar)
2. Dive into the data on the [Axelarscan block explorer](http://axelarscan.io)


==================== FILE: /workspace/docs/get-started/tooling/cross-chain/layerzero.mdx ====================

---
title: LayerZero Omnichain Messaging
image: /img/socialCards/layerzero-omnichain-messaging.jpg
description: >-
  Omnichain interoperability protocol enabling secure cross-chain communication
  for Linea applications. Connect to 100+ blockchains, send messages, and deploy
  omnichain tokens.
---

[LayerZero](https://layerzero.network) is an **omnichain interoperability protocol** that enables smart contracts to seamlessly communicate between different blockchain networks. With LayerZero V2, applications deployed on Linea can connect and interact with 100+ supported blockchains through secure, configurable messaging channels.

## Key features

LayerZero enables powerful cross-chain capabilities for builders on Linea:

1. **Cross-chain messaging** - Send arbitrary messages and data between contracts on different chains
2. **Omnichain tokens** - Deploy tokens (fungible `OFT` and non-fungible `ONFT`) that work seamlessly across multiple chains
3. **External chain data access** (`lzRead`) - Fetch and compute onchain state from other networks
4. **Composed messages** - Chain multiple cross-chain operations together

## How it works

1. **DVNs** (Decentralized Verifier Networks) independently verify that a message is valid, waiting for a configured number of block confirmations on the source chain.
2. When the message is verified, **executors** on the destination chain deliver the message to the target contract, paying for the destination gas automatically in the background. The user only pays for gas on the source chain.

Because each application can configure its own DVN sets, your security is not locked into a single aggregator or middlechain. For more details, check out the [LayerZero docs](https://docs.layerzero.network/).

To run your own DVN as part of your security set, check out the [DVN docs](https://docs.layerzero.network/v2/developers/evm/off-chain/build-dvns).

## Linea integration

When integrating with LayerZero, there are two key aspects to understand:

1. The [LayerZero Endpoint](https://docs.layerzero.network/v2/home/protocol/layerzero-endpoint)
   - Immutable smart contract that serves as the entry and exit point for messages
   - Allows applications to configure security and execution parameters
   - Provides interfaces for sending, receiving and reading cross-chain data
2. [Security Stack](https://docs.layerzero.network/v2/home/modular-security/security-stack-dvns)
   - Configurable set of Decentralized Verifier Networks (DVNs) that validate messages
   - Allows applications to customize security and cost tradeoffs
   - Ensures message integrity across chains

### Contract addresses

<table>
  <tbody>
    <tr>
      <th>Chain</th>
      <th>Chain Id</th>
      <th>Endpoint Id</th>
      <th>Endpoint address</th>
    </tr>
    <tr>
      <td>Linea Mainnet</td>
      <td>59144</td>
      <td>30183</td>
      <td>
        <a href="https://layerzeroscan.com/api/explorer/linea/address/0x1a44076050125825900e736c501f859c50fE728c">
          0x1a44076050125825900e736c501f859c50fE728c
        </a>
      </td>
    </tr>
    <tr>
      <td>Linea Sepolia Testnet</td>
      <td>59141</td>
      <td>40287</td>
      <td>
        <a href="https://layerzeroscan.com/api/explorer/lineasep-testnet/address/0x6EDCE65403992e310A62460808c4b910D972f10f">
          0x6EDCE65403992e310A62460808c4b910D972f10f
        </a>
      </td>
    </tr>
  </tbody>
</table>

Once a transaction is submitted, you can trace it on [LayerZero Scan](https://layerzeroscan.com/), which shows cross-chain message flow from source to destination in real time.

## Get started

Developers should:

1. Deploy contracts on each chain: [Quickstart - Create Your First Omnichain App](https://docs.layerzero.network/v2/developers/evm/create-lz-oapp/start)
2. Configure a Security Stack by selecting DVNs and block confirmations (optional).
3. Optionally configure an executor or use defaults to deliver messages.
4. Send messages, send tokens (OFT, ONFT), or read state on any chain, using LayerZero.

## Example use cases

LayerZero powers various cross-chain applications across different categories:

1. **Omnichain tokens (OFTs)** (e.g., [Ethena's USDe](https://ethena.fi/), Wrapped Bitcoin)
   - Unified token supply across chains
   - Native bridging without intermediary tokens
   - Real-world examples include USDe, sUSDe, ENA tokens, and WBTC
2. **Cross-chain DEXs** (e.g., [Trader Joe](https://traderjoexyz.com/))
   - Unified liquidity pools across chains
   - Cross-chain swaps and trading
3. **Omnichain lending** (e.g., [Radiant Capital](https://radiant.capital/))
   - Supply assets on any chain
   - Borrow against cross-chain collateral
4. **Cross-chain governance** (e.g., [Stargate DAO](https://stargate.finance/))
   - Vote on one chain, execute on many
   - Unified governance across deployments
5. **Chain data oracles**
   - Read and verify external chain state
   - Make decisions based on cross-chain data

## Resources

1. [LayerZero Developer Documentation](https://docs.layerzero.network/v2)
2. [LayerZero Scan](https://layerzeroscan.com/) - Message explorer and debugging
3. [Discord Community](https://discord.gg/layerzero)
4. [GitHub](https://github.com/LayerZero-Labs/)


==================== FILE: /workspace/docs/get-started/tooling/ai/index.mdx ====================

---
title: AI
image: /img/socialCards/ai.jpg
---


import DocCardList from '@theme/DocCardList';

<DocCardList />


==================== FILE: /workspace/docs/get-started/tooling/ai/spheron.mdx ====================

---
title: Spheron network
image: /img/socialCards/spheron-network.jpg
---

[Spheron Network](https://spheron.network/) is a decentralized compute provider and marketplace 
that offers scalable and secure infrastructure solutions. It aims to create a decentralized GPU 
exchange for global AI workloads, enabling projects from DeFi to AI to access compute solutions at 
lower costs compared to traditional providers. Spheron focuses on simplicity, usability, and support
to build an efficient global compute system for the next generation of applications.

View the [Spheron documentation](https://docs.spheron.network/) for information on how to deploy 
and manage your decentralized applications using the platform.


==================== FILE: /workspace/docs/get-started/tooling/privacy/secret.mdx ====================

---
title: Secret Network
image: /img/socialCards/secret-network.jpg
---

## Decentralized confidential computing

On most blockchains, all data must be public. But using Secret's [Confidential Computing Layer](https://scrt.network/confidential-computing-layer), dapps can communicate with Secret to store and compute over encrypted 
data. This unlocks powerful new use-cases for Linea applications. Some examples of what this can 
enable are private voting for DAOs, encrypted storage, secure random number generation, confidential 
data access via NFTs, sealed-bid auctions, and encrypted order books for DeFi applications.

## Integrate Secret's CCL

You can integrate Secret's CCL into an existing Linea application, or design a new application from 
the ground up to take advantage of the unique use-cases it enables.

To start, check out Secret Network's [Confidential Computing Layer](https://scrt.network/confidential-computing-layer) 
landing page to get an overview of how it works, and example use-cases for inspiration. From there 
you'll find multiple links to Secret's CCL documentation:

- [Basics](https://docs.scrt.network/secret-network-documentation/development/ethereum-evm-developer-toolkit/basics) - 
explains the cross-chain communication technologies used, and how to connect a MetaMask wallet to 
Secret Network.
- [Use-cases](https://docs.scrt.network/secret-network-documentation/development/ethereum-evm-developer-toolkit/usecases) - 
provides tutorials showing how to build various types of EVM applications using Secret's CCL. All of 
these tutorials can be used to connect Linea cross-chain with Secret Network.
- [Supported Networks](https://docs.scrt.network/secret-network-documentation/development/ethereum-evm-developer-toolkit/supported-networks) - 
provides a list of gateway contract addresses. This is how your Linea application will communicate 
with Secret. 

## Get support

To get CCL development help, you can join the Secret Network [Discord](https://scrt.network/discord) 
or [Telegram](https://t.me/SCRTCommunity). If you want to get in touch with the Secret Network 
developer relations team directly, you can use [this form](https://forms.monday.com/forms/43125a4be6281ed487b0ef2a7c76a251).


==================== FILE: /workspace/docs/get-started/tooling/privacy/index.mdx ====================

---
title: Security
image: /img/socialCards/security.jpg
---


import DocCardList from '@theme/DocCardList';

<DocCardList />


==================== FILE: /workspace/docs/get-started/tooling/account-abstraction/smartwallets.mdx ====================

---
title: thirdweb SDK
image: /img/socialCards/thirdweb-sdk.jpg
---

thirdweb's Smart Wallet SDK allows you to implement EIP-4337-compliant smart contract-enabled 
accounts on Linea, and leverages Pimlico infrastructure for Bundler and Paymaster.

A smart contract-enabled account, or _smart account_, is a type of web3 account that can be 
customized and managed by smart contracts.

This smart account is unlocked by a private key. This key can be held in MetaMask, on your local 
machine, or elsewhere, and is used as a way to 'sign in' to the account.

## Benefits

1. Optimized transaction efficiency and transaction batching
2. Combine multiple transactions into a single transaction to save on gas fees
3. Improved security features
4. Social and multi-sig recovery
5. Recover an account without seed phrases/passwords
6. Nominate a trusted person to recover your account in the case of an emergency

## Use cases:

As a dapp developer, you may want to control the user experience from the onboarding phase and 
embed a smart wallet in your dapp by default. thirdweb's Smart Wallet SDK enables this with 
low-code, Node.js, and React templates.

Visit thirdweb's Smart Wallet documentation:

1. [Smart Wallet docs and templates](https://portal.thirdweb.com/connect/account-abstraction/overview)
2. [Factories and contracts](https://thirdweb.com/explore/smart-wallet)
3. [Glossary](https://portal.thirdweb.com/glossary/smart-wallet)


==================== FILE: /workspace/docs/get-started/tooling/account-abstraction/openfort.mdx ====================

---
title: Openfort
image: /img/socialCards/openfort.jpg
---

## Account abstraction infrastructure built for web3 games

[Openfort](https://openfort.xyz) is an infrastructure provider that simplifies the development of 
games and gamified experiences with a suite of API endpoints. The platform vertically integrates 
the AA stack with a network of paymasters and bundlers, enabling game developers to focus on 
development without worrying about private key management, the account model or onchain interactions.

Openfort is powered by [ERC-6551](https://eips.ethereum.org/EIPS/eip-6551) and [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337).

[Visit the docs](https://openfort.xyz/docs) to get started with Openfort by deploying a smart 
account on Linea and creating your first transaction.


==================== FILE: /workspace/docs/get-started/tooling/account-abstraction/pimlico.mdx ====================

---
title: Pimlico
image: /img/socialCards/pimlico.jpg
---

Pimlico provides smart account tools for ERC-4337 that streamline development.

The core services provided by ERC-4337 at infrastructure level are:

1. A single entry point contract
2. A bundler (network) to bundle `UserOps`
3. An optional paymaster service

[The Pimlico docs](https://docs.pimlico.io/docs) will help you get started by deploying a wallet on 
Linea on top of Pimlico and submitting your first `UserOperation`.


==================== FILE: /workspace/docs/get-started/tooling/account-abstraction/noves.mdx ====================

---
title: Noves
image: /img/socialCards/noves.jpg
---

Noves provides advanced data capabilities for ERC-4337, both at the pre-sign level and for retrieval 
and interpretation of historical transactions.

## Human-readable transaction pre-sign

For pre-sign, Noves offers a `userOp` [preview tool](https://docs.noves.fi/reference/post_evm-chain-preview4337) 
as part of its Foresight product line. It is akin to a simulator, but also interprets the real-world 
meaning of the unsigned transaction (for example, "This transaction will claim 50 USDC in rewards"). 
This output can be shown to the user prior to the userOp being signed and submitted to the bundler 
for execution.

## Human-readable transaction history

For transactions that have already been executed, the [Translate API](https://docs.noves.fi/reference/introduction) 
allows developers to retrieve transactions in fully-enriched, human-readable form. For a sample of 
what this data looks like, check out [Linea for Humans](https://linea.forhumans.app), a human-readable 
block explorer built by Noves for Linea.

The Translate API is [fully compatible](https://docs.noves.fi/reference/account-abstraction) with 
account abstraction, and will "look through" the multiple layers of smart contracts that are 
involved, removing unnecessary technical jargon from the picture and telling the user in plain 
English what each transaction was (a stake, a claim rewards, a liquidity add, etc.).

## Learn more

- [Find out more about Noves](https://noves.fi)
- [Product docs](https://docs.noves.fi)

## Start using for free

A free plan is available for Linea users; click [here](https://noves.fi/pricing) to sign up.


==================== FILE: /workspace/docs/get-started/tooling/account-abstraction/etherspot.mdx ====================

---
title: Etherspot
image: /img/socialCards/etherspot.jpg
---

## Robust ERC4337 infrastructure for seamless web3 development

Build a positive web3 user experience by removing usability pain points with Etherspot's account 
abstraction (AA) infrastructure.

[**Etherspot**](https://etherspot.io) offers the following AA services:

- [**Etherspot Prime account abstraction SDK**](https://github.com/etherspot/etherspot-prime-sdk) — 
From social logins to transaction batching, using an Etherspot smart wallet can give your dapp a 
web2-like interface to provide the user with a seamless experience.
- [**Skandha bundler**](https://github.com/etherspot/skandha) - Bundle `userOperations` together to 
include multiple transactions onchain at a lower cost.
- [**Arka paymaster**](https://etherspot.fyi/arka/intro) - An open-source paymaster service for 
gasless and sponsored transactions.
- [**TransactionKit**](https://etherspot.io/transactionkit) - A smart account React library for 
fast and simple web3 development.

For more information and guidance on developing with Etherspot, please refer to our
[documentation](https://etherspot.fyi/introduction).

If you have any questions, contact the team on [Discord](https://discord.etherspot.io).


==================== FILE: /workspace/docs/get-started/tooling/account-abstraction/biconomy.mdx ====================

---
title: Biconomy
image: /img/socialCards/biconomy.jpg
---

The Biconomy SDK provides solutions for decentralized applications (dapps) that streamline and 
simplify tasks from onboarding to user engagement while respecting self-custody. It is a one-stop 
solution to reduce friction in your dapp: it eases onboarding for new users and abstracts away 
transaction complexities that your users face on a daily basis. This is enabled by using Smart 
Contract Wallets (SCW) built on top of our multi-chain Relayer Infrastructure.

Find out more about Biconomy [here](https://biconomy.io/).


==================== FILE: /workspace/docs/get-started/tooling/account-abstraction/particle-network.mdx ====================

---
title: Particle Network
image: /img/socialCards/particle-network.jpg
---

## Smart Wallet-as-a-Service

[Particle Network](https://particle.network)'s Wallet Abstraction services enable universal, 
web2-adjacent onboarding and interactions. Its core technology, [Smart Wallet-as-a-Service](https://blog.particle.network/announcing-our-smart-wallet-as-a-service-modular-stack-upgrading-waas-with-erc-4337) 
(WaaS) onboards users into multi-party computation (MPC)-secured smart accounts supporting any chain. 
It also allows developers to improve user experience through modular, fully customizable EOA/AA 
embedded wallets. Particle supports its Smart Wallet-as-a-Service through a modular L1 that powers 
chain abstraction, acting as a settlement layer across chains for a seamless multi-chain experience.

Smart Wallet-as-a-Service is compatible with Linea using EOAs (traditional accounts) and AA (smart 
accounts). This AA support extends to Particle Network's [Bundler](https://developers.particle.network/docs/bundler) 
and [Omnichain Paymaster](https://developers.particle.network/docs/paymaster) infrastructure, both 
of which are compatible with Linea.

Developers can leverage Particle Network to onboard users into smart accounts using social login, 
then facilitate full-stack ERC-4337 account abstraction through [native AA SDKs](https://developers.particle.network/docs/aa-web-quickstart), 
available across six platforms.

### Learn more

To give Particle Network's Smart Wallet-as-a-Service a try and learn more about implementation, 
check out the [Particle Web Demo](https://core-demo.particle.network/).


==================== FILE: /workspace/docs/get-started/tooling/account-abstraction/oklink.mdx ====================

---
title: OKLink
image: /img/socialCards/oklink.jpg
---

[OKLink](https://oklink.com/) is a one-stop blockchain data platform covering a wide range of 
onchain metrics. 

OKLink provides onchain information, prioritizing accessibility by simplifying insights for easy 
understanding. Users can search through transactions, blocks, wallet addresses, smart contracts, 
and other onchain data covering 40+ chains.

## Account abstraction services available through OKLink

1. [View UserOps details](https://oklink.com/linea/tx/uop/0x6c8f68613afffeb70ea31f145dc416d18540a32a0e00e04df4c94018d666fde2): 
including the AA address initiating the transaction, paymaster information, and details about using 
ERC-20 tokens for transaction fees.
2. [View the transaction list for ERC-4337](https://oklink.com/linea/address/0x7fb5aa2a66bd08c61956bd29df4da48cc63d66d9/aa): 
can view all ERC-4337 transactions related to the address.
3. [View the details page of the Entry Point](https://oklink.com/linea/address/0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789/contract): 
supports viewing transactions, contract details, and performing contract read and write operations.


==================== FILE: /workspace/docs/get-started/tooling/account-abstraction/index.mdx ====================

---
title: Account abstraction
image: /img/socialCards/account-abstraction.jpg
---

`Account abstraction` is a broad category of fast-moving development in the Ethereum ecosystem. It 
generally refers to different ways to create and manage accounts, other than using a Secret Recovery 
Phrase (seed phrase) and a wallet.

One milestone in this area was the inclusion of [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) 
in the Ethereum protocol. 

 This includes, but is not limited to:

 - Creating accounts using a cryptographic library running in a dapp (an "embedded wallet")
 - The creation of an account that is to some degree controlled by a smart contract

That second point may seem small, but it enables things like:

 - Account recovery ("social recovery", recovery via email or other identities or accounts)
 - Use case-specific limitations
 - Paying for a user's gas fees
 - Delegation of assets

and a *lot more*.

As a network, Linea is heavily invested in innovating in the account abstraction space; consult 
the resources here to see how you can implement the tools we already have... and then build your own.

import DocCardList from '@theme/DocCardList';

<DocCardList />


==================== FILE: /workspace/docs/get-started/tooling/account-abstraction/station.mdx ====================

---
title: Station
image: /img/socialCards/station.jpg
---

GroupOS by [Station](https://station.express) is a web3 toolkit designed to create and coordinate 
values-aligned networks in new ways. Accounts, the core module of GroupOS, enables organizations to 
create programmatic NFT wallets, incentivize users, and measure growth.

GroupOS is powered by [ERC-6551](https://eips.ethereum.org/EIPS/eip-6551) and [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337).

## Use cases

Accounts enables organizations to use NFTs to capture members' identities more accurately, unlocking 
brand-new ways to engage and monetize.

- **Membership loyalty and rewards:** Create gamification and rewards systems where users can earn 
and exchange points and collectibles. Reward loyal and early users with exclusive access to 
product features or experiences.
- **Interoperable profile (”Passport”):** Create a portable identity system that grants users 
control over their digital identity and reputation, supporting user autonomy and reducing platform 
integration overhead and reliance on third-party entities.
- **Gasless onboarding:** Enable gasless and user-friendly onboarding through NFT-bound accounts (ERC-6551) 
and account abstraction (ERC-4337) standards. Provide new members with access to your NFT experience
without having to pay gas fees.

## Quickstart

Follow our [quickstart tutorial](https://docs.groupos.xyz/api-reference/v1/getting-started/quickstart/) 
to create, distribute, and manage NFT accounts.

Need help? Have questions? [Reach us on Discord](https://discord.gg/BR6CgxUe).


==================== FILE: /workspace/docs/get-started/tooling/permanent-data/irys/overview.mdx ====================

---
title: Overview
image: /img/socialCards/overview.jpg
description: Using Irys's onchain data with Linea.
---

[Irys](https://docs.irys.xyz/) is a datachain, a blockchain optimized for data 
storage. Irys is built to store, retrieve, and process datasets of any size with 
minimal latency.

Irys makes it easy to store your data onchain by supporting payments with ETH on 
Linea. You can upload data with a single upfront payment, with guaranteed 
retrieval for a duration you set at the upload time — from a few days to forever.

Data on Irys is fully verifiable; you can inspect the blockchain at any time and 
verify what data was posted, when, and where it's located in Irys's data ledgers.


## Use Irys with Linea

Irys is **chain agnostic**; smart contracts on Linea can link to data on Irys.

You can:

- Deploy NFT contracts on Linea and [have images and metadata on Irys](../../../../learn/ecosystem-tutorials/irys/irys-nfts.mdx)
- Build games with state on Linea and visual assets on Irys
- Build an onchain identity protocol with user metadata on Irys
- Build a cross-chain bridge and use Irys to store messages

You can use [ETH on Linea](https://arweave-tools.irys.xyz/overview/supported-tokens)
to pay for permanent storage on Irys.

## Pay for uploads

Irys has a "pay once, store forever" payment model based on the number of bytes 
you upload.

## Free uploads

Uploads of less than 100KiB are free on Irys.

## Receipts

Each upload to Irys is given a cryptographically signed receipt that can be 
trustlessly verified.

Receipts are a JSON object with the following format:

```json
{
  id: '1Txlbl5NgEqUbIkDnnunHC0gFx0n8_Y92zAsoX54kI8',
  timestamp: 1676891681110,
  version: '1.0.0',
  public: '...',
  signature: '...',
  deadlineHeight: ...,
}
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>Transaction id (used to download the data)</td>
    </tr>
    <tr>
      <td>timestamp</td>
      <td>Timestamp (UNIX milliseconds) of when the transaction was created</td>
    </tr>
    <tr>
      <td>version</td>
      <td>The version of this JSON file, currently 1.0.0</td>
    </tr>
    <tr>
      <td>public</td>
      <td>Public key of the bundler node used</td>
    </tr>
    <tr>
      <td>signature</td>
      <td>A signed deep hash of the JSON receipt</td>
    </tr>
    <tr>
      <td>deadlineHeight</td>
      <td>The block number by which the transaction must be finalized on Arweave</td>
    </tr>
  </tbody>
</table>

## Pay for users' uploads

Use [balance approvals](https://docs.irys.xyz/build/d/features/balance-approvals) 
to pay for your users' uploads and build a web2-style UX that saves users from 
having to convert fiat or own tokens.

With balance approvals:

- You pay for transactions.
- Users sign transactions.

### Create an approval

```js
const receipt = await irysUploader.approval.createApproval({
  amount: irysUploader.utils.toAtomic(1), // Amount in atomic units
  approvedAddress: "<address>",
  expiresInSeconds: 100, // Expires in 100 seconds. Delete to remove expiration.
});
```

### Upload using an approval

```js
const receipt = await irysUploader.upload("GM World", {
  upload: { paidBy: "<address>" },
});
```

## Tagging

Irys supports attaching up to 20 metadata tags to each transaction. Tags are 
indexed and can be queried.

```js
// Your file
const fileToUpload = "./myNFT.png";

const tags = [{ name: "application-id", value: "foo" }];

try {
  const response = await irysUploader.uploadFile(fileToUpload, { tags });
  console.log(`File uploaded ==> https://gateway.irys.xyz/${response.id}`);
} catch (e) {
  console.log("Error uploading file ", e);
}
```

## Querying

Transaction metadata can be queried using the [Irys's GraphQL](../../../tooling/permanent-data/irys/irys-querying.mdx).


==================== FILE: /workspace/docs/get-started/tooling/permanent-data/irys/irys-querying.mdx ====================

---
title: Query Irys transactions
image: /img/socialCards/query-irys-transactions.jpg
description: Querying data on Irys.
---

Irys transaction metadata can be queried using GraphQL. You can use it to search 
for transactions by:

- Signer's address
- Payment token
- Metadata tags
- Timestamps

## GraphQL clients

You can query using an HTTP library like `fetch` or `axios`, or use specialized 
clients like [Apollo Client](https://apollographql.com/) or [urql](https://formidable.com/open-source/urql/).

## Endpoint

https://uploader.irys.xyz/graphql

## Query arguments

Any of the following query arguments can be used as search parameters:

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`ids`</td>
      <td>An array of transaction IDs passed as strings. Values are ORed together. Matching results will include transactions that have any of the supplied IDs.</td>
    </tr>
    <tr>
      <td>`owner`</td>
      <td>The address used when posting the transaction. Can be a native address from <a href="https://docs.irys.xyz/build/d/features/supported-tokens">any of the chains supported by Irys</a>. Note that in results fields, this is referred to as `address`.</td>
    </tr>
    <tr>
      <td>`token`</td>
      <td>The <a href="https://docs.irys.xyz/build/d/features/supported-tokens">token</a> used to pay for the transaction.</td>
    </tr>
    <tr>
      <td>`tags`</td>
      <td>An array of tag name/value pairs passed as JSON objects.</td>
    </tr>
  </tbody>
</table>

## Results fields

When building a query, any of the following values be included in your results:

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`id`</td>
      <td>The transaction ID.</td>
    </tr>
    <tr>
      <td>`address`</td>
      <td>The address used when posting the transaction. Can be a native address from any of the chains supported by Irys. Note that in query arguments, this is referred to as `owner`.</td>
    </tr>
    <tr>
      <td>`token`</td>
      <td>The token used to pay for the transaction.</td>
    </tr>
    <tr>
      <td>
	      ```
	      receipt { 
			deadlineHeight 
			signature 
			version
		  }
		  ```
	  </td>
      <td>An optional receipt, only exists if a user requested one at upload. 
	  	`deadlineHeight`: The block number by which the transaction must be finalized. 
	  	`signature`: A signed deep hash of the JSON receipt.</td>
    </tr>
    <tr>
      <td>
	      ```
	      tags { 
			name 
			value
		  }
		  ```
	  </td>
      <td>An array of tags supplied as name/value pairs. Exists if the user added them at upload.</td>
    </tr>
    <tr>
      <td>`timestamp`</td>
      <td>The timestamp, accurate to the millisecond of when the transaction was posted. This value is the same as the receipt timestamp.</td>
    </tr>
  </tbody>
</table>


## Sample Queries

Queries return transaction metadata. To then retrieve data, use the returned 
transaction ID and download the data from the Irys gateway using a URL formed 
as follows: `https://gateway.irys.xyz/:transactionId`.

### Transaction IDs

Search by transaction IDs.

```graphql
query getByIds {
	transactions(ids: ["--52WQHJIJod_rni8pkl1Vxt9MFGoXZAm8SC7ex6C1o", "--52THRWpX_RJzGcNXmtQ2DSP37d1e1VQ4YmvbY5ZXo"]) {
		edges {
			node {
				id
				tags {
					name
					value
				}
			}
		}
	}
}
```

### Timestamps

Search by timestamps:

```graphql
query getByTimestamp {
	transactions(timestamp: { from: 1688144401000, to: 1688317201000 }) {
		edges {
			node {
				id
			}
		}
	}
}
```


:::info
Irys timestamps are accurate to the millisecond, so you need to provide a 
timestamp in millisecond format when querying. You can convert from 
human-readable time to UNIX timestamp using websites like [Epoch101](https://epoch101.com/), 
be sure to convert in **millisecond** format, not **second**.
:::

### Owners

Search for transactions matching the wallet address used when posting the 
transaction:

```graphql
query getByOwner {
	transactions(owners: ["0xBcb812C6e26F4F0F78Bd7B6222461FF24F2942AE", "0xaC568a981B1370B2e1bAA8cE30BD5AC9E28C572D"]) {
		edges {
			node {
				id
				address
			}
		}
	}
}
```

### Tags

Search for transactions matching [tag](https://docs.irys.xyz/build/d/features/tags) 
name/value pairs:

```graphql
query getAllPNGs {
	transactions(tags: [{ name: "Content-Type", values: ["image/png"] }]) {
		edges {
			node {
				id
				address
			}
		}
	}
}
```

Search for transactions matching the tag with name **Content-Type** and the 
values of **image/png** OR **image/jpg**:

```graphql
query getTagsWithOR {
	transactions(tags: [{ name: "Content-Type", values: ["image/png", "image/jpg"] }]) {
		edges {
			node {
				tags {
					name
					value
				}
			}
		}
	}
}
```

Search for transactions matching the tag with name **Content-Type** and the 
values of **image/png** AND **image/jpg**:

```graphql
query getTagsWithAnd {
	transactions(
		tags: [{ name: "Content-Type", values: ["image/jpg"] }, { name: "Content-Type", values: ["image/png"] }]
	) {
		edges {
			node {
				tags {
					name
					value
				}
			}
		}
	}
}
```

### Limiting Results

Limit the number of results returned by including the `limit` parameter:

```graphql
query getAllPNGs {
	transactions(limit: 10, tags: [{ name: "Content-Type", values: ["image/png"] }]) {
		edges {
			node {
				id
				address
			}
		}
	}
}
```

### Pagination

You can request a maximum of 100 results returned from each query, to obtain 
additional results use pagination.

When using pagination you:

1. Retrieve the `cursor` field. This acts like a bookmark in the search results 
that you can then return to.
2. Use saved `cursor` value to obtain subsequent search results.

The following query returns 10 transactions tagged `image/png` occurring after 
the cursor with value: `LS02d1NsM3R6aUprd3dKUzVjN1FXaWg5aUxsbXh5dVJJbGlydHJtNlpPbw`. 
To obtain the next 10 transactions, use the final `cursor` value returned from 
this query as the value of the `after` parameter in the following query.

```graphql
query getPNGs {
	transactions(
		limit: 10
		tags: [{ name: "Content-Type", values: ["image/png"] }]
		after: "LS02d1NsM3R6aUprd3dKUzVjN1FXaWg5aUxsbXh5dVJJbGlydHJtNlpPbw"
	) {
		edges {
			node {
				id
			}
			cursor
		}
	}
}
```

### Sorting

You can sort results by timestamp in either ascending or descending order using 
the `order` field.

```graphql
query getAllByOwnerAsc {
	transactions(owners: ["0xBcb812C6e26F4F0F78Bd7B6222461FF24F2942AE"], order: ASC) {
		edges {
			node {
				id
				address
			}
		}
	}
}
```

```graphql
query getAllByOwnerDesc {
	transactions(owners: ["0xBcb812C6e26F4F0F78Bd7B6222461FF24F2942AE"], order: DESC) {
		edges {
			node {
				id
				address
			}
		}
	}
}
```


==================== FILE: /workspace/docs/get-started/tooling/permanent-data/irys/irys-quickstart.mdx ====================

---
title: Irys quickstart
image: /img/socialCards/irys-quickstart.jpg
description: Creating permanent data using Irys SDK.
---

Irys makes it easy to store your data onchain by supporting payments with ETH on 
Linea. You can upload data with a single upfront payment, with guaranteed 
retrieval for a duration you set at the upload time — from a few days to forever.

- To upload data, use the Irys [SDK](#irys-sdk) or [CLI](#irys-cli).
- To [download data](#download-data), use the Irys gateway.

## Irys SDK

### Install the SDK

Install using npm:

```bash
npm install @irys/upload @irys/upload-ethereum
```

or yarn:

```bash
yarn add @irys/upload @irys/upload-ethereum
```

### Import 

```ts
import { Uploader } from "@irys/upload";
import { LineaEth } from "@irys/upload-ethereum";
```

### Connect to Irys

#### On the server

When connecting to Irys on the server, provide a private key linked to a wallet 
funded with `linea-eth`. This wallet will be used to pay for uploads and to sign 
transactions.

Using ETH on Linea:

```ts
const getIrysUploader = async () => {
  const irysUploader = await Uploader(LineaEth).withWallet(process.env.PRIVATE_KEY);
  return irysUploader;
};
```

Or use the Irys devnet with Linea Sepolia ETH:

:::note
Uploads to the Irys devnet are purged after 60 days
:::

```ts
const getIrysUploader = async () => {
  const providerUrl = "https://rpc.sepolia.linea.build";
  const irysUploader = await Uploader(Ethereum)
    .withWallet(process.env.PRIVATE_KEY)
    .withRpc(rpcURL)
    .devnet();
 
  return irysUploader;
};
```

#### In the browser

When using Irys in the browser, the wallet browser extension injects a signer 
into the browser. This signer is used to pay for uploads and sign transactions.

Irys supports:

- Ethers v5
- Ethers v6
- Viem v2
- Privy

:::note
The following code example is for Ethers v6. For other providers, [see Irys's 
docs](https://docs.irys.xyz/build/d/irys-in-the-browser).
:::

```js
import { WebUploader } from "@irys/web-upload";
import { WebLineaEth } from "@irys/web-upload-ethereum";
import { EthersV6Adapter } from "@irys/web-upload-ethereum-ethers-v6";
import { ethers } from "ethers";
 
const getIrysUploader = async () => {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const irysUploader = await WebUploader(WebLineaEth).withAdapter(EthersV6Adapter(provider));
 
  return irysUploader;
};
```

### Fund your account

When you use Irys to upload data, you pay once and the data is guaranteed to be 
retrievable forever. The [fee is based on the number of bytes uploaded](https://docs.irys.xyz/build/d/sdk/payment/getPrice).

When calling `fund()` pass a value in atomic units. Use the utility functions 
`utils.toAtomic()` and `utils.fromAtomic()` to convert between atomic and 
standard units.

You can fund up-front, allowing you send over enough tokens to cover all of a 
project's uploads.

```js
try {
  const irysUploader = await getIrysUploader();

  const fundTx = await irysUploader.fund(irysUploader.utils.toAtomic(0.05));
  console.log(
    `Successfully funded ${irysUploader.utils.fromAtomic(fundTx.quantity)} ${
      irysUploader.token
    }`,
  );
} catch (e) {
  console.log("Error funding node ", e);
}
```

Or lazy-fund and fund per upload:

```js
try {
  const irysUploader = await getIrysUploader();

  const pathToFile = "./myNFT.png";
  const { size } = await fs.promises.stat(pathToFile);
  const price = await irysUploader.getPrice(size);
  await irysUploader.fund(price);

  const { id } = await irysUploader.uploadFile(pathToFile);
  console.log(`${pathToFile} --> Uploaded to https://gateway.irys.xyz/${id}`);
} catch (e) {
  console.log("Error funding node ", e);
}
```

### Upload data

```js
const uploadData = async () => {
  const irys = await getIrysUploader();
  const dataToUpload = "GM world.";
  try {
    const tags = [{ name: "Content-Type", value: "text/plain" }];

    const receipt = await irys.upload(dataToUpload, { tags });
    console.log(`Data uploaded ==> https://gateway.irys.xyz/${receipt.id}`);
  } catch (e) {
    console.log("Error uploading data ", e);
  }
};
```

### Upload a file

```js
const uploadFile = async () => {
  const irys = await getIrysUploader();
  const fileToUpload = "./myImage.png";

  const tags = [{ name: "application-id", value: "MyNFTDrop" }];

  try {
    const receipt = await irys.uploadFile(fileToUpload, { tags: tags });
    console.log(`File uploaded ==> https://gateway.irys.xyz/${receipt.id}`);
  } catch (e) {
    console.log("Error uploading file ", e);
  }
};
```

### Upload a folder

You can upload a group of files as a single transaction from both the server and 
the browser.

#### On the server

```js
const uploadFolder = async () => {
  const irysUploader = await getIrysUploader();

  // Upload an entire folder
  const folderToUpload = "./my-images/"; // Path to folder
  try {
    const receipt = await irysUploader.uploadFolder("./" + folderToUpload, {
      indexFile: "", // Optional index file (file the user will load when accessing the manifest)
      batchSize: 50, // Number of items to upload at once
      keepDeleted: false, // Whether to keep now deleted items from previous uploads
    });

    console.log(`Files uploaded. Manifest ID ${receipt.id}`);
  } catch (e) {
    console.log("Error uploading file ", e);
  }
};
```

#### In the browser

```js
const irysUploader = await getIrysUploader();

const files: File[] = [];
const tags: { name: string, value: string }[][] = [];

// Convert Files to TaggedFiles
const taggedFiles = files.map((f: TaggedFile, i: number) => {
  f.tags = tags[i];
  return f;
});

const response = await irysUploader.uploadFolder(taggedFiles);
```

## Irys CLI

### Install the CLI

Install using npm with the `-g` global flag.

```bash
npm i -g @irys/cli
```

Depending on your setup, you may need to use the sudo command.

```bash
sudo npm i -g @irys/cli
```

### Use private keys

When executing CLI commands involving funding nodes or signing transactions, you 
must provide a private key.

Use the `-w` flag to specify a private key along with the -t flag to indicate 
the token you'll use.

```console
irys -w <wallet-file-name> -t linea-eth
```

### Devnet

To use Irys's devnet, where uploads are kept for ~60 days and you pay with Linea 
Sepolia ETH, append `-n devnet` to any of the commands below.

### Fund a node

Use the `fund` command to fund a node.

```console
irys fund 1000000000000000 \
  -t linea-eth \
  -w bf20......c9885307 
```

### Withdraw funds

Use the `withdraw` command to withdraw funds from a node.

```console
irys withdraw 1000000000000000 \
  -t linea-eth \
  -w bf20......c9885307 
```

### Upload a file

Use the `upload` command to upload a file.

```console
irys upload myImage.png \
  -t linea-eth \
  -w bf20......c9885307 \
  --tags tagName1 tagValue1 tagName2 tagValue2 
```

### Upload a folder

Use the `upload-dir` command to upload a folder.

```console
irys upload-dir ./myImages \
  -t linea-eth \
  -w bf20......c9885307 
```

### Use tags

Use the `-t` option, followed by a series of name/value pairs to append metadata 
tags to your upload.

Irys supports adding any optional [metadata tags](./overview.mdx#tagging) to 
each upload. When uploading files with a filename extension, the related
[`Content-Type`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type) 
(MIME type) tag is automatically added.

```console
irys upload myImage.png \
  -t linea-eth \
  -w bf20......c9885307 \
  --tags tagName1 tagValue1 tagName2 tagValue2 
```

### Pricing

Use the `price` command, followed by a number of bytes, to get the cost to 
upload that number of bytes. You must also provide a token (`-t`) and a node 
URL (`-h`).

```console
irys price 1000000 \
  -t linea-eth \
  -n devnet \
  --provider-url https://rpc.sepolia.dev
```

## Download data

When you upload data to Irys, you're given a [receipt](./overview.mdx#receipts)
containing a transaction ID. Use this ID to download your data from the Irys 
gateway by creating a URL in the format:

`https://gateway.irys.xyz/:txId`


==================== FILE: /workspace/docs/get-started/tooling/permanent-data/index.mdx ====================

---
title: Permanent data
image: /img/socialCards/permanent-data.jpg
---

import DocCardList from '@theme/DocCardList';

<DocCardList />


==================== FILE: /workspace/docs/get-started/tooling/social-login/openfort.mdx ====================

---
title: Openfort
image: /img/socialCards/openfort.jpg
---

[Openfort](https://openfort.xyz) provides account abstraction infrastructure designed to simplify 
the development of games and gamified experiences across its suite of API endpoints. 

Authenticated users can instantly access the embedded, non-custodial [smart account](https://openfort.xyz/docs/security#smart-contract-accounts) from within the app context and sign blockchain transactions.

Use the [auth quickstart guide](https://openfort.io/docs/products/kit/react/quickstart) to allow 
social login for onboarding users.


==================== FILE: /workspace/docs/get-started/tooling/social-login/arcana.mdx ====================

---
title: Arcana
image: /img/socialCards/arcana.jpg
---

Web3 devs building on the Linea chain can **onboard users** using the [Arcana Auth SDK](https://arcana.network/auth) through the [social login](https://docs.arcana.network/concepts/social-login) feature. 

The SDK also offers an embedded, non-custodial, built-in web3 wallet, the [Arcana wallet](https://docs.arcana.network/concepts/anwallet/). It allows authenticated users to **sign Linea transactions** within the app context. 

## Onboard users

With Arcana Auth SDK's social login, devs can add a single line of code to onboard users through a plug-and-play login UI via `connect()`. Devs can choose one or more of the available [social login providers and custom login options](https://docs.arcana.network/setup/config-auth/) to manage the user onboarding experience. 

<div class="center-container">
  <div class="img-large">
      <img 
            src="/img/get_started/tooling/social_login/arcana/arcana_social_pnp_modal.png"
            alt="Arcana Social Login Plug & Play UI"
      />
  </div>
</div>

Besides onboarding users, devs can also set up the built-in Arcana wallet to use the preconfigured Linea chain as the default active chain in the wallet. This lets authenticated users access the Arcana wallet and review and sign Linea transactions without manually setting up and configuring a wallet before using the Linea chain.  

To onboard users via social login and enable them to use the Arcana wallet in a web3 app, refer to the [Auth Quickstart Guide](https://docs.arcana.network/quick-start/). 

## Sign Linea transactions

The Arcana wallet is automatically available for signing transactions once a user logs into any app integrated with the [Arcana Auth SDK](https://docs.arcana.network/concepts/authsdk). To access the wallet users need only log in to such an app. They can instantly access the in-app Arcana Wallet and issue transactions or perform supported web3 wallet operations. Users don't need to download, install, or configure a wallet for using the Linea chain.

<div class="center-container">
  <div class="img-large">
      <img 
            src="/img/get_started/tooling/social_login/arcana/arcana_wallet_linea_chain.png"
            alt="Arcana wallet: Linea chain"
      />
  </div>
</div>

## SDK integration

Devs need to follow these *steps* for using social login to onboard users and enabling the Arcana wallet within a web3 app's context:

1. **Register the app** with Arcana Network through the [Arcana Developer Dashboard](https://dashboard.arcana.network/), and copy the unique client identifier (**client ID**) for the app displayed in the dashboard.
2. **Configure Auth SDK usage** via the dashboard:
  - Select social login options.
  - Set up *Linea* as the **default active chain** displayed in thd wallet.
  - Specify wallet usage settings, etc.
  - Configure optional Auth SDK usage settings.
3. **Download and install** the appropriate Auth SDK flavor as per the web3 [app type](https://docs.arcana.network/sdk-installation). 
4. **Integrate the app** by using the *client ID* obtained in step 1. Refer to the specific app type [Auth Integration Guide](https://docs.arcana.network/auth/integrate/wagmi/) for details.

:::note

Devs can set up Linea as the [default active chain](https://docs.arcana.network/setup/config-dapp-with-db/) in the wallet. Refer to the dashboard [chain management settings](https://docs.arcana.network/setup/config-wallet-chains/#evm-chains). 

<div class="center-container">
  <div class="img-large">
      <img 
            src="/img/get_started/tooling/social_login/arcana/dashboard_setup.gif"
            alt="Arcana Developer Dashboard"
      />
  </div>
</div>

:::

Devs can also tailor the user experience of signing blockchain transactions on Linea. Besides the look and feel of the wallet, devs can also manage when the wallet UI is displayed within the app context to sign blockchain 
transactions.

[Learn more](https://docs.arcana.network/user-guides/wallet-ui/).

:::note

The in-app Arcana Wallet supports [JSON-RPC calls and web3 wallet operations](https://docs.arcana.network/auth/web3-ops/evm/).

:::

## Wallet access

Users do not need to download a wallet or manually configure it to use the Linea chain. To access the wallet users must log in to an app that is integrated with the [Arcana Auth SDK](https://arcana.network/auth).

Linea is preconfigured in the blockchain network list displayed in the wallet. Users can sign blockchain transactions within the app context on the Linea chain. This simplifies UX and speeds up user onboarding for a web3 app integrated with the Arcana Auth SDK. 

See [Arcana wallet User Guide](https://docs.arcana.network/user-guides/wallet-ui/) for usage details.


<div class="center-container">
  <div class="img-large">
      <img 
            src="/img/get_started/tooling/social_login/arcana/arcana_wallet_linea.gif"
            alt="Arcana wallet Linea active chain "
      />
  </div>
</div>

## References

* [Social login providers](https://docs.arcana.network/web3-stack/auth/)
* [Blockchain networks](https://docs.arcana.network/web3-stack/chains/)
* [Browsers](https://docs.arcana.network/web3-stack/browsers/)
* [Supported app types](https://docs.arcana.network/web3-stack/apps/)
* [API](https://docs.arcana.network/auth/auth-usage-guide/)
* [Arcana Developer Dashboard](https://dashboard.arcana.network/)


==================== FILE: /workspace/docs/get-started/tooling/social-login/privy.mdx ====================

---
title: Privy
description: >-
  Social login authentication with embedded wallets and flexible OAuth
  configuration options
category: featured
image: /img/socialCards/privy.jpg
---

Privy provides comprehensive social login authentication for web3 applications, enabling users to 
create embedded wallets through familiar social platforms. 

## Supported social providers

Privy supports authentication through many popular social platforms:

- Apple
- Discord
- Farcaster
- GitHub
- Google
- LinkedIn
- Telegram
- TikTok
- X

For X, Privy supports both OAuth 2.0 and OAuth 1.0a authentication flows, providing flexibility 
based on your application's needs.

## How social login works

When users choose social authentication, Privy handles the complete OAuth flow:

1. Provider selection: Users select their preferred social platform
2. OAuth redirect: Secure redirect to the chosen social provider's authentication page
3. Permission approval: Users approve access permissions on the familiar social platform
4. Account creation: Privy creates a user profile linked to their social account
5. Wallet generation: An embedded wallet is automatically created for web3 interactions
6. Token management: Optional OAuth tokens returned for additional API access

## Setup and configuration

### 1. Enable social providers

Configure social authentication in the [Privy Dashboard](https://dashboard.privy.io):

1. Find the "User management" section in the dashboard sidebar
2. Click on "Authentication"
3. Navigate to the "Socials" tab
4. Toggle on any desired social platforms.

### 2. OAuth credential options

Next to each social provider, you can see a dropdown that enables you to access OAuth configuration.
Privy offers two approaches for OAuth configuration:
- Default credentials: Use Privy's pre-configured OAuth credentials for quick setup and testing. This 
  is perfect for development and getting started quickly.
- Custom credentials: Configure your own OAuth applications for production use. This provides better 
  security, branding control, and eliminates shared rate limits.

See the [Privy guide](https://docs.privy.io/basics/get-started/dashboard/configure-login-methods#configure-your-oauth-credentials) 
to learn how to set up OAuth credentials with each provider.

Benefits of custom credentials:
- Your app branding appears on social login screens
- Better security and application control
- Dedicated rate limits for your application
- Enhanced resiliency and reliability

### 3. SDK integration

With configuration done, you can implement the Privy SDK and widget into your dapp.

First, install the Privy SDK:

```bash
npm install @privy-io/react-auth
```

There are many SDK flavours, depending on which language you're using. 

Now wrap your app in the `PrivyProvider`:

```jsx
import { PrivyProvider } from '@privy-io/react-auth';

export default function App() {
  return (
    <PrivyProvider
      appId="your-privy-app-id"
      config={{
        // Configure which login methods to show
        loginMethods: ['email', 'wallet', 'google', 'twitter', 'discord'],
        // Customize the authentication experience
        appearance: {
          theme: 'light',
          accentColor: '#676FFF',
        },
      }}
    >
      {/* Your app components */}
    </PrivyProvider>
  );
}
```

## Resources

- Visit the [Privy Dashboard](https://dashboard.privy.io) to configure social authentication
- Review [OAuth provider setup guides](https://docs.privy.io/basics/get-started/dashboard/configure-login-methods#social-providers) 
  for platform-specific configuration
- Explore [embedded wallets](https://docs.privy.io/guide/react/wallets/embedded) for seamless web3 
  integration
- Check out the [Privy documentation](https://docs.privy.io) for advanced configuration options


==================== FILE: /workspace/docs/get-started/tooling/social-login/index.mdx ====================

---
title: Social login
image: /img/socialCards/social-login.jpg
---


import DocCardList from '@theme/DocCardList';

<DocCardList />


==================== FILE: /workspace/docs/get-started/tooling/social-login/dynamic.mdx ====================

---
title: Dynamic
description: >-
  Social login authentication that combines web2 familiarity with web3
  functionality
category: featured
image: /img/socialCards/dynamic.jpg
---

Dynamic provides seamless social login authentication for web3 applications, enabling users to 
create embedded wallets via sign-in with social platforms.

## Supported social providers

Dynamic supports authentication through many popular social platforms:

- Apple
- Coinbase
- Discord
- Epic Games
- Facebook
- Farcaster
- Github
- Google
- Line
- Shopify
- Spotify
- Telegram
- TikTok
- Twitch
- X

See the [social providers overview](https://docs.dynamic.xyz/social-providers/overview) for a full 
list of options.

## How social login works

When users choose social authentication, Dynamic handles the complete OAuth flow:

1. User selection: Users click their preferred social provider
2. OAuth redirect: Secure redirect to the chosen social platform  
3. Permission approval: Users approve access on the familiar social platform
4. Account creation: Dynamic creates a user profile linked to their social account

Social login creates a profile for the user, but doesn't automatically create an embedded wallet. 
You can set up your Dynamic widget to automatically create an embedded wallet for the user when they
sign in with social. To turn this on, use the toggle on the "Embedded Wallets" section of the 
"Authentication" section in the dashboard.

## Setup and configuration

### 1. Enable social providers

Configure your social authentication options in the [Dynamic Dashboard](https://app.dynamic.xyz/dashboard/log-in-user-profile):

1. Navigate to the "Authentication" section in the sidebar of the dashboard, and then find the "Log 
  in and User Profile" section
2. Toggle on your desired social platforms
3. Configure OAuth credentials for each provider (see [step 2](#2-provider-specific-configuration))
4. Customize the authentication flow (popup vs redirect)

If you want to create an embedded wallet for the user's profile, you first need to turn on 
embedded wallets in the "Authentication" section of the dashboard, and then [configure a CORS origin](https://docs.dynamic.xyz/developer-dashboard/security#allowed-cors-origin) to proceed. Embedded wallets need a CORS origin to function.

### 2. Provider-specific configuration

Each social provider requires OAuth configuration, and this process differs depending on which 
platform you want to enable. 

Detailed setup instructions for each provider are available in the [Dynamic docs](https://docs.dynamic.xyz/social-providers/overview).

### 3. SDK integration

With the configuration complete, you can start to integrate the Dynamic widget into your dapp.

First, install the Dynamic SDK:

```bash
npm install @dynamic-labs/sdk-react-core
```

Then, configure the Dynamic widget:

```jsx
import { DynamicContextProvider } from '@dynamic-labs/sdk-react-core';

export default function App() {
  return (
    <DynamicContextProvider
      settings={{
        environmentId: 'your-environment-id',
        social: { strategy: 'popup' }
      }}
    >
      {/* Your app components */}
    </DynamicContextProvider>
  );
}
```

The `social` prop takes either `popup` or `redirect` to determine how the social login flow should
occur.

## Next steps

- Visit the [Dynamic Dashboard](https://app.dynamic.xyz/dashboard) to configure social 
  authentication
- Review [social provider configurations](https://docs.dynamic.xyz/social-providers/overview) for 
  platform-specific setup
- Explore [embedded wallets](https://docs.dynamic.xyz/wallets/embedded-wallets/dynamic-embedded-wallets) 
  for seamless web3 integration
- Check out the [Dynamic Documentation](https://docs.dynamic.xyz/) for advanced customization 
  options

You can also complement your users' social login with email and SMS authentication, and configure
multi-factor authentication (MFA) with services such as Google Authenticator.


==================== FILE: /workspace/docs/get-started/tooling/oracles/dia.mdx ====================

---
title: DIA
image: /img/socialCards/dia.jpg
---

## Request a custom oracle

[DIA](https://diadata.org/) offers customizable oracles tailored to each
dapp's needs. Each oracle can be customized in several ways, including data
sources, data cleansing filters, pricing and computational methodologies, update
mechanisms and more. This ensures that the data and oracle remain robust and
resilient to the market conditions and provide a global market price as well as
specific individual or cross-chain market prices.

By collecting billions of raw trades directly from over 90 sources, including
CEXs, DEXs, and NFT marketplaces, DIA enables full transparency, customization,
and control throughout the entire value stack. DIA's data and oracle suite
comprise price feeds for 20,000+ assets including cryptocurrencies, NFT
collections, and liquid-staked tokens, as well as random number generation and
other data feed types.

[Request a custom oracle](https://docs.diadata.org/introduction/intro-to-dia-oracles/request-an-oracle).

## Token price feeds

DIA token price feeds provide smart contracts with real-time price information
for [3,000+ cryptocurrencies](https://diadata.org/app/price), sourced
transparently from [90+ trusted, high-volume DEXs and CEXs](https://diadata.org/app/source/defi).

## Access DIA oracles

Here is an example of how to access a price value on DIA oracles:

1. Access your custom oracle smart contract on Linea.
2. Use the "Read" section on the explorer to execute the `getValue(pair_name)`
call, where `pair_name` is the full pair name such as `BTC/USD`.
3. The response of the call contains two values:
    - The current asset price in USD with a fix-comma notation of 8 decimals.
    - The UNIX timestamp of the last oracle update.

[Access DIA's oracle integration samples in Solidity and Vyper languages](https://docs.diadata.org/products/token-price-feeds/access-the-oracle).

## Linea demo price oracles

We have deployed the following demo oracles for the Linea community. They
provide a limited selection of cryptocurrency price feeds with predefined
configuration settings.

:::note
DIA demo oracles are not intended for use in production environments. For a
dedicated, production-ready oracle with custom price feeds and configuration
settings, [request a custom oracle](https://docs.diadata.org/introduction/intro-to-dia-oracles/request-an-oracle).
:::

### Demo oracle smart contracts

<table>
  <thead>
    <tr>
      <th>Network</th>
      <th>Contract address</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Linea Mainnet</td>
      <td><a href="https://lineascan.build/address/0xbb5a4708302ee9d959abc417ca1280abb106ba6a">0xbb5a4708302ee9d959abc417ca1280abb106ba6a</a></td>
    </tr>
  </tbody>
</table>

### Included price feeds

- [DIA/USD](https://diadata.org/app/price/asset/Ethereum/0x84cA8bc7997272c7CfB4D0Cd3D55cd942B3c9419/)
- [BTC/USD](https://diadata.org/app/price/asset/Bitcoin/0x0000000000000000000000000000000000000000/)
- [USDC/USD](https://diadata.org/app/price/asset/Ethereum/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/)

## Supported token API endpoints

DIA also supports API and GraphQL endpoints to return cryptocurrency price data.

[See all API endpoints in our documentation](https://docs.diadata.org/products/token-price-feeds/access-api-endpoints).

# 🎨 NFT floor price feeds

DIA NFT floor price feeds provide smart contracts with real-time price
information of [18,000+ NFT collections](https://diadata.org/app/floor-price), 
sourced on-chain with 100% transparency from [multiple, cross-chain NFT 
marketplaces](https://diadata.org/app/source/nft).

## Supported NFT API endpoints

DIA also supports API endpoints to return cryptocurrency price data. Developers
can directly access the example endpoints listed below or [visit the DIA
Documentation](https://docs.diadata.org/products/nft-floor-price-feeds/access-api-endpoints)
to see all API endpoints.

# Learn more

- [Twitter](https://x.com/DIAdata_org)
- [Discord](https://go.diadata.org/discord-menu)
- [Website](https://diadata.org/)
- [Docs](https://docs.diadata.org/)
- [Explore data](https://diadata.org/app/)


==================== FILE: /workspace/docs/get-started/tooling/oracles/chainlink.mdx ====================

---
title: Chainlink
image: /img/socialCards/chainlink.jpg
---

Chainlink is the industry standard for building, accessing, and selling oracle
services needed to power hybrid smart contracts on any blockchain. Chainlink
oracle networks enable smart contracts to connect to any external API and
leverage secure offchain computations for feature-rich applications. Chainlink
currently secures tens of billions of dollars across DeFi, insurance, gaming,
and other major industries, and offers global enterprises and leading data
providers a universal gateway to all blockchains.

## Chainlink products available on Linea

1. [CCIP](https://docs.chain.link/ccip) (Cross-Chain Interoperability Protocol):
Facilitates secure cross-chain data and token transfers.
2. [Data Feeds](https://docs.chain.link/data-feeds): Connects smart contracts
with real-world data like asset prices, NFT floor prices, and more, enhancing
decentralized applications' functionality and reliability.

:::info
Linea is live on Chainlink Data Feeds. Check out the data feeds [here](https://data.chain.link/) 
and filter by Linea Mainnet!
:::

## Use cases

Popular use cases with Chainlink include:

- Financial services
- DeFi
- Gaming
- NFT collectibles
- Climate markets
- Enterprise
- Insurance


[Learn more about Chainlink use cases through these case studies](https://chain.link/use-cases).

## Official links

- [Website](https://chain.link/)
- [Docs](https://docs.chain.link/)
- [Discord](https://discord.com/invite/aSK4zew)


==================== FILE: /workspace/docs/get-started/tooling/oracles/pyth.mdx ====================

---
title: Pyth Network
image: /img/socialCards/pyth-network.jpg
---

Pyth Network is an oracle that publishes financial market data to multiple
blockchains. Our market data is contributed by over 80 [first-party publishers](https://pyth.network/publishers), including major exchanges and market making firms. We offer price feeds for a number of
different asset classes, including [US equities, commodities, and 
cryptocurrencies](https://pyth.network/price-feeds). Each price feed publishes a
[robust aggregate](https://docs.pyth.network/documentation/how-pyth-works/price-aggregation)
of publisher prices that updates multiple times per second.

## How Pyth works

Pyth allows market participants to publish pricing information onchain for
others to use. The protocol is an interaction between three parties:

- _Publishers_ submit pricing information to Pyth's oracle program. Pyth has
  multiple data publishers for every product to improve the accuracy and
  robustness of the system.
- Pyth's _oracle program_ combines publishers' data to produce a single
  aggregate price and confidence interval.
- _Consumers_ read the price information produced by the oracle program.

## Pyth on-demand model

Pyth Network uses a pull price update model that is slightly different from
other oracles you may be more familiar with. Most oracles today use a push
model, where the oracle runs an offchain process that continuously sends
transactions to update an onchain price. In contrast, Pyth Network doesn't
operate an offchain process that pushes prices onchain. Instead, it delegates
this work to Pyth Network users.

Pyth price updates are created on [Pythnet](https://docs.pyth.network/documentation/how-pyth-works/pythnet)
and streamed offchain via the Wormhole Network, a cross-chain messaging protocol.
These updates are signed such that the Pyth onchain program can verify their
authenticity. Updating the onchain price is a permissionless operation: anyone
can submit a valid Wormhole message to the Pyth contract to update the price.
Typically, users of Pyth Network prices will submit a single transaction that
simultaneously updates the price and uses it in a downstream application.

Onchain prices can only move forward in time. If a user submits a Wormhole
message with an outdated price, the Pyth program will not fail, but will also
not update the price. This means there's no guarantee that when a user
atomically updates the price and then interacts with an application powered by
Pyth, the price that the application will read will be equal to the price the
user submitted.

[Read an in-depth explanation from one of our contributors, Jayant](https://youtube.com/watch?v=qdwrs23Qc9g), and [read more about on-demand updates](https://docs.pyth.network/documentation/pythnet-price-feeds/on-demand).

## Use price feeds

### Price feed IDs

Each Pyth Network price feed has a unique ID. However, the IDs may be
represented in different formats (e.g., hex or base58) depending on the
blockchain. Price feeds also have different IDs in mainnets than testnets or
devnets. The full list of price feeds is listed on the [pyth.network website](https://pyth.network/price-feeds). The [price feed IDs page](https://pyth.network/developers/price-feed-ids) lists the
ID of each available price feed on every chain where they are available. To use
a price feed onchain, look up its ID using these pages, then store the feed ID
in your program to use for price feed queries.

## Pyth on EVM (Linea)

Onchain EVM programs can use the [Solidity SDK](https://github.com/pyth-network/pyth-sdk-solidity) 
to read Pyth prices. The [EVM API reference](https://docs.pyth.network/evm) lets 
you interactively explore the complete API of the Pyth contract.

The offchain portion of the application can use [pyth-evm-js](https://github.com/pyth-network/pyth-crosschain/tree/main/target_chains/ethereum/sdk/js) to generate price update transactions. This 
repository's [quickstart](https://github.com/pyth-network/pyth-crosschain/tree/main/target_chains/ethereum/sdk/js#quickstart) includes an example of both the on- and offchain code necessary 
to integrate with Pyth.

### Examples

View [the example applications](https://github.com/pyth-network/pyth-examples/tree/main/price_feeds)
in the Pyth repository.

### Networks

Pyth is currently available on the following Linea networks:

<table>
  <thead>
    <tr>
      <th>Network</th>
      <th>Contract address</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Linea Mainnet</td>
      <td><a href="https://explorer.linea.build/address/0xA2aa501b19aff244D90cc15a4Cf739D2725B5729">0xA2aa501b19aff244D90cc15a4Cf739D2725B5729</a></td>
    </tr>
    <tr>
      <td>Linea Sepolia</td>
      <td><a href="https://sepolia.lineascan.build/address/0xA2aa501b19aff244D90cc15a4Cf739D2725B5729">0xA2aa501b19aff244D90cc15a4Cf739D2725B5729</a></td>
    </tr>
  </tbody>
</table>

### Price feed IDs

The price feed IDs for EVM chains differs depending on whether they are a
mainnet or testnet (see above):

- [List of mainnet IDs](https://pyth.network/developers/price-feed-ids#pyth-evm-mainnet)
- [List of testnet IDs](https://pyth.network/developers/price-feed-ids#pyth-evm-testnet)

## Links

- [X](https://x.com/PythNetwork)
- [Discord](https://discord.com/invite/PythNetwork)
- [Website](https://pyth.network/)
- [Docs](https://docs.pyth.network/documentation)


==================== FILE: /workspace/docs/get-started/tooling/oracles/api3.mdx ====================

---
title: API3
image: /img/socialCards/api3.jpg
---

[API3](https://api3.org/) is a collaborative project to deliver traditional API
services to smart contract platforms in a decentralized and trust-minimized way.  Its primary focus
is to bring cryptocurrency price data to smart contracts in a secure and reliable manner.  API3 price feeds
have [OEV](https://docs.api3.org/oev-searchers/) (Oracle Extractable Value) built in to the price feeds by default, this allows dapps to 
monetize the update of the price feeds they are using.  It is governed by a decentralized autonomous organization (DAO).

:::info

Read more about how The API3 DAO works. 
[Click here](https://api3.org/dao/)

:::

## Using dAPIs - API3 datafeeds

[dAPIs](https://docs.api3.org/dapps/quickstart/) are continuously
updated streams of offchain cryptocurrency price data. They can power various decentralized applications such as DeFi
lending, synthetic assets, stablecoins, derivatives, NFTs and more.

The data feeds are continuously updated by first party oracles using signed data. Dapp owners can read the onchain value of any dAPI in 
real-time.

Due to being composed of first-party data feeds, dAPIs offer security,
transparency, cost-efficiency and scalability in a turn-key package.

Apart from relying on deviation threshold and heartbeat configuration updates,
unlike traditional data feeds, [OEV Network](https://docs.api3.org/oev-searchers/in-depth/oev-network/)
enables dapps using dAPIs to auction off the right to update the data feeds to
searcher bots. Searcher bots can bid for price updates through the OEV Network
to update the data feeds. All the OEV proceeds go back to the dapp.

The [API3 Market](https://market.api3.org/linea) enables users to connect to a
dAPI and access the associated data feed services.

<div class="center-container">
  <div class="img-large">
      <img
        src="/img/get_started/tooling/oracles/api3/dapi-main.png"
        alt="dapi-main"
      />
  </div>
</div>


[Learn more about how dAPIs work](https://docs.api3.org/oev-searchers/in-depth/dapis/).

### Subscribe to dAPIs

The [API3 Market](https://market.api3.org/linea) lets users access dAPIs on both
[Linea Mainnet](https://market.api3.org/linea) and [testnet](https://market.api3.org/linea-sepolia-testnet).

#### Explore, select and configure your dAPI

The [API3 Market](https://market.api3.org/linea) provides a list of all the
dAPIs available across multiple chains including testnets. You can filter the
list by mainnet or testnet chains. After selecting the chain, you can search for
a specific dAPI by name. Once selected, you will land on the details page (eg
ETH/USD on Linea Testnet) where you can find more information about the dAPI.

The current supported configurations for dAPIs are:

| Deviation | Heartbeat |
| --------- | --------- |
| 0.25%     | 24 hours  |
| 0.5%      | 24 hours  |
| 1%        | 24 hours  |
| 5%        | 24 hours  |

<div class="center-container">
  <div class="img-large">
      <img
        src="/img/get_started/tooling/oracles/api3/dapi-1.png"
        alt="dapi-1"
      />
  </div>
</div>

#### Activate your dAPI

:::note

If a dAPI is already activated, make sure to check the expiration date and
update parameters. You can update the parameters and extend the subscription by
purchasing a new configuration.

:::

After selecting the dAPI and the configuration, you will be presented with an
option to purchase the dAPI and activate it. Make sure to check the time and
amount of the subscription. If everything looks good, click "Purchase".

<div class="center-container">
  <div class="img-small">
      <img
        src="/img/get_started/tooling/oracles/api3/dapi-2.png"
        alt="dapi-2"
      />
  </div>
</div>

You can then connect your wallet and confirm the transaction. Once it's
confirmed, you will be able to see the updated configuration for the dAPI.

#### Get the proxy address

Once you are done configuring and activating the dAPI, you can now integrate it.
To do so, click on the "Integrate" button on the dAPI details page.

<div class="center-container">
  <div class="img-large">
      <img
        src="/img/get_started/tooling/oracles/api3/dapi-5.png"
        alt="dapi-5"
      />
  </div>
</div>

You can now see the deployed proxy contract address. You can now use this to
read from the configured dAPI.

### Read from a dAPI

Here's an example of a basic contract that reads from a dAPI.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "@openzeppelin/contracts@4.9.5/access/Ownable.sol";
import "@api3/contracts/api3-server-v1/proxies/interfaces/IProxy.sol";

contract DataFeedReaderExample is Ownable {
    // The proxy contract address obtained from the API3 Market UI.
    address public proxyAddress;

    // Updating the proxy contract address is a security-critical
    // action. In this example, only the owner is allowed to do so.
    function setProxyAddress(address _proxyAddress) public onlyOwner {
        proxyAddress = _proxyAddress;
    }

    function readDataFeed()
        external
        view
        returns (int224 value, uint256 timestamp)
    {
        // Use the IProxy interface to read a dAPI via its proxy contract .
        (value, timestamp) = IProxy(proxyAddress).read();
        // If you have any assumptions about `value` and `timestamp`,
        // make sure to validate them after reading from the proxy.
    }
}

```

- `setProxyAddress()` is used to set the address of the dAPI Proxy Contract.

- `readDataFeed()` is a view function that returns the latest price of the set
dAPI.

[Read more about dAPIs](https://docs.api3.org/oev-searchers/in-depth/dapis/).

> 
[Try deploying it on Remix!](https://remix.ethereum.org/#url=https://github.com/api3-ecosystem/remix-contracts/blob/master/contracts/DapiReader.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.18+commit.87f61d96.js)

## Resources

Here are some additional developer resources:

- [API3 docs](https://docs.api3.org/)
- [API3 Market](https://market.api3.org/linea)
- [dAPI docs](https://docs.api3.org/oev-searchers/in-depth/dapis/)
- [OEV docs](https://docs.api3.org/oev-searchers/)
- [Github](https://github.com/api3dao/)
- [Medium](https://medium.com/api3)
- [YouTube](https://youtube.com/API3DAO)


==================== FILE: /workspace/docs/get-started/tooling/oracles/redstone.mdx ====================

---
title: RedStone
image: /img/socialCards/redstone.jpg
---

RedStone provides data feeds with update times of less than 10 seconds, suitable
for various DeFi applications such as lending, perpetuals, options,
derivatives, and stablecoins. The infrastructure is used on mainnets and by
several protocols in the DeFi space.

:::tip
Learn more about how to integrate RedStone Oracles in the [official Redstone
documentation](https://docs.redstone.finance/).
:::

## Links

- [Twitter](https://x.com/redstone_defi)
- [Discord](https://redstone.finance/discord)
- [Website](https://redstone.finance/)
- [Docs](https://docs.redstone.finance/)


==================== FILE: /workspace/docs/get-started/tooling/oracles/tellor.mdx ====================

---
title: Tellor
description: >-
  A versatile oracle protocol that can provide data of any type permissionlessly
  with crypto-economic liveness and security.
image: /img/socialCards/tellor.jpg
---

Rather than just providing arbitrary price data, the Tellor oracle is a protocol 
for answering verifiable onchain queries of any format. The Tellor protocol 
incentivizes an open, permissionless network of data reporting and data 
validation, ensuring that data can be provided by anyone and checked by everyone.
Built for any data type, our network of reporters supports your basic spot 
prices, more sophisticated pricing specs (TWAP/VWAP), RNG, or any custom data 
needs you have. If your data can be verified, Tellor can bring it onchain.

## How it works

The oracle mechanism works by using simple crypto-economic incentives to secure 
data through staking and dispute mechanisms, while the protocol is bound by a 
token which utilizes governance and monetary incentives to reward data reporters 
and development of the network.

At a high level, Tellor is an oracle system where a bonded set of “reporters” 
answer questions onchain for others to use freely. To create a properly 
incentivized system, Tellor mints a native token, “Tributes” (TRB). Rewards in 
TRB incentivize reporters to submit data using peer-to-peer payments. Using TRB, 
parties can “tip” a specific question or “query” they want updated, then 
reporters can choose whether the reward for fetching the data is worth the cost 
of placing the value onchain. The security of Tellor comes through a deposit of 
TRB that acts as a bond or stake requirement in order for reporters to 
participate in providing data. The reporters risk losing this stake if they 
submit data that is successfully disputed.

## Get started

Use the [UsingTellor](https://github.com/tellor-io/usingtellor) helper contract
to use Tellor data. After connecting it to the oracle you can read a value using 
your `queryid`. Follow the guides in our [documentation](https://docs.tellor.io) 
for further instruction.


> **Looking for help getting started?** Ask us anything in the developers' channel of our [Discord server](https://discord.gg/tellor).

## Request data feeds

Tellor's network of data reporters already actively supports a large variety of 
price/data feeds and adding new ones upon request can happen with a quick 
turnaround. You can even do it permissionlessly. For both price feed requests 
and non-price/custom feeds, anyone can submit a data specification and get their 
query supported by Tellor.  

- [Current price feeds](https://github.com/tellor-io/telliot-feeds/tree/main/src/telliot_feeds/feeds)
- [New data request form](https://github.com/tellor-io/dataSpecs/issues/new?assignees=&labels=&template=new_query_type.yaml&title=%5BNew+Query+Type%5D%3A+)
- [Custom data type examples](https://github.com/tellor-io/dataSpecs/tree/main/types)

## Tellor contracts on Linea

### Linea Sepolia

- Token: [0x34Fae97547E990ef0E05e05286c51E4645bf1A85](https://sepolia.lineascan.build/address/0x34Fae97547E990ef0E05e05286c51E4645bf1A85)
- Oracle: [0xC7199e0686DF9844B511fAf2796C518F6D7292EB](https://sepolia.lineascan.build/address/0xC7199e0686DF9844B511fAf2796C518F6D7292EB)
- Governance: [0xB3bB03eA894C609C8560Af3d8726556f52140a39](https://sepolia.lineascan.build/address/0xB3bB03eA894C609C8560Af3d8726556f52140a39)
- Autopay: [0x02FB285409Cec68EE12183cc3035a090A456f66C](https://sepolia.lineascan.build/address/0x02FB285409Cec68EE12183cc3035a090A456f66C)

### Linea Mainnet

- Token: [0x35482B93941B439dEA2244Cc30A20D1Ed862DF86](https://lineascan.build/token/0x35482b93941b439dea2244cc30a20d1ed862df86)
- Oracle: [0x896419Ed2E0dC848a1f7d2814F4e5Df4b9B9bFcc](https://lineascan.build/address/0x896419ed2e0dc848a1f7d2814f4e5df4b9b9bfcc#code)
- Governance: [0xC866DB9021fe81856fF6c5B3E3514BF9D1593D81](https://lineascan.build/address/0xC866DB9021fe81856fF6c5B3E3514BF9D1593D81)
- Autopay: [0x9EA18BFDB50E9bb4A18F9d3Df7804E398F8fE0dc](https://lineascan.build/address/0x9EA18BFDB50E9bb4A18F9d3Df7804E398F8fE0dc)



==================== FILE: /workspace/docs/get-started/tooling/oracles/index.mdx ====================

---
title: Oracles
image: /img/socialCards/oracles.jpg
---


import DocCardList from '@theme/DocCardList';

<DocCardList />


==================== FILE: /workspace/docs/get-started/tooling/oracles/umbrella.mdx ====================

---
title: Umbrella Network
image: /img/socialCards/umbrella-network.jpg
---

Umbrella Network is a decentralized oracle service that provides blockchain 
projects with secure, scalable, and customizable data solutions.

Umbrella offers smart contracts a broad suite of solutions. It can provide any 
type of price feed, whether for custom needs, high frequency pricing updates, or 
aggregating large volumes of data at scale. Secured by a network of 
decentralized community validators, Umbrella can provide any data that you need 
when you need it.

Umbrella can create any custom price feed for your project. [Contact us](https://umb.network/contact#form).

## Solutions

At Umbrella, we are committed to providing simple solutions for using offchain 
data onchain. We understand that different projects have unique requirements. 
That's why we offer several ways to consume data:

### Onchain data

For projects that need their custom data feeds onchain, with defined parameters 
such as deviation triggers and heartbeat. This solution is suitable for vault 
tokens, volatility monitoring, TWAPs, and more. 

These are the price feeds available on Linea Mainnet and their configuration:

- ETH-USD
  - Deviation threshold: 0.5%
  - Heartbeat: 1 hour
- USDT-USD
  - Deviation threshold: 1%
  - Heartbeat: 6 hours
- USDC-USD
  - Deviation threshold: 1%
  - Heartbeat: 6 hours

> You can expect some delays on the update of the price feeds on chain as 
validators on the Umbrella Network complete their upgrades.

If you need another price feed, [contact us](https://umb.network/contact#form).

Check our technical documentation at the bottom of this page to get the 
Umbrella's Registry contract address on Linea.

### Layer 2 data

For projects that need data secured onchain at scale, our layer 2 data solution 
is the answer. Whether you're in the DeFi space, prediction markets, or 
building data-heavy web3 solutions, we ensure your data is secure and readily 
available to support your applications.

### On-demand data

For projects that require high-frequency data. Signed offchain data can be 
written into any smart contract on demand. This feature is suitable for 
high-frequency perpetual futures or spot-trading platforms where timing is 
crucial. Access the data you need, precisely when you need it.

## Technical documentation

- [Technical documentation](https://umbrella-network.github.io/technical-documentation/umbrella-network/docs/getting-started-1.html)
- [Reference documentation](https://umbrella-network.readme.io/reference

## Follow Umbrella Network

[Discord](https://discord.com/invite/AHHSM7Bks2) | [Twitter](https://x.com/UmbNetwork) | [Announcements](https://t.me/umbnetannouncement) | [Website](https://umb.network/) | [Governance](https://umb.network/community)


==================== FILE: /workspace/docs/get-started/tooling/oracles/ora.mdx ====================

---
title: ORA
image: /img/socialCards/ora.jpg
---

[ORA](https://ora.io) is a verifiable oracle protocol that brings AI and complex
compute onchain. 

Its main product, **Onchain AI Oracle (OAO)**, integrates AI capabilities
directly onchain.

ORA breaks down the limitations of smart contracts by offering verifiable AI
inference, so developers can innovate freely.

## OAO quickstart

This quickstart is designed to help you build a smart contract on Linea able
to interact with OAO. [See more details in our docs](https://docs.ora.io/doc/oao-onchain-ai-oracle/develop-guide).

### Workflow

1. The user contract sends the AI request to OAO on Linea by calling the
`requestCallback` function on the OAO contract.
2. Each AI request will initiate an opML inference.
3. OAO will emit a `requestCallback` event that will be collected by opML node.
4. The opML node will run the AI inference, and then upload the result on Linea,
waiting for the challenge period.
    1. During the challenge period, the opML validators will check the result, 
    and challenge it if the submitted result is incorrect.
    2. If the submitted result is successfully challenged by one of the 
    validators, the submitted result will be updated on Linea.
    3. After the challenge period, the submitted result on chain is finalized.
5. When the result is uploaded or updated on Linea, the provided AI inference in
opML will be dispatched to the user's smart contract via its specific callback
function.

## Integration

### Overview

To integrate with OAO, you will need to write your own contract.

To build with AI models of OAO, we provided an example of contract using OAO: 
[Prompt](https://lineascan.build/address/0xC20DeDbE8642b77EfDb4372915947c87b7a526bD).

### Smart contract integration

1. Inherit `AIOracleCallbackReceiver` in your contract and bind with a specific
OAO address:

```solidity
constructor(IAIOracle _aiOracle) AIOracleCallbackReceiver(_aiOracle) {}
```

2. Write your callback function to handle the AI result from OAO. Note that only
OAO can call this function:

```solidity
function aiOracleCallback(uint256 requestId, bytes calldata output, bytes calldata callbackData) external override onlyAIOracleCallback()
```

3. When you want to initiate an AI inference request, call OAO as follows:

```solidity
aiOracle.requestCallback(modelId, input, address(this), gas_limit, callbackData);
```

## Reference

Two models are available on Linea: Stable Diffusion (ID: 50) and Llama3 8B
Instruct (ID: 11).

[Prompt](https://docs.ora.io/doc/oao-onchain-ai-oracle/reference) and 
[SimplePrompt](https://docs.ora.io/doc/oao-onchain-ai-oracle/reference) are both
example smart contracts that interact with OAO.

For simpler application scenarios (eg. prompt engineering-based AI like GPTs),
you can directly use Prompt or SimplePrompt.

SimplePrompt saves gas by only emitting the event without storing historical
data.

Linea Mainnet contracts: 

- OAO Proxy: [0x0A0f4321214BB6C7811dD8a71cF587bdaF03f0A0](https://lineascan.build/address/0x0A0f4321214BB6C7811dD8a71cF587bdaF03f0A0)
- Prompt: [0xC20DeDbE8642b77EfDb4372915947c87b7a526bD](https://lineascan.build/address/0xC20DeDbE8642b77EfDb4372915947c87b7a526bD)
- SimplePrompt: [0xC3287BDEF03b925A7C7f54791EDADCD88e632CcD](https://lineascan.build/address/0xC3287BDEF03b925A7C7f54791EDADCD88e632CcD)

## Useful links:

- Read [ORA documentation](https://docs.ora.io)
- [Join our Discord](https://discord.gg/ora-io) for help from our team
- Follow us [on X](https://x.com/OraProtocol)


==================== FILE: /workspace/docs/get-started/tooling/oracles/supra.mdx ====================

---
title: Supra
image: /img/socialCards/supra.jpg
---

[Supra](https://supraoracles.com/) is a novel, high-throughput oracle and 
IntraLayer: a vertically integrated toolkit of cross-chain solutions (data 
oracles, asset bridges, automation network, and more) that interlink all 
blockchains, public (L1s and L2s) or private (enterprises).

Supra provides decentralized oracle price feeds that can be used for onchain and 
offchain use-cases such as spot and perpetual DEXs, lending protocols, and 
payments protocols. Supra's oracle chain and consensus algorithm makes it the 
fastest-to-finality oracle provider, with layer-1 security guarantees. The pull 
oracle has a sub-second response time. Aside from speed and security, Supra's 
rotating node architecture gathers data from 40+ data sources and applies a 
robust calculation methodology to get the most accurate value. The node 
provenance on the data dashboard also provides a fully transparent historical 
audit trail. Supra's Distributed Oracle Agreement (DORA) paper was accepted into 
ICDCS 2023, the oldest distributed systems conference.

[Check out our developer docs](https://docs.supra.com/oracles/overview).


==================== FILE: /workspace/docs/get-started/tooling/analytics/arkham.mdx ====================

---
title: Arkham
image: /img/socialCards/arkham.jpg
---

[Arkham](https://platform.arkhamintelligence.com/) is a crypto intelligence platform that 
systematically analyzes blockchain transactions, showing users the people and companies behind 
blockchain activity, with a suite of advanced tools for analyzing their activity.

Access Arkham [here](https://platform.arkhamintelligence.com/).

References:

- [Platform guide](https://arkhamintelligence.notion.site/Arkham-eb1213a42ae24fe39643bd737f4ae78e)
- [Whitepaper](https://arkhamintelligence.com/whitepaper)
- [Codex](https://codex.arkhamintelligence.com/)
- [Demos](https://youtube.com/@arkhamintel)


==================== FILE: /workspace/docs/get-started/tooling/analytics/mobula.mdx ====================

---
title: Mobula
image: /img/socialCards/mobula.jpg
---

[Mobula](https://docs.mobula.io) serves is a specialized data layer offering analytics 
capabilities. It is designed to streamline and enhance data analysis processes, ensuring users have 
access to precise, actionable insights. It's aimed at enhancing data-driven decision-making for 
users seeking to optimize their strategies.

## Why Mobula?

- **Data aggregation and analytics**: Aggregating vast datasets to provide a rich, unified view of 
information, the analytics engine of [Mobula](https://mobula.io) enables analysis that helps unveil 
critical patterns, trends, and insights. This supports informed decision-making by offering a 
comprehensive view of data.

- **User experience and functionality**: The platform prioritizes user experience with an intuitive 
interface, simplifying data analysis. It caters to users at all levels, making advanced data 
processing accessible and reducing the learning curve for effective data utilization.

- **Strategic insight generation**: By transforming complex datasets into actionable insights, this 
platform aids in streamlining decision-making across various contexts. It empowers users to uncover 
opportunities and tackle challenges, steering operational improvements and driving innovation 
strategies.

&nbsp;

<div class="center-container">
  <div class="img-large">
    <img
      src="https://metacore.mobula.io/Capture%20d%E2%80%99e%CC%81cran%202024-04-03%20a%CC%80%2013.36.18.png"
      alt="Mobula Analytics"
    />
  </div>
</div>

## Get started

Transform data into actionable insights with [Mobula's](https://docs.mobula.io) analytics.

Create a room with Mobula core team **[here](https://t.me/MobulaPartnerBot?start=Linea_Docs_Analytics)**

**Additional resources:**

- **[Dive into the documentation](https://docs.mobula.io)** - Delve into [Mobula's](https://docs.mobula.io) 
documentation, from detailed API guidelines to thorough tutorials.

- **[Explore the Mobula app](https://mobula.io)** - Access analytics with the [Mobula](https://mobula.io) 
app, designed for ease of integration and enriched with powerful data insights.

**X:** https://x.com/MobulaIO

**Telegram:** https://t.me/MobulaFI


==================== FILE: /workspace/docs/get-started/tooling/analytics/index.mdx ====================

---
title: Analytics
image: /img/socialCards/analytics.jpg
---

import DocCardList from '@theme/DocCardList';

<DocCardList />


==================== FILE: /workspace/docs/get-started/tooling/analytics/dune.mdx ====================

---
title: Dune
image: /img/socialCards/dune.jpg
---

[Dune](https://dune.com/) is crypto's data platform. Teams and individuals alike use Dune to explore, 
query, access, and export blockchain data. Dune's community of data engineers, researchers, and 
analysts use the platform to gain deeper insights into blockchain activity. Dune provides organized, 
decoded and human-readable blockchain data, across 15+ chains and 1.5M datasets.  

## Features

- **Data exploration**: Dune Analytics allows you to explore and analyze blockchain data using SQL 
queries. You can easily filter, aggregate, and visualize data to gain insights into blockchain 
activity.
- **Dashboards**: Create interactive dashboards to monitor key metrics and visualize data trends,
with drag-and-drop interface for designing custom dashboards.
- **Collaboration**: Share your queries, dashboards, and insights with others. Dune Analytics 
supports collaboration features, allowing you to work together with your team or the wider community.
- **API access**: Access blockchain data programmatically using Dune's API. You can integrate 
blockchain data into your applications, tools, and services.
- **Snowflake datashare**: Dune's Snowflake datashare allows you to access and analyze blockchain 
data directly in your Snowflake account. You can query and join blockchain data with your existing 
datasets in Snowflake.

## Resources

Here are some resources to help you learn more about Dune Analytics:

- [Documentation](https://docs.dune.com/): The official documentation provides detailed guides and 
tutorials on using Dune Analytics.
- [API Docs](https://docs.dune.com/api): The API documentation provides detailed information on how 
to access blockchain data programmatically using Dune's API.
- [YouTube](https://youtube.com/@dunecom) : The Dune YouTube channel features video tutorials 
and demos of the platform.
- [Blog](https://dune.com/blog): The Dune blog features articles, case studies, and updates about 
the platform.
- [Twitter](https://x.com/duneanalytics): Follow Dune Analytics on Twitter for the latest 
news and announcements.


==================== FILE: /workspace/docs/get-started/tooling/analytics/cookie3.mdx ====================

---
title: Cookie3
image: /img/socialCards/cookie3.jpg
---

[Cookie3](https://cookie3.co/) is like Google Analytics, but for web3. It allows you to 
analyze every visitor and wallet on your website, including campaigns and customer journey 
exploration features.

## Benefits

### Understand user attribution

- Gain insight into the complete web3 user journey, from their initial interaction to their 
transactions in your dapp.
- Understand on-chain activity, including preferred dapps or NFT collections, portfolio value or 
favorite wallet.
- Leverage user segmentation for targeted engagement and personalized experiences.

### Meet marketing KPIs

- Improve your marketing KPIs by blending offchain and onchain data. Use metrics like cost per 
NFT mint, token sales, website visits, and more.
- Monitor your KPIs over time to see when you make progress.
- Sort UTM links tailored for each marketing campaign to assess their effectiveness. Utilize these 
insights to strategically allocate your budget across the most impactful marketing channels.

### Grow your user base

- Enhance your understanding of user preferences and interests by intersecting onchain data with 
website traffic and demographics.
- Identify and engage with specific user segments by understanding their interactions with dapps, 
tokens, and NFTs.
- Gain valuable insights into user behavior within your Discord community, enabling tailored live
events, product launches, and giveaways.

## Additional resources

1. [One-minute YouTube explainer](https://youtube.com/@Cookie3_com)
2. [Documentation](https://docs.cookie3.co/)


==================== FILE: /workspace/docs/get-started/tooling/libraries/ape.mdx ====================

---
title: Ape Framework
image: /img/socialCards/ape-framework.jpg
---

Ape Framework is an easy-to-use web3 development tool. Users can compile, test,
and interact with smart contracts, all in one command line session. With a
modular plugin system, Ape supports multiple contract languages and chains,
including Linea.

Ape is built by [ApeWorX LTD](https://apeworx.io/).

The Linea team developed the [plugin to add Linea support to Ape](https://github.com/Consensys/ape-linea).

See the [Ape docs](https://docs.apeworx.io/ape/stable/index.html) for more
information.


==================== FILE: /workspace/docs/get-started/tooling/libraries/ethereum-list.mdx ====================

---
title: ethereum-lists/chains
image: /img/socialCards/ethereum-listschains.jpg
---

# `ethereum-lists/chains`

Linea Mainnet and Linea Sepolia are listed on the official
`ethereum-lists/chains` repository that is pulled by many cross-chain projects
like Chainlist.org, Thirdweb, and Cookbook.dev.

You can access different key parameters for the Linea chains, such as:

1. `chainId`
2. RPC Endpoints
3. Native currency settings
4. Block explorers
5. ENS information
6. Network icons

See the official repo here:

- [Linea Mainnet](https://github.com/ethereum-lists/chains/blob/master/_data/chains/eip155-59144.json)
- [Linea Sepolia](https://github.com/ethereum-lists/chains/blob/master/_data/chains/eip155-59141.json)


==================== FILE: /workspace/docs/get-started/tooling/libraries/reown.mdx ====================

---
title: Reown
image: /img/socialCards/reown.jpg
---

Use the Reown protocol to enable users from a multitude of wallets to log into decentralized 
applications. Linea is now listed inside chain list for any project configuration on 
[Reown Cloud](https://cloud.reown.com/).

To learn more about Reown, take a look at the [official page](https://reown.com/).


==================== FILE: /workspace/docs/get-started/tooling/libraries/wagmi.mdx ====================

---
title: Wagmi
image: /img/socialCards/wagmi.jpg
---

Wagmi is a collection of React hooks containing everything you need to start
working with Linea.

Wagmi makes it easy for users to connect their wallet, display ENS names and
balance information, sign messages, interact with contracts, and much more — all
with caching, request deduplication, and persistence. Wagmi supports Linea
(along with MetaMask).

To point to your dapp on Linea, use the chain tag `lineaSepolia` for Linea
Sepolia and `linea` for Linea Mainnet.

For specifics, [see the docs](https://wagmi.sh/core/chains#supported-chains).

[Visit the Wagmi docs](https://wagmi.sh/) for more information.


==================== FILE: /workspace/docs/get-started/tooling/libraries/ethers-js.mdx ====================

---
title: Ethers.js
image: /img/socialCards/ethersjs.jpg
---

The ethers.js library aims to be a complete and compact library for interacting
with the Ethereum blockchain and its ecosystem — including Linea, due to its
EVM-equivalence. Ethers.js simplifies Ethereum development, enhances code
quality, and provides a modern and efficient alternative to older Ethereum
development libraries.

To learn more about ethers.js take a look at the official [documentation](https://docs.ethers.org/v6/).


==================== FILE: /workspace/docs/get-started/tooling/libraries/web3j.mdx ====================

---
title: Web3j
description: A web3 Java library that supports Linea-specific RPC methods.
image: /img/socialCards/web3j.jpg
---

[Web3j](https://web3labs.com/web3j-sdk) is a lightweight, modular, and open-source Java library 
designed for EVM blockchains. Since Linea is EVM-equivalent, it is completely compatible with 
Web3j. 

Web3j supports Linea-specific RPC methods:
- [`linea_estimateGas`](../../../api/reference/linea-estimategas.mdx) can be called using
`lineaEstimateGas()`
- [`linea_getProof`](../../../api/reference/linea-getproof.mdx) can be called using `lineaGetProof()`
- [`linea_getTransactionExclusionStatusV1`](../../../api/reference/linea-gettransactionexclusionstatusv1.mdx) can be called using `lineaGetTransactionExclusionStatusV1()`.

To get started, visit the [documentation](https://docs.web3j.io/latest/quickstart/), or [read more](https://lfdecentralizedtrust.org/blog/full-linea-rpc-apis-support-in-web3j) 
about using the Linea-specific RPC methods.


==================== FILE: /workspace/docs/get-started/tooling/libraries/index.mdx ====================

---
title: Libraries
image: /img/socialCards/libraries.jpg
---

import DocCardList from "@theme/DocCardList";

<DocCardList />


==================== FILE: /workspace/docs/get-started/tooling/libraries/viem.mdx ====================

---
title: Viem
image: /img/socialCards/viem.jpg
---

Viem offers a TypeScript interface for Ethereum that provides low-level
stateless features for interactions focused on reliability, performance, and
developer experience.

To point to your dapp on Linea, you need to use

```
import { linea, lineaSepolia } from 'viem/chains'
```

For more specifics, [see the docs](https://viem.sh/docs/chains/introduction).


==================== FILE: /workspace/docs/get-started/tooling/libraries/multicall.mdx ====================

---
title: MulticallV3
image: /img/socialCards/multicallv3.jpg
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Multicall aggregates results from multiple contract constant function calls.

This reduces the number of separate JSON RPC requests that need to be sent,
which is especially useful if using remote nodes like Infura. This guarantees
that all values returned are from the same block (like an atomic read) and
return the block number the values are from (giving them important context so
that results from old blocks can be ignored if they're from an out-of-date
node).

<Tabs className="my-tabs">
  <TabItem value="Mainnet" label="Mainnet">

The Multicall contract V3 is deployed on Linea Mainnet at the standard contract
address: [0xcA11bde05977b3631167028862bE2a173976CA11](https://explorer.linea.build/address/0xcA11bde05977b3631167028862bE2a173976CA11)

</TabItem>
 <TabItem value="Linea Sepolia" label="Sepolia">

The Multicall contract V3 is deployed on Linea Sepolia at the standard contract 
address: [0xcA11bde05977b3631167028862bE2a173976CA11](https://sepolia.lineascan.build/address/0xca11bde05977b3631167028862be2a173976ca11)

 </TabItem>
</Tabs>

[View the official repo of the project](https://github.com/mds1/multicall).


==================== FILE: /workspace/docs/get-started/tooling/contracts-templates/cookbook.mdx ====================

---
title: Cookbook.dev
image: /img/socialCards/cookbookdev.jpg
---

[Cookbook.dev](https://contracts.cookbook.dev/) is an open-source smart contract registry 
where developers can find Solidity primitives, libraries, and smart contracts for protocols.

## Search the smart contract registry

Navigate to [contracts.cookbook.dev/chains/Linea](https://contracts.cookbook.dev/chains/Linea) and 
explore protocols on Linea, or search for specific smart contracts in the search bar.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/how_to/deploy_smart_contract/cookbook/Linea_deploy_smart_contract_Cookbook_1.png"
      alt="Cookbook Search"
    />
  </div>
</div>

To learn about a smart contract on Cookbook, select the protocol, and select "Expand". This opens 
the code alongside ChefGPT, Cookbook's AI Solidity assistant.

Highlight selections of the code and press "Analyze Snippet" to get more information, or ask ChefGPT 
questions about Linea, Solidity, or your smart contract.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/how_to/deploy_smart_contract/cookbook/Linea_deploy_smart_contract_Cookbook_2.png"
      alt="Cookbook Analyze Code Snippet"
    />
  </div>
</div>

## Import smart contract code

Import verified smart contract code into Cookbook to fork, learn about, or build with by inputting 
any smart contract address into the Cookbook search bar.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/how_to/deploy_smart_contract/cookbook/Linea_deploy_smart_contract_Cookbook_3.png"
      alt="Cookbook Import Contract"
    />
  </div>
</div>

## Find smart contracts within the Remix IDE with the Cookbook plugin

Go to [Remix.Ethereum.org](https://remix.ethereum.org/#activate=cookbookdev).

Add the Cookbook plugin to Remix by clicking the chef hat logo under **Featured Plugins** on the 
Remix Homepage.

<div class="center-container">
  <div class="img-medium">
      <img
      src="/img/get_started/how_to/deploy_smart_contract/cookbook/Linea_deploy_smart_contract_Cookbook_8.png"
      alt="Cookbook Remix Featured Plugin"
    />
  </div>
</div>

Alternatively, search Cookbook and select "Activate" in the Remix Plugin Manager.

<div class="center-container">
  <div class="img-small">
      <img
      src="/img/get_started/how_to/deploy_smart_contract/cookbook/Linea_deploy_smart_contract_Cookbook_9.png"
      alt="Cookbook Remix Add Plugin"
    />
  </div>
</div>

Search for any protocol or smart contract and click the search result to import the smart contract 
code into Remix.

Cookbook's AI Solidity co-pilot, ChefGPT, is available within the Remix plugin to answer questions 
about Linea, Solidity, or the smart contract you're working with.

<div class="center-container">
  <div class="img-small">
      <img
      src="/img/get_started/how_to/deploy_smart_contract/cookbook/Linea_deploy_smart_contract_Cookbook_10.png"
      alt="Cookbook Remix Search"
    />
  </div>
</div>

## Resources

For more information on using Cookbook to find, learn about or build with smart contracts, check out 
the following resources:

- [Blog](https://medium.com/@cookbookdev)
- [X](https://x.com/cookbook_dev)
- [Community](https://discord.gg/cookbook)


==================== FILE: /workspace/docs/get-started/tooling/contracts-templates/index.mdx ====================

---
title: Contract templates
image: /img/socialCards/contract-templates.jpg
---


import DocCardList from '@theme/DocCardList';

<DocCardList />


==================== FILE: /workspace/docs/get-started/tooling/contracts-templates/thirdweb.mdx ====================

---
title: thirdweb
image: /img/socialCards/thirdweb.jpg
---

thirdweb is a developer tools platform that speeds up and simplifies dapp development. On the 
[thirdweb Linea website](https://thirdweb.com/linea), you can find:

1. A collection of pre-audited Solidity smart contracts that will let you deploy on Linea with 
one click
2. Multiple use cases ranging from NFTs to tokens, DAOs, DEXs, and marketplaces.
3. A dashboard to manage deployed contracts (updates, interaction, monitoring, etc.)
4. An SDK that will help you to interact with deployed contracts and/or wallets that you can use 
in your dapp
5. Backend or frontend code, available in Javascript/Node.js, React, React Native, Python, Go and 
Unity.

Check it out on the [thirdweb Linea website](https://thirdweb.com/linea).

## Resources

Learn more and start building with thirdweb:

- [Documentation](https://portal.thirdweb.com)
- [Tutorial videos](https://youtube.com/thirdweb)
- [Tutorial guides](https://blog.thirdweb.com/guides)
- [Contract deployment quickstart](../../how-to/deploy-smart-contract/thirdweb.mdx)


==================== FILE: /workspace/docs/get-started/tooling/gas/blocknative.mdx ====================

---
title: Blocknative
image: /img/socialCards/blocknative.jpg
---

Blocknative offers APIs to help developers and users estimate fees on Linea. The estimates are based 
on real-time Linea data and ML modeling to accurately and consistently estimate Linea transaction 
fees. Linea fee estimation is also available in the Blocknative [browser extension](https://blocknative.com/gas-extension).

## Use the Blocknative Gas API

To leverage Blocknative's Gas API, you will need an [API Key](https://docs.blocknative.com/gas-prediction/gas-platform). 
Once you have an API key, you can request fee estimation for Linea:

```bash
curl -H "Authorization: your-apikey-here" https://api.blocknative.com/gasprices/blockprices?chainid=59144
```


==================== FILE: /workspace/docs/get-started/tooling/gas/index.mdx ====================

---
title: Gas
image: /img/socialCards/gas.jpg
---

import DocCardList from '@theme/DocCardList';

<DocCardList />


==================== FILE: /workspace/docs/get-started/tooling/index.mdx ====================

---
title: Tools
image: /img/socialCards/tools.jpg
---

import DocCardList from '@theme/DocCardList';

<DocCardList />


==================== FILE: /workspace/docs/get-started/tooling/node-providers/erpc.mdx ====================

---
title: eRPC
image: /img/socialCards/erpc.jpg
---

[eRPC](https://erpc.cloud/) is a fault-tolerant EVM RPC proxy and re-org aware
permanent caching solution. It is built with read-heavy use-cases in mind such
as data indexing and high-load frontend usage.

- [Github](https://github.com/erpc/erpc)
- [Docs](https://docs.erpc.cloud/)
- [Telegram](https://t.me/erpc_cloud)

<div class="center-container">
  <div class="img-large">
    <img
      src="https://github.com/erpc/erpc/raw/main/assets/hla-diagram.svg"
      alt="architecture diagram"
    />
  </div>
</div>

# Quickstart

1. Create your [`erpc.yaml`](https://docs.erpc.cloud/config/example)
   configuration file:

```yaml
filename="erpc.yaml"
logLevel: debug
projects:
  - id: main
    upstreams:
      # You don't need to define architecture (e.g. evm) or chain id (e.g. 59144)
      # as they will be detected automatically by eRPC.
      - endpoint: https://linea-mainnet.blastapi.io/xxxx
      - endpoint: evm+alchemy://xxxx-my-alchemy-api-key-xxxx
```

View [the complete config example](https://docs.erpc.cloud/config/example) for
inspiration.

2. Use the Docker image:

```bash
docker run -v $(pwd)/erpc.yaml:/root/erpc.yaml -p 4000:4000 -p 4001:4001 ghcr.io/erpc/erpc:latest
```

3. Send your first request:

```bash
curl --location 'http://localhost:4000/main/evm/59144' \
--header 'Content-Type: application/json' \
--data '{
    "method": "eth_getBlockByNumber",
    "params": [
        "0x7340c3",
        false
    ],
    "id": 9199,
    "jsonrpc": "2.0"
}'
```

4. Bring up the monitoring stack (Prometheus, Grafana) using `docker-compose`:

```bash
# clone the repo if you haven't
git clone https://github.com/erpc/erpc.git
cd erpc

# bring up the monitoring stack
docker-compose up -d
```

5. Open Grafana at [http://localhost:3000](http://localhost:3000) and log in
   with the following credentials:

- username: `admin`
- password: `admin`

6. Send more requests and watch the metrics being collected and visualized in
   Grafana.


==================== FILE: /workspace/docs/get-started/tooling/node-providers/index.mdx ====================

---
title: Node providers
image: /img/socialCards/node-providers.jpg
---

## Private RPC endpoints

<table>
  <tr>
    <th>Provider</th>
    <th>Linea API methods*</th>
    <th>WebSocket</th>
  </tr>
  <tr>
    <td><a href="https://alchemy.com/">Alchemy</a></td>
    <td>:white_check_mark:</td>
    <td>:white_check_mark:</td>
  </tr>
  <tr>
    <td><a href="https://ankr.com/rpc/">ANKR</a></td>
    <td>:x:</td>
    <td>:white_check_mark:</td>
  </tr>
  <tr>
    <td><a href="https://blastapi.io/">BLAST API</a></td>
    <td>:white_check_mark:</td>
    <td>:white_check_mark:</td>
  </tr>
  <tr>
    <td><a href="https://blockpi.io/">Blockpi</a></td>
    <td>:white_check_mark:</td>
    <td>:white_check_mark:</td>
  </tr>
  <tr>
    <td><a href="https://chainstack.com/">Chainstack</a></td>
    <td>:white_check_mark:</td>
    <td>:white_check_mark:</td>
  </tr>
  <tr>
    <td><a href="https://drpc.org/">DRPC</a></td>
    <td>:white_check_mark:</td>
    <td>:white_check_mark:</td>
  </tr>
  <tr>
    <td><a href="https://getblock.io/">GetBlock</a></td>
    <td>:white_check_mark:</td>
    <td>:white_check_mark:</td>
  </tr>
  <tr>
    <td><a href="https://grove.city/">Grove</a></td>
    <td>:white_check_mark:</td>
    <td>:x:</td>
  </tr>
  <tr>
    <td><a href="https://infura.io/">Infura</a></td>
    <td>:white_check_mark:</td>
    <td>:white_check_mark:</td>
  </tr>
  <tr>
    <td><a href="https://moralis.io/nodes/">Moralis</a></td>
    <td>:x:</td>
    <td>:x:</td>
  </tr>
  <tr>
    <td><a href="https://nownodes.io/nodes">NOWNodes</a></td>
    <td>:white_check_mark:</td>
    <td>:x:</td>
  </tr>
  <tr>
    <td><a href="https://quicknode.com">QuickNode</a></td>
    <td>:x:</td>
    <td>:white_check_mark:</td>
  </tr>
  <tr>
    <td><a href="https://unifra.io/">Unifra</a></td>
    <td>:x:</td>
    <td>:white_check_mark:</td>
  </tr>
</table>

> \* _"Linea API methods" indicates endpoints that support custom features beyond standard
> Ethereum functionality, such as the [`linea_estimateGas`](../../../api/reference/linea-estimategas.mdx) 
> API method, or features that require a specific implementation to work on Linea, such as use of
> the [`finalized` tag](../../how-to/finalized-block.mdx)._

## Run your own node

View our [node running guides](../../how-to/run-a-node/index.mdx) to find out how to run a node locally. 

You can also run nodes with the following providers:
- [EasyNode](https://app.easy-node.xyz/)
- [Mintair](https://mintair.xyz/)
- [RapidNode](https://rapidnode.xyz)

## Use RPC proxy and caching

- [eRPC](./erpc.mdx)

## Public RPC endpoints

:::caution

Public endpoints are rate limited, and not meant for production systems.

:::

<table>
  <tr>
    <th>Mainnet</th>
    <th>Testnet</th>
    <th>Linea API methods*</th>
    <th>Websocket</th>
  </tr>
  <tr>
    <td>
      <code>https://linea-mainnet.public.blastapi.io</code>
    </td>
    <td>
      <code>https://linea-sepolia.public.blastapi.io</code>
    </td>
    <td>:white_check_mark:</td>
    <td>:white_check_mark:</td>
  </tr>
  <tr>
    <td>
      <code>https://rpc.linea.build</code>
    </td>
    <td>
      <code>https://rpc.sepolia.linea.build</code>
    </td>
    <td>:white_check_mark:</td>
    <td>:x:</td>
  </tr>
  <tr>
    <td>
      <code>https://linea.rpc.thirdweb.com</code>
    </td>
    <td>
      <code>https://linea-sepolia.rpc.thirdweb.com</code>
    </td>
    <td>:x:</td>
    <td>:x:</td>
  </tr>
  <tr>
    <td>
      <code>https://linea-mainnet-public.unifra.io</code>
    </td>
    <td>N/A</td>
    <td>:x:</td>
    <td>:x:</td>
  </tr>
  <tr>
    <td>
      <code>https://linea.rpc.grove.city/v1/01fdb492</code>
    </td>
    <td>N/A</td>
    <td>:white_check_mark:</td>
    <td>:x:</td>
  </tr>
  <tr>
    <td>
      <code>https://go.getblock.io/ACCESS_TOKEN</code>
    </td>
    <td>
      <code>https://go.getblock.io/ACCESS_TOKEN</code>
    </td>
    <td>:x:</td>
    <td>:white_check_mark:</td>
  </tr>
  <tr>
    <td>
      <code>https://site1.moralis-nodes.com/linea/API_KEY</code>
    </td>
    <td>
      <code>https://site1.moralis-nodes.com/linea-sepolia/API_KEY</code>
    </td>
    <td>:x:</td>
    <td>:x:</td>
  </tr>
</table>

> \* _"Linea API methods" indicates endpoints that support custom features beyond standard
> Ethereum functionality, such as the [`linea_estimateGas`](../../../api/reference/linea-estimategas.mdx) 
> API method, or features that require a specific implementation to work on Linea, such as use of
> the [`finalized` tag](../../how-to/finalized-block.mdx)._

You can also view an overview of public and private RPC endpoints on [linea.chain.love](https://linea.chain.love/).

If you're an RPC endpoint provider and would like to be added to the list, reach
out to our team, or make a PR to the docs.


==================== FILE: /workspace/docs/get-started/tooling/security/hexagate.mdx ====================

---
title: Hexagate
image: /img/socialCards/hexagate.jpg
---

[Hexagate](https://hexagate.com) is a proactive web3 security and risk analytics solution. 
Hexagate's enterprise-grade security platform prevents cyber exploits, hacks, governance and 
financial risks for protocols, web3 apps and asset managers. The platform allows end-to-end 
detection and response for any type of threat to mitigate risk and threats ahead of time, before 
they impact any digital assets.


==================== FILE: /workspace/docs/get-started/tooling/security/goplus-security-api.mdx ====================

---
title: GoPlus Security API
image: /img/socialCards/goplus-security-api.jpg
---

[GoPlus Security](https://gopluslabs.io/) provides open, permissionless, user-driven security 
services. GoPlus security engine covers multi-chain with multidimensional risk detection for both 
crypto projects and ordinary users, making a safer chain ecosystem.

You can find out more about how to use their APIs and SDK in their [developer documentation](https://docs.gopluslabs.io/).


==================== FILE: /workspace/docs/get-started/tooling/security/hypernative.mdx ====================

---
title: Hypernative
image: /img/socialCards/hypernative.jpg
---

[Hypernative](https://hypernative.io/) stops zero-day cyber attacks, economic risks, detects 
on-chain anomalies, and protects digital assets, protocols, and web3 applications from significant 
losses or threats.

Powered by our “pre-cog” platform, Hypernative monitors on and offchain data sources using our 
proprietary machine learning models to accurately predict cyber, economic, and governance threats 
before they manifest. The detections are then connected to various automated playbooks to prevent 
and mitigate risks in real time.


==================== FILE: /workspace/docs/get-started/tooling/security/index.mdx ====================

---
title: Security
image: /img/socialCards/security.jpg
---


import DocCardList from '@theme/DocCardList';

<DocCardList />


==================== FILE: /workspace/docs/get-started/tooling/security/scamfari.mdx ====================

---
title: Scamfari
image: /img/socialCards/scamfari.jpg
---

[Scamfari](https://scamfari.com) is a cybersecurity tool developed on the Linea blockchain, enabling 
users to report suspicious activities linked to malicious actors within the blockchain space. These 
malicious entities - including scammers and phishers — pose ongoing challenges in the blockchain 
community. Scamfari's approach involves thorough reviews of each user-submitted report by 
cybersecurity professionals to ensure the data's accuracy. Verified reports are subsequently 
integrated into various databases, notably the [HAPI Protocol](https://hapi.one), fortifying the 
collective defense against such threats.


==================== FILE: /workspace/docs/get-started/tooling/security/spherex.mdx ====================

---
title: SphereX
image: /img/socialCards/spherex.jpg
---

[SphereX](https://spherex.xyz/) eliminates unexpected manipulations and malicious attacks, 
employing _embedded security_ to neutralize attack surfaces. Stay leaps ahead - remove the element 
of surprise and ensure the unwavering control in every conceivable situation.

<div class="center-container">
  <div class="img-medium">
    <img
      src="/img/get_started/tooling/security/spherex/SphereX-infographic.png"
      alt="SphereX Architecture"
    />
  </div>
</div>

Web3 has lost trust and faith due to frequent hacks, resulting in billions of dollars lost, while 
existing security solutions continue to fall short. Auditing is not scalable, and monitoring is 
often too late. Both fail to provide the comprehensive, continuous protection is needed to defend 
your protocol and instill trust. Protocol owners find themselves having to independently construct 
security measures and components, making it nearly impossible to guarantee certainty and eliminate 
edge cases and malicious activity in their protocol despite substantial efforts and budget.

SphereX's embedded security safeguards your protocol and fortifies your code during execution, 
proactively blocking any exploitative or unexpected behavior. SphereX's solution is designed as a 
modular platform, facilitating the seamless onboarding of diverse capabilities. Features like 
compliance, circuit breakers, virtual patching, investigations, and more can be seamlessly added at 
any stage during your protocol's lifecycle. The modular nature allows the protocol to evolve in 
tandem with tasks and requirements. SphereX's platform guarantees that any attempt to interact with 
the protocol beyond the intended boundaries will be promptly intercepted and reversed.


==================== FILE: /workspace/docs/get-started/tooling/attestations/primus.mdx ====================

---
title: Primus
image: /img/socialCards/primus.jpg
---

[Primus](https://primuslabs.xyz/) is a cryptography-based attestation protocol to bring all 
internet data into smart contracts. Primus relies heavily on cryptography to minimize trust, 
and enables end users to prove the correctness of their personal web data in a privacy-preserving 
manner.

The core techniques used in Primus include secure multi-party computation (MPC) and interactive 
zero-knowledge proofs (IZK). End users run Primus client apps to attest their personal web data, and 
create related data proofs with the help of Primus nodes. These data proofs are cryptographically 
verified attestations with security guarantees including:

- Data authenticity: the user web data is honestly retrieved from the indicated data source, and 
the integrity is secured by MPC-TLS and IZK techniques.
- Privacy: When coupled with specific application logic, users' sensitive information is 
well-protected under the zero-knowledge property.

The MPC-TLS and IZK techniques are general enough for both data source integration and data 
computation. For instance, you can create your own attestations including but not limited to:

- Proofs of CEX assets, e.g., Alice has more than 1000 USD for her total token values in Coinbase;
- Proofs of specific token holding, e.g., Alice holds more than 2 ETH in Binance;
- Proofs of nationality, e.g., Alice is a verified bank user with British nationality;
- Proofs of a heavy gamer, e.g., Bob plays more than 10 hours per day on Steam games.

## For developers

The Primus team is creating a template-based SDK (in progress) for developers to build their own 
applications using Primus's off-chain attestation capabilities. The SDK will encapsulate the details 
of underlying cryptographic algorithms and protocols, and provide high-level interfaces for 
application developers to manage the data retrieval and data computation. Developers can leverage 
the SDK in two aspects:

- Use the data source templates to integrate with any preferred Internet data source, and to attest
the corresponding type of data.
- Define and implement their own application logic by integrating with data consumption templates.

## Networks

Primus is deployed on Linea, and integrated with [Verax](https://github.com/Consensys/verax-documentation), 
a public attestation registry to store and manage attestation data that can be accessed by any 
party. This means Primus users can submit these data proofs to Linea via Verax, which can be further 
accessed by other dapps. The following contract address is the Primus portal contract:

| Network | Contract address |
| --- | --- |
| Linea Mainnet | [`0x50bd377EB8D4236Bb587AB3FB1eeafd888AEeC58`](https://lineascan.build/address/0x50bd377EB8D4236Bb587AB3FB1eeafd888AEeC58) |

## Resources

Learn more and start using PADO!

- [Product tutorial](https://docs.primuslabs.xyz/data-verification/pado-extension/mainfunctions)
- [Technical principles](https://docs.primuslabs.xyz/)
- [Technical whitepaper](https://eprint.iacr.org/2023/964.pdf)

## Learn more

- [X](https://x.com/primus_labs)
- [Discord](https://discord.com/invite/pdrNxRrApX)
- [Website](https://primuslabs.xyz/)
- [Medium](https://medium.com/@primuslabs)
- [Github](https://github.com/primus-labs)


==================== FILE: /workspace/docs/get-started/tooling/attestations/index.mdx ====================

---
title: Attestations
image: /img/socialCards/attestations.jpg
---

An attestation is evidence or proof of something, issued by a given authority. 

Some common examples of attestations are:

- Passport: Proof of citizenship, and ability to travel internationally
- University degree: Proof of education
- Driver's license: Proof of being able and legally approved to drive a car

In the world of web3, attestations can prove digital identity, ownership of digital assets, and more. 

This space is currently rapidly evolving, and use cases for attestations are still being discovered 
and built.

import DocCardList from '@theme/DocCardList';

<DocCardList />


==================== FILE: /workspace/docs/get-started/tooling/attestations/verax.mdx ====================

---
title: Verax
image: /img/socialCards/verax.jpg
---

Verax is a shared onchain attestation registry. The teams that are actively involved in designing 
and building the project include Consensys (the team behind Linea), Clique, Karma3 Labs, Aspecta, 
Primus Labs, and Reclaim Protocol. A number of other teams including GitCoin are building 
integrations with the system.

**_It is not an EIP, a protocol, or a product, but a simple primitive that can be used by any dapps 
and protocols as a shared “data lake” of public data. In essence, it can be thought of as a backend 
or a database._**

Think of Verax as a distribution channel where issuers of attestations keep the attestations. Any 
protocol, dapp, or user that wants to use those attestations can easily use and compose attestations 
from the different sources that are available in that distribution channel. Examples of some of the 
integrations currently being built include Clique, GitCoin, Primus Labs and Reclaim Protocol.

To learn more about why we need Verax, read this [blog post](https://linea.build/blog/introducing-verax-an-on-chain-attestation-registry).

## Use cases

Verax can enable a wide range of use cases, including:

- Inclusive sybil resistance: dapps can have a high degree of confidence that their users are not 
bots _without_ prescribing a narrow method of proving their humanity, which can impose a 
prerequisite on new users and introduce friction into the user experience. Imagine having a 
bot-resistant Lens profile creation system without whitelists, based on sophisticated reputation 
protocols.
- Supporting a market for under-collateralized peer-to-peer lending based on robust, transparent 
and continually evolving reputation scores.
- Permissionless fraud detection and scam prevention: smart contracts and dapps can prove they are 
audited and can have a reputation based on usage and reviews, etc.
- A powerful recommendation engine that allows people to discover new content and dapps that are 
relevant to them, without the need for a centralized curator.

## Contract address

| Network | Contract address |
| --- | --- |
| Linea Mainnet | [0x0A564cdD56E4916AA1C63e11652f27B50d970ba0](https://lineascan.build/address/0x0A564cdD56E4916AA1C63e11652f27B50d970ba0) |

## Proof of Humanity (PoH)

PoH systems ensure that participants in web3 are real humans and not bots. For example, in the 
[Linea DeFi Voyage](https://linea.build/blog/welcome-to-the-linea-voyage-defi), these 
systems were run by our partners such as Gitcoin, Clique, and Aspecta, leveraging the Verax registry. 
End-users don't directly interact with Verax at any point.

PoH is available as a public API, and can also be checked onchain. See our [guide](../../how-to/poh-api.mdx) 
for more information.

## Resources

Access the [official Verax documentation](https://docs.ver.ax/verax-documentation/).


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/envio.mdx ====================

---
title: Envio
image: /img/socialCards/envio.jpg
---

[Envio](https://envio.dev/) is a customizable, real-time indexing solution that
provides developers with a seamless, efficient way to index and aggregate
blockchain data. The indexed data is accessible through GraphQL queries,
providing developers with the ability to flexibly retrieve specific information.

Envio offers native support for Linea (both testnet and mainnet) and has been
designed to support high-throughput blockchain applications that rely on
real-time data for their business requirements.

Designed to optimize the user experience, Envio offers automatic code
generation, flexible language support, quickstart templates, and a reliable,
cost-effective hosted service.

Indexers on Envio can be written in JavaScript, TypeScript, or ReScript.

## Envio HyperSync

Envio offers support for [HyperSync](https://docs.envio.dev/docs/hypersync) on
Linea Mainnet.

HyperSync is an indexed layer of the Linea blockchain, providing accelerated
APIs (JSON-RPC bypass) for fast historical data syncing. Developers do not need
to worry about RPC URLs, rate-limited APIs, or managing infrastructure, and can
sync large datasets in a few minutes, something that would usually take 20x
longer via JSON-RPC.

## Other features

- Fully customizable to meet your unique data needs.
- Aggregate data from multi-chain/cross-chain deployments into a unified GraphQL
  API (or REST API).
- Detailed logging and error messaging for effective troubleshooting and
  debugging.
- Quickstart templates with pre-defined indexing logic for popular OpenZeppelin
  contracts (ERC-20, ERC-721, ERC-1155, etc.)

## Get started

The following files are required from the user to run the Envio indexer:

- Configuration (defaults to `config.yaml`)
- GraphQL Schema (defaults to `schema.graphql`)
- Event Handlers (defaults to `src/EventHandlers.*` depending on the language
  chosen)

These files are auto-generated according to the template and language chosen by
running the `envio init` command.

> [See our **quickstart guide**.](https://docs.envio.dev/docs/quickstart)

```bash
? Would you like to start from a template or migrate from a subgraph?
> "Template"
  "SubgraphMigration"
[↑↓ to move, enter to select, type to filter]

```

Then choose a template out of the possible options:

```bash
? Which template would you like to use?
> "Blank"
  "Greeter"
  "ERC-20"
[↑↓ to move, enter to select, type to filter]
```

Then choose a language from **Javascript**, **Typescript**, or **Rescript** to
write the event handlers file.

```bash
? Which language would you like to use?
> "Javascript"
  "Typescript"
  "Rescript"
[↑↓ to move, enter to select, type to filter]
```

This will create the config, schema and event handlers files according to the
template and language chosen.

## Get help

Indexing can be a rollercoaster, especially for more complex use cases. Our
engineers are available to help you with your data availability needs.

You can schedule an [intro call](https://calendly.com/sven-float-shipping/envio)
to talk about your use case and where Envio can provide value.

Join our growing community of elite builders, and find peace of mind with Envio.

- [Discord](https://discord.gg/mZHNWgNCAc)
- Email: [hello@envio.dev](mailto:hello@envio.dev)


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/goldsky/goldsky-mirror.mdx ====================

---
title: Quickstart - Mirror
sidebar_position: 3
image: /img/socialCards/quickstart-mirror.jpg
---

To get started with Goldsky Mirror:

1. Create an account at **[app.goldsky.com](https://app.goldsky.com/)**.
2. Choose a plan that best fits your needs.
3. Create an API key on
   the **[Settings page](https://app.goldsky.com/dashboard/settings)**.
4. Install the Goldsky CLI:

   ```bash
   npm install -g @goldskycom/cli
   ```

5. Log in with the API key created earlier:

   ```bash
   goldsky login
   ```

6. Use the following command to walk through a guided experience to create
   pipelines. Based on the input you provide, the CLI will generate a pipeline
   definition for you behind the scenes.

   ```bash
   goldsky pipeline create <your-pipeline-name>
   ```

7. Upon successfully walking through the CLI, an active pipeline will be created
   and data should appear in the destination sink shortly. A monitoring table
   will automatically be displayed, or can be activated using the following
   command:

   ```bash
   goldsky pipeline monitor <your-pipeline-name>
   ```

8. For greater flexibility, Mirror pipelines can be defined via JSON
   configuration files. For more detail and full reference information on how to
   define pipelines, data sources, transformations, and sinks via JSON - visit
   [Goldsky’s docs](https://docs.goldsky.com/mirror/references/pipeline-configuration).


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/goldsky/overview.mdx ====================

---
title: Overview
sidebar_position: 1
image: /img/socialCards/overview.jpg
---

[Goldsky](https://goldsky.com) is a data indexing provider for Linea enabling
you to extract, transform, and load onchain data to power application and
analytics use cases. Goldsky offers two primary approaches to indexing and
accessing blockchain data: [Index](#index) (subgraphs) and [Mirror](#mirror)
(real-time data replication pipelines).

## Index

[Index](./goldsky-index.mdx) is a hosted subgraph solution with native support
for Linea (both testnet and mainnet). Subgraphs allow you to define a data
schema and how blockchain data should be indexed for querying, and can be
deployed to Goldsky directly from the command line. If you've built with
subgraphs in the past, you can work with Goldsky's hosted service with no change
to your development flow, and take advantage of several key benefits:

- **Cross-chain**: Native cross-chain and multi-chain support to query data from
  multiple blockchains from a single endpoint, automatically managing event
  order, re-orgs, and other complexities.
- **RPC proxy**: [Goldsky](https://goldsky.com) balances load and manages RPC
  provider failures across 20+ endpoints, maximizing indexing speed and querying
  reliability.
- **Dev tooling**: Webhooks, version control, data source tags, instant
  subgraphs without writing a line of code, and other goodies to make indexing
  data easier.
- **White-glove support**: With custom SLAs and support scopes, Goldsky's
  support team is available 24/7 to customize your indexing and query server for
  your specific use case, and to help if things go wrong.

## Mirror

[Mirror](./goldsky-mirror.mdx) is a real-time data replication system that
allows you to keep blockchain data where your app is. Mirror pipelines instruct
[Goldsky](https://goldsky.com) where to take data from, how to (optionally)
process it, and where to persist the results. Compared to subgraphs, Mirror
pipelines differ in a few key ways:

- **Self-hosted**: Results are persisted in a database or as flat files rather
  than being served only via a remotely-hosted API. This allows for seamless
  colocation of indexed data alongside your app and (private) user data.
- **Self-healing**: Mirror pipelines benefit from the wisdom of the crowd -
  quality checks, fixes, and improvements to the data are applied automatically
  through upserts and deletes directly in your database.
- **Scalable**: You can index data from multiple sources (and push it to
  multiple sinks, and with transformations) in parallel, and with infinite
  horizontal scaling, allowing you to complete historical backfills in record
  speed.
- **Simple**: Mirror pipelines can be defined and executed entirely through a
  five-step interactive CLI, or with simple JSON configuration files and some
  SQL for more flexibility.

## Get started

Visit the quickstart pages for [Index](./goldsky-index.mdx) and
[Mirror](./goldsky-mirror.mdx) on Linea, or visit the complete Goldsky
documentation [here](https://docs.goldsky.com).


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/goldsky/goldsky-index.mdx ====================

---
title: Quickstart - Index
sidebar_position: 2
image: /img/socialCards/quickstart-index.jpg
---

To get started with Goldsky Index:

1. Create an account at **[app.goldsky.com](https://app.goldsky.com/)**.
2. Choose a plan that best fits your needs.
3. Create an API key on
   the **[Settings page](https://app.goldsky.com/dashboard/settings)**.
4. Install the Goldsky CLI:

   ```bash
   npm install -g @goldskycom/cli
   ```

5. Log in with the API key created earlier:

   ```bash
   goldsky login
   ```

6. Deploy your subgraph

   ```bash
   cd <your-subgraph-directory>
   graph build # Build your subgraph as normal.
   goldsky subgraph deploy my-subgraph/1.0.0
   ```

7. Alternative, subgraphs can be deployed using Goldsky’s instant subgraph
   functionality

   ```bash
   goldsky subgraph deploy <subgraphName>/<subgraphVersion> --from-abi <path-to-config-file>
   ```

   Config files for instant subgraphs are written in JSON and outline key
   information such as the chain, contract address, and path to ABI file.
   Example of a basic configuration file below.

   ```bash
   {
     "version": "1",
     "name": "TokenDeployed",
     "abis": {
       "TokenRegistry": {
         "path": "./abis/token-registry.json"
       }
     },
     "chains": ["mainnet"],
     "instances": [
       {
         "abi": "TokenRegistry",
         "address": "0x0A6f564C5c9BeBD66F1595f1B51D1F3de6Ef3b79",
         "startBlock": 13983724,
         "chain": "mainnet"
       }
     ]
   }
   ```

8. Once deployed, you can access data using the GraphQL API link provided, and
   review all deployed subgraphs with `goldsky subgraph list` or at
   app.goldsky.com.

---

For more detail & context, and the full CLI reference, visit
[Goldsky’s docs](https://docs.goldsky.com/indexing).


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/arkham.mdx ====================

---
title: Arkham
image: /img/socialCards/arkham.jpg
---

[Arkham](https://platform.arkhamintelligence.com/) is a crypto intelligence
platform that systematically analyzes blockchain transactions, showing users the
people and companies behind blockchain activity, with a suite of tools for
analyzing their activity.

Access Arkham [here](https://platform.arkhamintelligence.com/).

Resources:

- [Platform guide](https://arkhamintelligence.notion.site/Arkham-eb1213a42ae24fe39643bd737f4ae78e)
- [Whitepaper](https://arkhamintelligence.com/whitepaper)
- [Codex](https://codex.arkhamintelligence.com/)
- [Demos](https://youtube.com/@arkhamintel)


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/dipdup/quickstart.mdx ====================

---
title: Quickstart
sidebar_position: 2
image: /img/socialCards/quickstart.jpg
---

This page will guide you through the steps to get your first DipDup indexer up
and running in a few minutes without getting too deep into the details.

Let's create an indexer for output transactions from a specific address. We will
need to set up the indexing environment, configure the indexer, and store the
results in a database.

## Prerequisites

Here are a few things you need to get started with DipDup:

- **Skills**: Basic Python 3 knowledge to implement data handlers.
- **Operating system**: You can use any Linux/macOS distribution on amd64/arm64
  platforms with Python installed.
- **Python version**: Python 3.11 is required for DipDup. You can check your
  Python version by running `python3 --version` in your terminal.

## Step 1 — Install DipDup

The easiest way to install DipDup as a CLI application is
[pipx](https://pipx.pypa.io/stable/) with the command `pipx install dipdup`. If
you don't want to deal with tooling, we have a convenient installer script. Run
the following command in your terminal:

```bash
curl -Lsf https://dipdup.io/install.py | python3
```

See the [installation](https://dipdup.io/docs/installation) page for other
options.

## Step 2 — Create a project

DipDup CLI has a built-in project generator with lots of templates. To create a
new project interactively, run the following command:

```bash
dipdup new
```

For educational purposes, we'll create a project from scratch, so choose
`[none]` network and `demo_blank` template.

Follow the instructions; the project will be created in the new directory.

## Step 3 — Configuration file

The project root directory contains a bash file named `dipdup.bash`. It's the
main configuration file of your indexer. Available options are described in
detail on [this page](https://dipdup.io/docs/getting-started/config). For now,
just replace its content with the following:

```bash
spec_version: 2.0
package: linea

datasources:
  subsquid:
    kind: evm.subsquid
    url: https://v2.archive.subsquid.io/network/linea-mainnet
    node: evm_node

  etherscan:
    kind: abi.etherscan
    url: https://api.lineascan.build/api

  mainnet_node:
    kind: evm.node
    url: https://linea-mainnet.infura.io/v3
    ws_url: wss://linea-mainnet.infura.io/ws/v3

contracts:
  some_contract:
    kind: evm
    address: 0xa219439258ca9da29e9cc4ce5596924745e12b93
    typename: not_typed

indexes:
  evm_index:
    kind: evm.subsquid.transactions
    datasource: mainnet_node
    handlers:
      - callback: on_output_transaction
        from: some_contract
    last_level: 4631


database:
  kind: sqlite
  path: data/linea.sqlite
```

Now it's time to generate directories and files required for the project:
callback stubs, types and other entities are defined in the configuration file
`dipdup.bash`, so don't worry; in this guide we will only need a few. To
generate the directories and files, run:

```bash
dipdup init
```

You can read more about the structure of the DipDup package
[here](https://dipdup.io/docs/getting-started/package).

## Step 4 — Define models and implement data handlers

In this step, we define the business logic of our application. DipDup supports
storing data in SQLite, PostgreSQL and TimescaleDB databases. We use custom ORM
based on Tortoise ORM as an abstraction layer.

First, you need to define a model class. Our schema will consist of a single
`Transaction` model:

```bash
from dipdup import fields
from dipdup.models import Model


class Transaction(Model):
    hash = fields.TextField(pk=True)
    block_number = fields.IntField()
    from_ = fields.TextField()
    to = fields.TextField(null=True)

    created_at = fields.DatetimeField(auto_now_add=True)
```

Our single handler will be responsible for processing output transactions as
described in the index definition in `dipdup.bash`:

```bash
from dipdup.context import HandlerContext
from dipdup.models.evm_node import EvmNodeTransactionData
from dipdup.models.evm_subsquid import SubsquidTransactionData

from linea import models as models


async def on_output_transaction(
    ctx: HandlerContext,
    transaction: SubsquidTransactionData | EvmNodeTransactionData,
) -> None:
    await models.Transaction(
        hash=transaction.hash,
        block_number=transaction.block_number,
        from_=transaction.from_,
        to=transaction.to,
    ).save()
```

## Step 5 — Results

Time to run the indexer. Processed data will be written to the SQLite file
defined in the configuration:

```bash
dipdup run
```

DipDup will fetch all the historical data and switch to realtime mode. You can
check the progress in the logs.

Query the database to see the results:

```bash
sqlite3 /tmp/linea.sqlite 'SELECT * FROM transaction LIMIT 10'
```


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/dipdup/overview.mdx ====================

---
title: Overview
sidebar_position: 1
image: /img/socialCards/overview.jpg
---

[DipDup](https://dipdup.io/) is a Python framework for building smart contract
indexers. It helps developers focus on business logic instead of writing a
boilerplate to store and serve data. DipDup-based indexers are selective, which
means only required data is requested. This approach allows to achieve faster
indexing times and decreased load on underlying APIs.

## Understanding DipDup

DipDup is a software framework that helps web3 developers create selective
indexers for decentralized applications. It uses blockchain data provided by
various off-chain data sources. Some of the key features of DipDup include:

- **Ready for multichain**: DipDup supports dozens of blockchains, and we are
  constantly adding new ones. You can easily reuse your business logic for
  different networks or even index multiple chains in a single project.
- **Declarative configuration**: A whole indexer is defined by a single
  configuration file and a bunch of Python data handlers. Code is completely
  separated from the configuration and environment variables, making it easy to
  maintain and deploy your project.
- **Integrations**: You can use SQLite, PostgreSQL, or TimescaleDB databases to
  store blockchain data, deploy to Compose or Swarm with a single command,
  monitor your indexer with Prometheus or Sentry, and more.
- **GraphQL API**: DipDup automatically generates a GraphQL API for your data
  using Hasura, so you can query it from your frontend or other services. You
  can extend the API with custom queries and metadata requests.
- **CLI**: DipDup CLI has everything you need to conveniently manage your
  project, from creating a new one to running and deploying. There are lots of
  templates for various blockchains and use cases, so you can start quickly.

## Explore

To learn more about DipDup features, visit the
[official DipDup documentation](https://dipdup.io/docs). It offers an in-depth
explanation of the framework concepts, lots of examples from basic to the most
advanced, allowing rapid and efficient development of blockchain data indexers
of any complexity.


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/flair.mdx ====================

---
title: Flair
image: /img/socialCards/flair.jpg
---

Real-time and historical custom data indexing for any evm chain.

[Flair](https://flair.dev) offers reusable **indexing primitives** (such as
fault-tolerant RPC ingestors, custom processors, re-org aware database
integrations) for receiving, transforming, storing, and accessing your onchain
data.

<div class="center-container">
  <div class="img-large">
    <a href="https://docs.flair.dev/">
      <img
        src="/img/get_started/tooling/data_indexers/flair/Linea_Flair_1.png"
        alt="Flair architecture"
      />
    </a>
  </div>
</div>

## Why Flair?

- 🚀 A **parallel and distributed processing paradigm**, rather than constrained
  sequential processing, supports your indexing stack's scalability and
  resiliency.
- 🧩 Focused on **primitives**, which means on the left you plug in an RPC and
  on the right you output the data to any destination database.
- 🚄 Native **real-time stream processing** for certain data workloads (such as
  aggregations, rollups) for things like total volume per pool, or total
  portfolio per user wallet.
- ☁️ **Managed** cloud services avoid DevOps and irrelevant engineering costs
  for dapp developers.
- 🧑‍💻 Avoid decentralization **overhead** (consensus, network hops, etc.). We
  believe the best UX for dapps reading data must be as close to the developers
  as possible.

## Features

- ✅ Listen to **any EVM chain** with just an RPC URL.
  - Free managed RPC URLs for 8+ popular chains already included.
  - Works with both websocket and https-only RPCs.
- ✅ Track and ingest **any contract** for **any event topic.**
  - Auto-track new contracts deployed from factory contracts.
- ✅ **Custom processor scripts** with Javascript runtime (with **Typescript**
  support)
  - Make external API or Webhook calls to third-party or your backend.
  - Get current or historical USD value of any ERC-20 token amount of any
    contract address on any chain.
  - Use any external NPM library.
- ✅ **Stream** any stored data to your destination database (Postgres, MongoDB,
  MySQL, Kafka, Elasticsearch, Timescale, etc).

## Get started

1. Clone the [starter boilerplate](https://github.com/flair-sdk/starter-boilerplate)
   template and follow the instructions:

```bash
git clone https://github.com/flair-sdk/starter-boilerplate.git
# ... follow instructions in README.md
```

:::info

Boilerplate instructions will create a **new cluster**, generate **an API Key**,
and set up a `manifest.yml` to index your **first contract** with **sample
custom processor** scripts.

Learn more about the [structure of `manifest.yml`](https://docs.flair.dev/reference/manifest.yml).

:::

2. Configure Linea RPC nodes. Set a unique namespace, Linea `chainId` and RPC
   endpoint in your `config`. Remember that you can add up to 10 RPC endpoints
   for resiliency.

```yaml
{
  "cluster": "dev",
  "namespace": "my-awesome-linea-indexing-dev",
  "indexers":
    [
      {
        "chainId": 59140,
        "enabled": true,
        "ingestionFilterGroup": "default",
        "processingFilterGroup": "default",
        "sources": [
            # Having at least 1 websocket endpoint is highly recommended
            "wss://linea-mainnet.infura.io/v3/xxxxxxxxxx",
            "https://linea-mainnet.infura.io/v3/xxxxxxxxxx",
            # You can add multiple endpoints for failover
            "https://rpc.linea.build",
          ],
      },
    ],
}
```

3. Sync some historical data using the [`backfill` command](https://docs.flair.dev/reference/backfilling).
Remember that the `enabled: true` flag in your `config` already enables your
indexer to capture data in real-time.

```bash
# backfill certain contracts or block ranges
pnpm flair backfill --chain 59140 --address 0x0872ec4426103482a50f26ffc32acefcec61b3c9 -d backward --max-blocks 10000
# backfill for a specific block number, if you have certain events you wanna test with
pnpm flair backfill --chain 59140 -b 409652
# backfill for the recent data in the last X minute
pnpm flair backfill --chain 59140 --min-timestamp="30 mins ago" -d backward
```

4. [Query](https://docs.flair.dev/#getting-started) your custom indexed data.

5. Stream the data to your [own database](https://docs.flair.dev/reference/database#your-own-database).

## Examples

Explore real-world usage of Flair indexing primitives for various use cases.

### DeFi

- [Aggregate protocol fees in USD across multiple chains](https://github.com/flair-sdk/examples/tree/main/aggregate-protocol-fees-in-usd)
- [Calculate "Health Factor" of positions with contract factory tracking](https://github.com/flair-sdk/examples/tree/main/health-factor-with-factory-tracking)
- [Index Uniswap v2 swaps with USD price for all addresses](https://github.com/flair-sdk/examples/tree/main/uniswap-v2-events-from-all-contracts-with-usd-price)

### NFT

- [Index ERC-721 and ERC-1155 NFTs on any EVM chain with an RPC URL](https://github.com/flair-sdk/examples/tree/main/erc721-and-erc1155-nft-indexing)

## Need help?

[Our engineers](https://docs.flair.dev/talk-to-an-engineer) are available to
help you at any stage.


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/subquery.mdx ====================

---
title: SubQuery
description: 'Fast, flexible, universal, open source and decentralized APIs'
image: /img/socialCards/subquery.jpg
---

SubQuery is a blockchain data indexer that provides developers with fast,
flexible, universal, open source and decentralized APIs for web3 projects.
SubQuery SDK allows developers to get rich indexed data and build decentralized
applications more efficiently. SubQuery supports 100+ ecosystems including
Linea, Ethereum, Polygon, Polkadot, Algorand, NEAR, and Avalanche.

One of SubQuery's key features is that it aggregates data across multiple
blockchains within a single project. This allows you to create feature-rich
dashboard analytics and multi-chain block scanners.

Other features include multiple RPC endpoint configurations, multi-worker
capabilities and a configurable caching architecture.

**Useful resources**:

- [SubQuery Academy (Documentation)](https://academy.subquery.network/)
- [Quickstart guide](https://academy.subquery.network/quickstart/quickstart.html)
- [Linea starter project](https://github.com/subquery/ethereum-subql-starter/tree/main/Linea/linea-starter)
- For technical questions and support reach out to us at [start@subquery.network](mailto:start@subquery.network).

## Get started

Take a look at this SubQuery starter project that introduces SubQuery's Linea
support by indexing [Linea](https://github.com/subquery/ethereum-subql-starter/tree/main/Linea/linea-starter).

You can also follow this [step-by-step guide](https://academy.subquery.network/quickstart/quickstart.html)
to get familiar with SubQuery.

## Running and hosting Linea SubQuery APIs

SubQuery is open-source, meaning you can run it in three ways:

- Locally on your own computer (or a cloud provider of your choosing). View the
  instructions for [running SubQuery locally](https://academy.subquery.network/run_publish/run.html).
- Publish to SubQuery's enterprise-level [Managed Service](https://managedservice.subquery.network/), 
  where we'll host your SubQuery project in production-ready services for 
  mission-critical data with zero-downtime blue/green deployments. A free tier 
  is also available. [Learn more.](https://academy.subquery.network/run_publish/publish.html).
- Publish to the decentralized [SubQuery Network](https://subquery.network/network), 
  an open and scalable data service for dapp developers. The SubQuery Network 
  indexes and services data to the global community in an incentivised and 
  verifiable way and supports Linea from launch.


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/thegraph.mdx ====================

---
title: The Graph Network
image: /img/socialCards/the-graph-network.jpg
---

# The Graph

Getting historical data on smart contracts can be frustrating when building a
dapp. [The Graph](https://thegraph.com/) offers a powerful way to query smart
contract data with open APIs known as subgraphs. Anyone can create or query
subgraphs, making the data available to the entire ecosystem. The Graph is
powered by hundreds of independent Indexers, enabling your dapp to become truly
decentralized.

Developers can use 100,000 free queries per month by using The Graph Network.

## Quickstart

Subgraphs index emitted events by default, but additional functionality can be
added later. A subgraph can be created in just a few minutes by following these
steps:

1. Initialize your subgraph
2. Publish your subgraph to The Graph Network
3. Query from your dapp with your unique API key

Here is a step-by-step walkthrough:

## 1. Initialize your subgraph

### Create a subgraph in subgraph studio

Go to the [Subgraph Studio](https://thegraph.com/studio/) and connect your
wallet. Once your wallet is connected, you can begin by clicking "Create a
Subgraph". When choosing a name, it's recommended to use Title Case, including
the subgraph and chain name, e.g., "MyDapp Subgraph Linea".

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/tooling/data_indexers/the-graph/create-a-subgraph.png"
      alt="alt text here"
    />
  </div>
</div>

Then, you will land on your subgraph's page. All the CLI commands you need will
be visible on the right side of the page:

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/tooling/data_indexers/the-graph/cli-commands.png"
      alt="alt text here"
    />
  </div>
</div>

### Install the Graph CLI⁠

On your local machine, run the following:

```
npm install -g @graphprotocol/graph-cli
```

### Initialize your subgraph⁠

You can copy this directly from your subgraph page to include your specific
subgraph slug:

```
graph init <SUBGRAPH_SLUG>
```

You'll be prompted to provide some info on your subgraph like this:

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/tooling/data_indexers/the-graph/cli-example.png"
      alt="alt text here"
    />
  </div>
</div>

Simply verify your contract on the block explorer, and the CLI will
automatically obtain the ABI and set up your subgraph. The default settings will
generate an entity for each event.

## 2. Deploy and publish

### Deploy to Subgraph Studio

First, run these commands:

```bash
$ graph codegen
$ graph build
```

Then, run these to authenticate and deploy your subgraph. You can copy these
commands directly from your subgraph's page in Studio to include your specific
deploy key and subgraph slug:

```bash
$ graph auth <DEPLOY_KEY>
$ graph deploy <SUBGRAPH_SLUG>
```

You will be asked for a version label. You can enter something like v0.0.1, but
you're free to choose the format.

### Test your subgraph

You can test your subgraph by making a sample query in the playground section.
The Details tab will show you an API endpoint. You can use that endpoint to test
from your dapp.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/tooling/data_indexers/the-graph/playground.png"
      alt="alt text here"
    />
  </div>
</div>

### Publish your subgraph to The Graph's decentralized network

Once your subgraph is ready to be put into production, you can publish it to the
decentralized network. On your subgraph's page in Subgraph Studio, click on the
Publish button:

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/tooling/data_indexers/the-graph/publish-button.png"
      alt="alt text here"
    />
  </div>
</div>

Before you can query your subgraph, Indexers need to begin serving queries on
it. In order to streamline this process, you can curate your own subgraph using
GRT.

When publishing, you'll see the option to curate your subgraph. As of May 2024,
it is recommended that you curate your own subgraph with at least 3,000 GRT to
ensure that it is indexed and available for querying as soon as possible.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/tooling/data_indexers/the-graph/publish-screen.png"
      alt="alt text here"
    />
  </div>
</div>

> **Note:** The Graph's smart contracts are all on Arbitrum One, even though
> your subgraph is indexing data from Ethereum, BSC or any other
> [supported chain](https://thegraph.com/docs/en/developing/supported-networks/).

## 3. Query your subgraph

Congratulations! You can now query your subgraph on the decentralized network!

To query any subgraph on the decentralized network, pass a GraphQL query into
the subgraph's query URL, which can be found at the top of its Explorer page.

Here's an example from the
[CryptoPunks Ethereum subgraph](https://thegraph.com/explorer/subgraphs/HdVdERFUe8h61vm2fDyycHgxjsde5PbB832NHgJfZNqK)
by Messari:

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/tooling/data_indexers/the-graph/query-url.png"
      alt="alt text here"
    />
  </div>
</div>

The query URL for this subgraph is:

`https://gateway-arbitrum.network.thegraph.com/api/`**[api-key]**`/subgraphs/id/HdVdERFUe8h61vm2fDyycgxjsde5PbB832NHgJfZNqK`

Now, you simply need to fill in your own API Key to start sending GraphQL
queries to this endpoint.

### Get your own API key

In Subgraph Studio, you'll see the "API Keys" menu at the top of the page. Here,
you can create API Keys.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/tooling/data_indexers/the-graph/api-keys.png"
      alt="alt text here"
    />
  </div>
</div>

## Appendix

### Sample query

This query shows the most expensive CryptoPunks sold.

```graphql
{
  trades(orderBy: priceETH, orderDirection: desc) {
    priceETH
    tokenId
  }
}
```

Passing this into the query URL returns this result:

```
{
  "data": {
    "trades": [
      {
        "priceETH": "124457.067524886018255505",
        "tokenId": "9998"
      },
      {
        "priceETH": "8000",
        "tokenId": "5822"
      },
//      ...
```

### Sample code

```jsx
const axios = require("axios");

const graphqlQuery = `{
  trades(orderBy: priceETH, orderDirection: desc) {
    priceETH
    tokenId
  }
}`;
const queryUrl =
  "https://gateway-arbitrum.network.thegraph.com/api/[api-key]/subgraphs/id/HdVdERFUe8h61vm2fDyycHgxjsde5PbB832NHgJfZNqK";

const graphQLRequest = {
  method: "post",
  url: queryUrl,
  data: {
    query: graphqlQuery,
  },
};

// Send the GraphQL query
axios(graphQLRequest)
  .then((response) => {
    // Handle the response here
    const data = response.data.data;
    console.log(data);
  })
  .catch((error) => {
    // Handle any errors
    console.error(error);
  });
```

### Additional resources

- To explore all the ways you can optimize and customize your subgraph for better
  performance, read more about
  [creating a subgraph here](https://thegraph.com/docs/en/developing/creating-a-subgraph/).
- To learn more about
  [querying data from your subgraph](https://thegraph.com/docs/en/querying/querying-the-graph/).
- [Subgraph Studio](https://thegraph.com/studio/).


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/mobula.mdx ====================

---
title: Mobula
image: /img/socialCards/mobula.jpg
---

[Mobula](https://docs.mobula.io) is a specialized data layer that offers
Octoflow, a system designed to stream any onchain action, including events,
traces, transactions, and blocks. Octoflow enables users to access real-time
blockchain data to perform analytics and extract actionable insights. Octoflow's
capabilities democratize the analysis of blockchain events, improving users'
ability to conduct detailed investigations and derive strategic advantages.
Octoflow equips users with the tools needed to navigate the complexities of the
blockchain with confidence and precision.

## Get started

To leverage onchain insights with data indexing technology, consider using
[Mobula's](https://docs.mobula.io) Octoflow.

[Create a room with the Mobula core team](https://t.me/MobulaPartnerBot?start=Linea_Docs_Octoflow).

## Additional resources

- **[Dive into the documentation](https://docs.mobula.io)** - Delve into
  [Mobula's](https://docs.mobula.io) extensive documentation, from API
  guidelines to tutorials.
- **[Explore the Mobula app](https://mobula.io)** - Access the [Mobula](https://mobula.io) 
  app, designed for ease-of-integration and enriched with data insights.
- Follow us on [X](https://x.com/MobulaIO) and keep in touch via [Telegram](https://t.me/MobulaFI).


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/alchemy.mdx ====================

---
title: Alchemy
image: /img/socialCards/alchemy.jpg
---

Alchemy Subgraphs is a blockchain indexing platform with drop-in support for
hosted subgraphs.

Subgraphs are an open-source tool for building custom GraphQL APIs from on-chain
data.

Identify on-chain events you want to index, write AssemblyScript handlers to
transform them into your preferred format, and let the subgraph automatically
ingest new events for you immediately as they happen.

## Why subgraphs?

Developing an in-house indexing system is time-consuming, expensive, and
requires ongoing expertise in data pipelines, devOps, and more.

Subgraphs handle the intricacies of data ingestion, decoding, and database
management for you. Just define the data format you want and query live data
through a GraphQL API.

## Why Alchemy Subgraphs?

- **Simple and reliable.** We make payment easy (just a credit card, no staking
  tokens) and have guaranteed uptime.
- **Developer tooling.** Access developer tools like error logs, subgraph
  versioning, indexing performance metrics, and more.
- **Easy migration.** If you have existing subgraphs, it takes just 5 minutes to
  switch over using the familiar command line tools.

## Get started

- [Subgraphs quickstart](https://docs.alchemy.com/reference/subgraphs-quickstart)
- [Deploying a Subgraph](https://docs.alchemy.com/reference/deploying-a-subgraph)

## Help

Email [subgraphs@alchemy.com](mailto:subgraphs@alchemy.com) with any questions.


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/noves.mdx ====================

---
title: Noves
image: /img/socialCards/noves.jpg
---

Noves is a leading provider of interpreted, human-readable data in the EVM
space. Our flagship product, [Translate API](https://docs.noves.fi/reference/introduction), 
allows developers to retrieve transactions in enriched, human-readable form.

For a sample, check out [Linea for Humans](https://linea.forhumans.app), a
human-readable block explorer built by Noves for Linea.

Translate covers more than 50 transaction types in its interpretation schema,
including common transactions such as claiming rewards or staking (across
thousands of protocols), but also more niche types such as governance
delegation, MEV, NFT transformations, and [more](https://docs.noves.fi/reference/token).

## Cross-DEX pricing data

The Pricing API supports many DEX protocols on Linea, allowing developers to
price a variety of tokens and LP tokens on the chain.

The API also offers historical pricing with block-level granularity. The price
of any token/LP token can be requested as of a specific block. This is
particularly useful for financial applications or reporting, where establishing
a precise cost-basis is necessary.

## Learn more

Find out more about Noves: [noves.fi](https://noves.fi)

Product docs: [docs.noves.fi](https://docs.noves.fi)

## Start for free

A free plan is available for Linea users. Click [here](https://noves.fi/pricing)
to sign up.


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/sentio.mdx ====================

---
title: Sentio
image: /img/socialCards/sentio.jpg
---

Sentio is an integrated, hosted, and modern analytics, monitoring, alerting, and
debugging tool for decentralized applications.

You can use Sentio's SDK to collect and transform [metrics](https://docs.sentio.xyz/docs/metrics) 
and [event logs](https://docs.sentio.xyz/docs/event-logs) generated based on 
their smart contracts' events, transactions, traces and states. Sentio fully 
manages the indexing process, and users can visualize data in the [dashboard](https://docs.sentio.xyz/docs/dashboard), 
set up [alerts](https://docs.sentio.xyz/docs/alerts), perform advanced search on 
the logs, and dig into a transaction via [Sentio debugger](https://docs.sentio.xyz/docs/debugger-overview), 
all via Sentio's web interface.

<div class="center-container">
  <div class="img-large">
      <img
        src="/img/get_started/tooling/data_indexers/sentio/Sentio_dashboard.png"
        alt="Sentio dashboard"
      />
  </div>
</div>

## Get started

We've put together some helpful guides for you to get set up with our product
quickly. Sentio supports [multi-chain](https://docs.sentio.xyz/docs/multi-chain). 
Simply use the network option below inside Sentio processor and select Linea.

```
EthChainId.LINEA
```

[**Quickstart**](https://docs.sentio.xyz/docs/quickstart)

[**Samples**](https://docs.sentio.xyz/docs/examples)

## Get help

If your issue can't be resolved in the docs, please contact us:

- [Telegram](https://t.me/sentioxyz)
- [Discord](https://discord.gg/vSdkMYqnjb)
- Email: [support@sentio.xyz](mailto:support@sentio.xyz)


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/bitscrunch.mdx ====================

---
title: bitsCrunch
description: bitsCrunch is an AI-enabled decentralized blockchain data network
image: /img/socialCards/bitscrunch.jpg
---

# bitsCrunch

bitsCrunch is an AI-powered onchain data indexer which offers 100+ endpoints for NFTs, wallets, tokens, DeFi and more, all through a single API. Along with providing access to the most comprehensive onchain data set, it also offers exclusive AI analytics like IP infringement detection and asset price estimation.

## Integrate bitsCrunch to get access to:

1. **NFT data and analytics** - NFT metadata, transaction history, wash trading detection and more
2. **Token data and analytics** -  Token price, liquidity, reputation scores and more
3. **Wallet data and analytics** - Wallet portfolio tracking, history, reputation scores and more
4. **Gaming data and analytics** - Engagement rates, revenue tracking, active wallets and more
5. **DeFi data and analytics** - TVL, liquidity pools, positions tracking and more
6. **AI solutions** - Asset price estimation, IP protection, sentiment analysis and more

## Get started:

### 1. Read the [documentation](https://docs.unleashnfts.com/docs/about) and get your free [API Key](https://unleashnfts.com/pricing)
### 2. Join the [bitsCrunch Network Ecosystem](https://docs.bitscrunch.com/docs/overview/about)

## Reference links

- [bitsCrunch](https://bitscrunch.com/)
- [UnleashNFTs](https://unleashnfts.com/)
- [bitsCrunch network interface](https://app.bitscrunch.com/)

## Need help?

Email [support@bitscrunch.com](mailto:support@bitscrunch.com) with any questions.


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/nftscan.mdx ====================

---
title: NFTScan
image: /img/socialCards/nftscan.jpg
---

The increasing demand for NFTs has brought attention to the importance of having
efficient tools to keep track of their creation, movement, and trading
activities. For companies and developers involved in NFTs, being able to monitor
minting events is crucial, especially with the growth of NFT-based applications
that will be facilitated by Linea's scalability.

This article provides information on how you can utilize the NFTScan API to
monitor the full NFT data on Linea.

## Understanding NFTScan

NFTScan provides web3 developers with professional, comprehensive and
authoritative NFT data services and solutions. Through establishing the full NFT
data information of multiple blockchain networks with standardized indexing
methods, the NFTScan APIs help developers build new experiences retrieving NFTs.
We provide a set of endpoints that enable you to fetch ERC-721 and ERC-1155 NFT
assets as well as transactions, collections, marketplace statistics, and more.

## What can the NFTScan API provide?

NFTScan API indexes all core aspects of NFTs on multiple blockchains and
provides quick access to this through a suite of data-focused API endpoints. No
matter what you are building, NFTScan API will support the data you will need.

- **Retrieving NFTs**
- **Retrieving owners of NFTs**
- **Retrieving NFT transactions**
- **Retrieving NFT collections**
- **Obtain NFT marketplace statistics**
- **More custom services and solutions**

## Access the NFTScan NFT API

### 1. Create an NFTScan developer account

Before using the NFTScan API, you need to visit the developer website and create
an account. Go to the NFTScan official website and click the “Sign Up” button
for NFTScan API registration.

> _NFTScan Developer Platform:
> [https://developer.nftscan.com/user/signup](https://developer.nftscan.com/user/signup)_

<div class="center-container">
  <div class="img-medium">
      <img
        src="/img/get_started/tooling/data_indexers/nftscan/Linea_NFTScan_create_account.png"
        alt="NFTScan sign up page"
      />
  </div>
</div>

After logging in, find your unique API key on the Dashboard and copy it. Visit
the API documentation and input your API key as guided. You can then start using
the API service. In the API documentation, developers can find various interface
modes to choose from based on their needs.

<div class="center-container">
  <div class="img-medium">
      <img
        src="/img/get_started/tooling/data_indexers/nftscan/Linea_NFTScan_add_API_key.png"
        alt="NFTScan API key"
      />
  </div>
</div>

In the Dashboard, developers can also view statistics on their API usage,
helping to track historical usage data. Moreover, NFTScan provides each
registered developer with 1M CU (Call Units) of API calls, allowing access to
all NFT API interfaces, and CU never expires.

<div class="center-container">
  <div class="img-medium">
      <img
        src="/img/get_started/tooling/data_indexers/nftscan/Linea_NFTScan_dashboard.png"
        alt="NFTScan dashboard"
      />
  </div>
</div>

### 2. View the NFTScan API documentation

After registering as a developer and obtaining your API key, review the NFTScan
API documentation, which includes available API endpoints and parameters and
detailed instructions on building requests and handling responses. Read the API
documentation carefully and ensure you understand how to use the API to retrieve
the data you need.

> _[NFTScan API Documentation](https://docs.nftscan.com)_

NFTScan API services aim to enhance developers' experience of obtaining NFT data
analysis. NFTScan currently has the largest and most comprehensive NFT
Collection library, supporting full NFT data on 16 blockchains: Ethereum,
Solana, BNBChain, Bitcoin, Polygon, zkSync, Aptos, Linea, Avalanche, Arbitrum,
Optimism, Fantom, Moonbeam, PlatON, Cronos, and Gnosis.

The covered NFT data is diverse, providing a complete set of interfaces for
accessing ERC-721 and ERC-1155 assets, transactions, projects, market
statistics, and more. It supports over 50 public interfaces for EVM-compatible
chains and a set of similar interfaces for Solana, Aptos, and Bitcoin,
satisfying developers' needs for indexing various types of NFT data.

<div class="center-container">
  <div class="img-large">
      <img
        src="/img/get_started/tooling/data_indexers/nftscan/Linea_NFTScan_API_documentation.png"
        alt="NFTScan API documentation"
      />
  </div>
</div>

### 3. Set the chain to Linea

In the API documentation, you'll notice a section for selecting the blockchain.
Make sure to set it to Linea to ensure you're retrieving NFT data specifically
from the Linea blockchain.

<div class="center-container">
  <div class="img-large">
      <img
        src="/img/get_started/tooling/data_indexers/nftscan/Linea_NFTScan_set_chain_to_Linea.png"
        alt="NFTScan set chain to Linea"
      />
  </div>
</div>

### 4. Querying relevant API requests

Now that you've configured the blockchain to Linea, you can start using the API
endpoints tailored to your specific needs. NFTScan offers a wide range of API
endpoints, each designed for various purposes.

<div class="center-container">
  <div class="img-large">
      <img
        src="/img/get_started/tooling/data_indexers/nftscan/Linea_NFTScan_querying_API_requests.png"
        alt="NFTScan querying API requests"
      />
  </div>
</div>

- **[Retrieve Assets](https://docs.nftscan.com/reference/evm/get-nfts-by-account):**
  A core API for retrieving NFT asset data. The core data model in NFTScan API
  is Assets, representing unique digital items. It includes contract addresses,
  contract names, token IDs, ERC protocol standards, metadata JSON, image URIs,
  holders, rarity rankings, and data about NFT projects, asset lists, and
  details.
- **[Retrieve Transactions](https://docs.nftscan.com/reference/evm/get-transactions-by-account):**
  This API retrieves NFT transaction records, comprehensively recording NFT
  trade markets and transaction contract information on various blockchain
  networks. It offers analysis based on contract source codes and transaction
  logs, contributing to data parsing logic.
- **[Retrieve Collections](https://docs.nftscan.com/reference/evm/get-an-nft-collection):**
  This API retrieves NFT Collection asset data, providing essential information
  about NFT Collections and the data held by wallet addresses. Descriptions,
  social media, and other basic information about NFT Collections can be
  obtained through APIs offered by leading NFT markets on various blockchain
  networks. Additionally, floor price information is centralized data obtained
  through APIs based on market orders.
- **[Collection Statistics](https://docs.nftscan.com/reference/evm/collection-statistics):**
  This API provides statistics for NFT Collections, offering key statistical
  indicators such as holder distribution, circulation rate, trading volume, and
  price trends. These statistics are useful for product design, market research,
  and asset evaluation.
- **[Account Statistics](https://docs.nftscan.com/reference/evm/account-overview-statistics):**
  This API offers comprehensive statistics for NFT user accounts, providing core
  statistical indicators such as the number of NFTs held, total value held, and
  historical transaction data. This data is essential for product design, user
  research, customer profiling, and more.
- **[Analytic Statistics](https://docs.nftscan.com/reference/evm/trade-ranking):**
  This API offers in-depth analysis of NFT data, such as NFT ranking, trend
  forecasts, and more, supporting data-driven decision-making and strategic
  planning.

### 5. Build relevant NFT requests

Constructing NFT-related requests with NFTScan is straightforward. Developers
only need to find the desired interfaces in the API documentation, review
interface addresses, request methods, and parameters. Based on their programming
language of choice, such as JavaScript, Python, Java, etc., developers can use
the respective HTTP request libraries to send requests to the interface
addresses, including necessary headers and parameters.

## Conclusion

NFTScan provides a customized NFT data retrieval experience that is different
from traditional blockchain data platforms. This not only enriches applications'
functionality, but also greatly reduces the cost of developers obtaining and
processing NFT data. Developers can flexibly access the rich NFT data resources
provided by NFTScan based on their application requirements, and freely combine
APIs according to business scenarios, building NFT applications and solutions
that meet their specific needs.

## Resources

- [NFTScan](https://nftscan.com/)
- [NFTScan Developer Platform](https://developer.nftscan.com/)
- [NFTScan API docs](https://docs.nftscan.com)


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/index.mdx ====================

---
title: Data indexers
image: /img/socialCards/data-indexers.jpg
---

import DocCardList from "@theme/DocCardList";

<DocCardList />


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/covalent.mdx ====================

---
title: Covalent
image: /img/socialCards/covalent.jpg
---

[GoldRush](https://goldrush.dev/?utm_source=linea&utm_medium=partner-docs),
powered by Covalent, is a set of data tools that support web3 development across
[200+ supported blockchains](https://goldrush.dev/docs/networks/?utm_source=linea&utm_medium=partner-docs),
including Linea Mainnet and Linea Sepolia. The mission of GoldRush is to improve
the lives of developers by providing structured onchain data for dapps.

Developers can utilize GoldRush via SDKs, APIs, UI Kits, human-readable
transactions and pre-built templates for multiple web3 use cases. The GoldRush
suite is powered by Covalent, which is decentralized and cryptographically
secure.

With GoldRush, you have access to:

- Every wallet's token balances
- Full transaction histories
- Every contract log event
- All NFTs including assets and metadata

**Use GoldRush if you need:**

- Wallet, Transactions, NFT, DEX, Staking or core blockchain data (i.e. log
  events, blocks, gas)
- Normalized, aggregated and enhanced multichain data, beyond what you get from
  RPC providers

> [Sign up to start building on Linea](https://goldrush.dev/platform/?utm_source=linea&utm_medium=partner-docs)

## APIs

The GoldRush APIs enables developers to quickly and easily access structured
onchain data. This means consistent response schemas that are blockchain
agnostic. Available APIs and corresponding use cases include:

### Wallet API

- **Features:** All token balances (ERC20, 721, 1155, native), token transfers
  and prices (spot and historical) for a wallet.
- **Use cases:** [Wallets, portfolio trackers](https://goldrush-wallet-portfolio-ui.vercel.app/?utm_source=linea&utm_medium=partner-docs),
  token gating, airdrop snapshots.

### Transactions API

- **Features:** All historical transactions with human-readable log events.
  Includes gas usage/spend summaries.
- **Use cases:** [Accounting and tax tools](https://bit.ly/crypto-tax-tool),
  branded in-app [transaction receipts](https://goldrush-dfk-tx-receipt-ui.vercel.app/tx/defi-kingdoms-mainnet/0x4e5c0af28b2cea27d06677fae1f573572e0ff863c43ae42d2959ca67b90c4390/?utm_source=linea&utm_medium=partner-docs).

### NFT API

- **Features:** Media assets, metadata, sales, owners, trait & attribute
  filters, thumbnails, and previews.
- **Use cases:** [NFT galleries and marketplaces](https://goldrush-nft-gallery-ui.vercel.app/?utm_source=linea&utm_medium=partner-docs),
  real world asset (RWA) tracking, token gating.

### Cross-Chain Activity API

- **Features:** Single API call to fetch a list of active chains and the latest
  transaction date on each for an address.
- **Use cases:** [App onboarding](https://goldrush-wallet-portfolio-ui.vercel.app/activity/0xfc43f5f9dd45258b3aff31bdbe6561d97e8b71de/?utm_source=linea&utm_medium=partner-docs).

### Security API

- **Features:** NFT and ERC20 token allowances, including value-at-risk.
- **Use cases:** [Revoke features](https://goldrush-revokehub.vercel.app/?utm_source=linea&utm_medium=partner-docs)
  in wallets, security applications.

### Blockchain API

- **Features:** Block details, log events by contract address or topic hash, gas
  prices, token prices and holders.
- **Use cases:** [Custom block explorers](https://goldrush-block-explorer-ui.vercel.app/?utm_source=linea&utm_medium=partner-docs).

## Developer Tools

There are four primary developer tools for using the APIs:

1.  [GoldRush API](https://goldrush.dev/docs/api/?utm_source=linea&utm_medium=partner-docs) -
    REST API with endpoints to use with any programming language. Switch
    blockchains with one path parameter.

        ```bash
        curl -X GET https://api.covalenthq.com/v1/linea-mainnet/address/0xc882b111a75c0c657fc507c04fbfcd2cc984f071/balances_v2/ \
            -H 'Content-Type: application/json' \
            -u YOUR_API_KEY:
        ```

2.  [GoldRush SDKs](https://goldrush.dev/docs/unified-api/sdk/?utm_source=linea&utm_medium=partner-docs) -
    official client libraries including TypeScript, Python, Go and Viem.

        ```jsx
        npm install @covalenthq/client-sdk
        ```


        ```jsx
        import { CovalentClient } from "@covalenthq/client-sdk";

        (async () => {
        try {
            const client = new CovalentClient("YOUR_API_KEY");
            const transactions = client.TransactionService.getAllTransactionsForAddress("linea-mainnet", "0xc882b111a75c0c657fc507c04fbfcd2cc984f071");

            for await (const tx of transactions) {
            console.log("tx", tx);
            }
        } catch (error) {
            console.log(error.message);
        }
        })();
        ```

3.  [GoldRush UI Kit](https://github.com/covalenthq/goldrush-kit/?utm_source=linea&utm_medium=partner-docs) -
    React components for your dApp frontend.

        [![GoldRush Component Example](https://datocms-assets.com/86369/1711147954-goldrush_wallet_ui_example.png)](https://goldrush-wallet-portfolio-ui.vercel.app/dashboard/balance/0xfc43f5f9dd45258b3aff31bdbe6561d97e8b71de/transfers/eth-mainnet/0xf8c3527cc04340b208c854e985240c02f7b7793f)

4.  [GoldRush Decoder](https://github.com/covalenthq/goldrush-decoder/?utm_source=linea&utm_medium=partner-docs) -
    decode any raw event logs into human-readable structured data.

        **Request:**
        ```bash
        curl -X POST http://localhost:8080/api/v1/tx/decode \
            -H 'Content-Type: application/json' \
            -d '{
                  "chain_name": "linea-mainnet",
                  "tx_hash": "0xfb6277bb32b5c5fb9c84925a42406ff47e65efd3b0eeea526f8d270429c9e453"
            }'
        ```

        **Custom decoded response:**
        ```json
        {
            "success": true,
            "events": [
                {
                    "action": "Transferred",
                    "category": "Token",
                    "name": "Transfer",
                    "protocol": {
                        "logo": "https://logos.covalenthq.com/tokens/59144/0xc1061a8315095945d83650a1ba28cd026d64cdb0.png",
                        "name": "SLToken1"
                    },
                    "details": [
                        {
                            "heading": "From",
                            "value": "0xb5c6a0625E6F01CAbF9DDBdf64AaAbd1B178e1E2",
                            "type": "address"
                        },
                        {
                            "heading": "To",
                            "value": "0xf081470f5C6FBCCF48cC4e5B82Dd926409DcdD67",
                            "type": "address"
                        }
                    ],
                    "tokens": [
                        {
                            "decimals": 18,
                            "heading": "Token Amount",
                            "pretty_quote": "$0.00",
                            "ticker_logo": "https://logos.covalenthq.com/tokens/59144/0xc1061a8315095945d83650a1ba28cd026d64cdb0.png",
                            "ticker_symbol": "SLTT1",
                            "value": "1000"
                        }
                    ]
                },
                {
                    "action": "Transferred",
                    "category": "Token",
                    "name": "Transfer",
                    "protocol": {
                        "logo": "https://logos.covalenthq.com/tokens/59144/0xc1061a8315095945d83650a1ba28cd026d64cdb0.png",
                        "name": "SLToken1"
                    },
                    "details": [
                        {
                            "heading": "From",
                            "value": "0xf081470f5C6FBCCF48cC4e5B82Dd926409DcdD67",
                            "type": "address"
                        },
                        {
                            "heading": "To",
                            "value": "0x7160570BB153Edd0Ea1775EC2b2Ac9b65F1aB61B",
                            "type": "address"
                        }
                    ],
                    "tokens": [
                        {
                            "decimals": 18,
                            "heading": "Token Amount",
                            "pretty_quote": "$0.00",
                            "ticker_logo": "https://logos.covalenthq.com/tokens/59144/0xc1061a8315095945d83650a1ba28cd026d64cdb0.png",
                            "ticker_symbol": "SLTT1",
                            "value": "1000"
                        }
                    ]
                },
                {
                    "action": "Transferred",
                    "category": "Token",
                    "name": "Transfer",
                    "protocol": {
                        "logo": "https://logos.covalenthq.com/tokens/59144/0xfe3b40b2d513b8e7ab3c7b6c758df3f00a2772dd.png",
                        "name": "SLToken5"
                    },
                    "details": [
                        {
                            "heading": "From",
                            "value": "0x7160570BB153Edd0Ea1775EC2b2Ac9b65F1aB61B",
                            "type": "address"
                        },
                        {
                            "heading": "To",
                            "value": "0xf081470f5C6FBCCF48cC4e5B82Dd926409DcdD67",
                            "type": "address"
                        }
                    ],
                    "tokens": [
                        {
                            "decimals": 18,
                            "heading": "Token Amount",
                            "pretty_quote": "$0.00",
                            "ticker_logo": "https://logos.covalenthq.com/tokens/59144/0xfe3b40b2d513b8e7ab3c7b6c758df3f00a2772dd.png",
                            "ticker_symbol": "SLTT5",
                            "value": "989"
                        }
                    ]
                },
                {
                    "action": "Transferred",
                    "category": "Token",
                    "name": "Transfer",
                    "protocol": {
                        "logo": "https://logos.covalenthq.com/tokens/59144/0xfe3b40b2d513b8e7ab3c7b6c758df3f00a2772dd.png",
                        "name": "SLToken5"
                    },
                    "details": [
                        {
                            "heading": "From",
                            "value": "0xf081470f5C6FBCCF48cC4e5B82Dd926409DcdD67",
                            "type": "address"
                        },
                        {
                            "heading": "To",
                            "value": "0xb5c6a0625E6F01CAbF9DDBdf64AaAbd1B178e1E2",
                            "type": "address"
                        }
                    ],
                    "tokens": [
                        {
                            "decimals": 18,
                            "heading": "Token Amount",
                            "pretty_quote": "$0.00",
                            "ticker_logo": "https://logos.covalenthq.com/tokens/59144/0xfe3b40b2d513b8e7ab3c7b6c758df3f00a2772dd.png",
                            "ticker_symbol": "SLTT5",
                            "value": "988"
                        }
                    ]
                },
                {
                    "action": "Account Abstraction Transaction",
                    "category": "Others",
                    "name": "User Operation Event",
                    "protocol": {
                        "logo": "https://logos.covalenthq.com/tokens/59144/0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789.png",
                        "name": "4337 Entry Point"
                    },
                    "details": [
                        {
                            "heading": "Gas Cost",
                            "value": "25590122985514",
                            "type": "text"
                        },
                        {
                            "heading": "Gas Used",
                            "value": "426502",
                            "type": "text"
                        },
                        {
                            "heading": "Paymaster",
                            "value": "0x0000000000000000000000000000000000000000",
                            "type": "address"
                        },
                        {
                            "heading": "Sender",
                            "value": "0xb5c6a0625E6F01CAbF9DDBdf64AaAbd1B178e1E2",
                            "type": "address"
                        },
                        {
                            "heading": "User Operation Hash",
                            "value": "0xfce86b467cae9f1375483acc23edaf5ead45f1fcff1939f06e00b28b2f776f94",
                            "type": "address"
                        }
                    ]
                }
            ],
            "tx_metadata": {
                ...
                },
                "explorers": [
                    {
                        "label": null,
                        "url": "https://lineascan.build/tx/0xfb6277bb32b5c5fb9c84925a42406ff47e65efd3b0eeea526f8d270429c9e453"
                    }
                ]
            }
        }
        ```

## Get started

- [API Key](https://goldrush.dev/platform/auth/register/?utm_source=linea&utm_medium=partner-docs) -
  sign up for free
- [Docs](https://goldrush.dev/docs/unified-api/?utm_source=linea&utm_medium=partner-docs) -
  comprehensive knowledge base for all things GoldRush
- [Guides](https://goldrush.dev/docs/unified-api/guides/?utm_source=linea&utm_medium=partner-docs) -
  learn how to build for various use cases and expand your onchain knowledge


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/scopescan.mdx ====================

---
title: Scopescan
image: /img/socialCards/scopescan.jpg
---

As web3 platforms, protocols, and dapps become more mainstream, there is an
increasing demand for these companies to know their users' behaviors and
connections. Having a partner that can help companies and developers understand
their users better is important for Linea and its mission to provide better
scalability.

This article provides information on using Scopescan and its analytical tools to
determine authentic users and their relations on Linea.

## Scopescan and its value

Understanding web3 users' patterns can be difficult, especially given that any
particular user can have multiple addresses and that web3 prioritizes privacy.
Unlike their web2 counterparts, web3 companies understandably have additional
hurdles to clear to fine-tune their products to users' evolving needs. This is
where Scopescan brings unique value to the Linea platform and its projects.

Scopescan is an onchain data analytics platform that allows the creation of
real-time profiles, called entities, with meaningful connections. It features an
extensive list of analytical tools that are built on user-based data and powered
by the 0xScope web3 AI Data Layer, for high-quality data extraction and
processing that meets the high data standards of AI solutions.

When Scopescan added Linea to its lineup of supported blockchains, it looked
into all the addresses of this chain and the relationships between these
addresses. This way, Scopescan users will be able to see the behavior of any
user on the Linea chain, and then discover connections between these users. When
Linea ecosystem projects leverage this entity-related information, they can
understand their users better and fine-tune their strategies to grow their user
base.

## Scopescan's analytical tools

Scopescan is equipped with a variety of tools that help the Linea community
better understand users, projects, and their interconnections. Here are the
three categories through which Scopescan's lineup of tools are categorized:

### 1. Discovery mode

In this mode, Scopescan users can find profiles of the top addresses, tokens,
and projects on Linea. These profile pages are comprehensive dashboards
containing relevant information about any entity on Linea. Below, you can see a
sample dashboard for Linea's projects and addresses.

<div class="center-container">
  <div class="img-large">
      <img
        src="/img/get_started/tooling/data_indexers/scopescan/Scopescan_for_linea_1.png"
      />
  </div>
</div>

<div class="center-container">
  <div class="img-large">
      <img
        src="/img/get_started/tooling/data_indexers/scopescan/Scopescan_for_linea_2.png"
      />
  </div>
</div>

### 2. Alpha hunting

This segment of Scopescan contains dashboards focused on identifying potential
alpha opportunities related to tokens and projects in the Linea ecosystem. The
Live Statistics dashboard (shown in the first picture below) displays statistics
such as active users, top gas spenders and consumers, and CEX activity on
Linea-supported tokens. There are other dashboards dedicated to whales, VCs, and
institutions affiliated with the Linea ecosystem. The second picture below is an
example of the Whale Watch dashboard.

In addition, you can create your own dashboard that can track specific addresses
on your radar, giving you a key advantage in tracking changes in user behaviors
and acting upon them.

<div class="center-container">
  <div class="img-large">
      <img
        src="/img/get_started/tooling/data_indexers/scopescan/Scopescan_for_linea_3.png"
      />
  </div>
</div>

<div class="center-container">
  <div class="img-large">
      <img
        src="/img/get_started/tooling/data_indexers/scopescan/Scopescan_for_linea_4.png"
      />
  </div>
</div>

### 3. Investigation mode

Under Investigation Mode, there are several tools focused on transactions and
token analytics. For instance, the Address Clustering tool (first picture below)
allows you to generate an address graph that visualizes likely connected
addresses, based on a search for a single address. Meanwhile, the Money Flow
tool (second picture below) allows users to investigate, track and share
relevant information on blockchain transactions.

<div class="center-container">
  <div class="img-large">
      <img
        src="/img/get_started/tooling/data_indexers/scopescan/Scopescan_for_linea_5.png"
      />
  </div>
</div>

<div class="center-container">
  <div class="img-large">
      <img
        src="/img/get_started/tooling/data_indexers/scopescan/Scopescan_for_linea_6.png"
      />
  </div>
</div>

There are more tools to discover. [Go to our docs](https://docs.scopescan.ai/)
for information about the complete suite of Scopescan's web3 analytical tools.

## Conclusion

Scopescan allows the Linea community to do the following:

- Discover new insights by exploring more than 10,000,000 data labels and tags
- Query complex onchain data points
- Explore real-world entities using our intuitive dashboards
- Analyze entity behavior across multiple chains, including Linea
- Get access to all kinds of onchain data including entities, behavior, web2
  social connections, and more
- Recognize real-time signals
- Leverage address tracking and monitoring for investigative and product
  enhancement purposes
- Get new insights into the companies behind web3 products

## Reference links:

- [Scopescan](https://scopescan.ai/home?network=linea)
- [Scopescan docs](https://docs.scopescan.ai)
- [Scopescan on 0xScope](https://0xscope.com/scopeScan)


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/dune.mdx ====================

---
title: Dune
image: /img/socialCards/dune.jpg
---

## Crypto's data platform

[Dune](https://dune.com/) is crypto's data platform. Teams and individuals alike
use Dune to explore, query, access, and export blockchain data. Dune's community
of data engineers, researchers, and analysts use the platform to gain deeper
insights into blockchain activity. Dune provides organized, decoded and
human-readable blockchain data, across 15+ chains and 1.5M datasets.

### Features

- **Data exploration**: Dune Analytics allows you to explore and analyze
  blockchain data using SQL queries. You can filter, aggregate, and visualize
  data to gain insights into blockchain activity.

- **Dashboards**: Create interactive dashboards to monitor key metrics and
  visualize data trends. Dune Analytics provides a drag-and-drop interface for
  designing custom dashboards.

- **Collaboration**: Share your queries, dashboards, and insights with others.
  Dune Analytics supports collaboration features, allowing you to work together
  with your team or the wider community.

- **API access**: Access blockchain data programmatically using Dune's API. You
  can integrate blockchain data into your applications, tools, and services.

- **Snowflake datashare**: Dune's Snowflake datashare allows you to access and
  analyze blockchain data directly in your Snowflake account. You can query and
  join blockchain data with your existing datasets in Snowflake.

### Resources

Here are some resources to help you learn more about Dune Analytics:

- [Documentation](https://docs.dune.com/): The official documentation provides
  detailed guides and tutorials on using Dune Analytics.

- [API Docs](https://docs.dune.com/api): The API documentation provides detailed
  information on how to access blockchain data programmatically using Dune's
  API.

- [YouTube](https://youtube.com/@dunecom) : The Dune YouTube channel
  features video tutorials and demos of the platform.

- [Blog](https://dune.com/blog): The Dune blog features articles, case studies,
  and updates about the platform.

- [Twitter](https://x.com/duneanalytics): Follow Dune Analytics on Twitter
  for the latest news and announcements.


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/moralis.mdx ====================

---
title: Moralis
image: /img/socialCards/moralis.jpg
---

[Moralis](https://moralis.io/?utm_source=linea-docs&utm_medium=partner-docs)
offers indexed and real-time crypto data APIs across [30+ chains](https://docs.moralis.io/supported-chains?utm_source=linea-docs&utm_medium=partner-docs),
including APIs for portfolio and wallet balances, NFT data, token data, price
data, candlestick data, net worth data, and more. All data is enhanced with
metadata, parsed events, address labels and wider offchain data for
comprehensive insights.

[Start building with using our docs.](https://moralis.io/chains/linea/?utm_source=linea-docs&utm_medium=partner-docs)

## Indexed data APIs

Moralis' Linea API integration supports:

- **[Wallet API](https://moralis.io/api/wallet/?utm_source=linea-docs&utm_medium=partner-docs)**:
  Insights into wallet balances, token balances, NFTs, wallet history,
  transactions, wallet net worth, and more.
- **[NFT API](https://moralis.io/api/nft/?utm_source=linea-docs&utm_medium=partner-docs)**:
  NFT metadata, transfers, owners, prices, and more.
- **[Token API](https://moralis.io/api/token/?utm_source=linea-docs&utm_medium=partner-docs)**:
  Token metadata, transfers, token approvals, prices, and more.
- **[Price API](https://moralis.io/api/price/?utm_source=linea-docs&utm_medium=partner-docs)**:
  NFT prices, token prices, candlestick data, and more.
- **[DeFi API](https://moralis.io/api/defi/?utm_source=linea-docs&utm_medium=partner-docs)**:
  DeFi balances, rewards, transactions, and more.
- **[Blockchain API](https://moralis.io/api/blockchain/?utm_source=linea-docs&utm_medium=partner-docs)**:
  Raw data such as blocks, transactions, and logs.

### Example features

Moralis indexed data APIs can be used for:

- Fetching all NFTs for a user's wallet
- Fetching all ERC20 tokens, with prices, for a user's wallet
- Fetching a decoded transaction history for a user's wallet
- Fetching NFT metadata for a given token
- Fetching the current price of an ERC20 token
- Detecting which chain(s) a given user wallet is active on

### Example use cases

Moralis indexed data APIs can be used to build:

- **Web3 wallets:** Integrating wallet functionalities such as displaying token
  balances, transaction history, and NFT holdings.
- **Portfolio pages:** Creating personalized portfolio trackers to monitor asset
  performance across multiple blockchains.
- **NFT marketplaces:** Building platforms for buying, selling, and trading NFTs
  by fetching and displaying NFT data.
- **DeFi platforms:** Integrating token and blockchain data to facilitate
  decentralized finance activities such as lending, borrowing, and trading.

## Real-time data APIs

Moralis' Linea real-time data integration supports:

- **[Streams API](https://moralis.io/streams/?utm_source=linea-docs&utm_medium=partner-docs)**:
  Stream blockchain data directly to your server via webhooks in real-time.
  Setup and configure advanced filters, or use any of our out-of-the-box
  configurations.

### Example features

Moralis real-time data APIs can be used for:

- Listening to transfer events for a given ERC20 token
- Listening to native transfer events for a given wallet
- Listening to token mints or burns
- Listening to transfer events for a given NFT collection
- Detecting activity across multiple addresses
- Tracking custom blockchain events

### Example use cases

Moralis real-time data APIs can be used to build:

- **In-app notifications:** Sending real-time alerts to users based on their
  wallet holdings, for events like token transfers, price changes, staking
  rewards etc. to increase engagement.
- **Real-time token balances:** Continuously updating and displaying users'
  wallet balances in real-time within dapps, enabling instant visibility into
  their current asset holdings and values.
- **Discord alerts:** Providing real-time updates to Discord communities about
  blockchain activities and token movements.
- **Build a database:** Track real-time events for specific events and store
  them in your database, ensuring that you maintain a comprehensive historical
  record of blockchain activities for a given wallet or contract.

## Get started

- [Sign up for a free account](https://moralis.io/?utm_source=linea-docs&utm_medium=partner-docs)
- Visit the [Moralis documentation](https://docs.moralis.io/?utm_source=linea-docs&utm_medium=partner-docs)
- Check out our [tutorials on Youtube](https://youtube.com/@MoralisWeb3).


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/reservoir.mdx ====================

---
title: Reservoir
image: /img/socialCards/reservoir.jpg
---

[Reservoir](https://reservoir.tools/) is a developer platform that lets you
interact with the NFT market using a single toolkit. With the tools, you can
build [custom marketplaces](https://docs.reservoir.tools/docs/custom-marketplaces),
[embed buying, selling](https://docs.reservoir.tools/docs/embedded-buying-selling),
and [minting](https://docs.reservoir.tools/docs/minting) into your app, and get
[distribution for your protocol's liquidity](https://docs.reservoir.tools/docs/how-to-get-distribution-for-your-protocol-using-reservoir),
among many other [use cases](https://docs.reservoir.tools/docs/custom-marketplaces). 
We run a hosted version of our API, but all the tools are open-source.

The platform is built on **The Reservoir Standard**, an open framework for
understanding the NFT market across marketplaces and chains. Together, these
pieces function as an interface that makes NFT markets composable, easy to
participate in, and aligned with the ethos of web3. Check out our tools:

## [NFT trading and data APIs](https://docs.reservoir.tools/reference/overview)

Reservoir APIs provide all-in-one endpoints for building NFT applications. The
NFT trading APIs allow you to trade NFTs across major NFT marketplaces and
create your own orders with advanced order types and custom fees. The NFT data
APIs provide granular token price data, real-time collection floor price and top
bid events, token and collection metadata, and more. The API is wrapped in a
[TS/JS SDK](https://docs.reservoir.tools/reference/reservoir-sdk-jstsnode) with
performant methods.

[Learn more about our NFT Trading & Data APIs](https://docs.reservoir.tools/reference/overview).

## [ReservoirKit](https://docs.reservoir.tools/reference/reservoirkit)

ReservoirKit is a React library that simplifies adding marketplace functionality
into your project. The kit has out of the box and customizable (headless) modals
for major market actions and a series of useful hooks to simplify development.

[Learn more about ReservoirKit](https://docs.reservoir.tools/reference/reservoirkit).

## [Open-source marketplace](https://docs.reservoir.tools/reference/open-source-marketplace)

Reservoir's open-source marketplace is a NextJS app that you can fork and use
freely as a standalone marketplace or a base for building something custom and
unique. [Check out our fully-functional reference deployment](https://marketplace.reservoir.tools/).

[Learn more about our Open-source Marketplace](https://docs.reservoir.tools/reference/open-source-marketplace).

## Why use Reservoir?

Interacting with the NFT market can be challenging. Reservoir simplifies the
process so you can spend your time focusing on your product's unique value-add
to the market.

### Developer-focused tooling

Reservoir allows you to build at your desired level of the stack. We provide a
modular set of tools that let you interact with the NFT market at the
appropriate level of abstraction for your application. Whether you wish to use
our router contracts directly, use our APIs for trade execution, or use
ReservoirKit to build a React app, we have you covered.

[Learn more about our tools](https://docs.reservoir.tools/docs/marketplace-toolkit).

### Abstracted orderbook and exchange

Reservoir treats the NFT market as one cohesive whole and abstracts the process
of interacting with individual orderbooks and exchanges. This means you get:

- **Upgrade protection** - Since Reservoir abstracts the orderbook and exchange,
  you get exchange and orderbook upgrades free and with no additional work. By
  default we use the Seaport exchange, as new features roll out, you will get
  them without any changes to your code.
- **Out of the box aggregation** - We aggregate all major marketplaces and
  normalize the liquidity so all orders are treated equally in our system. See a
  full list of aggregated marketplaces [here](https://docs.reservoir.tools/reference/supported-marketplaces). 
  We also aggregate bid liquidity from across the NFT ecosystem so your users 
  can sell instantly into the best available offer.
- **Order distribution** - Reservoir allows you to post your own orders with
  your desired fee structure. These orders are distributed to all Reservoir
  partner marketplaces and marketplaces that aggregate the Reservoir orderbook.
  Additionally, Reservoir allows you to cross post orders to other major
  marketplace orderbooks.

### Marketplace innovation

Reservoir is pushing the boundaries of NFT markets. We strive to build
best-in-class NFT market solutions. Here are just a few of the important
features we have released recently that you won't find anywhere else.

- [Royalty Compliance](https://docs.reservoir.tools/docs/royalties) - Leverage
  aggregated liquidity with normalized royalties, so you get all the NFT market
  liquidity while still respecting creator royalties.
- [Custom Fees](https://docs.reservoir.tools/docs/custom-fees) - Distribute
  orders across the NFT ecosystem with your own custom fee structure.
- [Cross-chain support](https://docs.reservoir.tools/reference/supported-chains) -
  Reservoir is currently live on Ethereum, Polygon and Optimism - with more
  chains on the way.
- [Instant Sell](https://docs.reservoir.tools/docs/add-instant-sell) -
  Aggregated bid liquidity allows your users to sell instantly into the best
  offer on the market.


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/subsquid.mdx ====================

---
title: Subsquid
image: /img/socialCards/subsquid.jpg
---

[Subsquid](https://subsquid.io/) is a decentralized indexing toolkit optimized
for batch extraction and processing of large volumes of data, achieving indexing
speed of up to 50k blocks per second. It currently serves historical on-chain
data including event logs, transaction receipts, traces and per-transaction
state diffs.


==================== FILE: /workspace/docs/get-started/tooling/data-indexers/etherscan.mdx ====================

---
title: Etherscan
description: Use one API key across multiple chains with the Etherscan API v2
image: /img/socialCards/etherscan.jpg
---

Use the Etherscan API v2 to access data across over 50 [supported chains](https://docs.etherscan.io/etherscan-v2/getting-started/supported-chains),
including Linea, with a single API key.

To get started, create an account on [Etherscan](https://etherscan.io/register),
and then head to the [API key page](https://etherscan.io/myapikey) and generate
a new key.

:::warning

Although you can use the same API key across multiple chains, you can only make
requests to one chain at a time.

:::

From here, you can use the API key in any request, defining the chains you want
to use it with:

```javascript
async function main() {
  // query ETH balances on Ethereum Mainnet and Linea

  const chains = [1, 59144];

  for (const chain of chains) {
    const query = await fetch(`https://api.etherscan.io/v2/api
           ?chainid=${chain}
           &module=account
           &action=balance
           &address=INSERT_ADDRESS
           &tag=latest&apikey=INSERT_API_KEY`);

    const response = await query.json();

    const balance = response.result;
    console.log(balance);
  }
}

main();
```

For full details of how to use the Etherscan API v2, see the [documentation](https://docs.etherscan.io/etherscan-v2).


==================== FILE: /workspace/docs/get-started/index.mdx ====================

---
title: Overview
description: Your starting point for building on Linea.
image: /img/socialCards/overview.jpg
---

Linea is a secure, low-cost, and Ethereum-equivalent layer 2 blockchain built to bring the world 
onchain without compromising on security and decentralization. 

Linea has been incubated within Consensys and will decentralize in 2025. 

Our mission is to empower developers to build the next generation of decentralized applications and 
onboard the next billion users to web3. 

## Security for all

Built as a layer above Ethereum, Linea inherits the robust security and decentralization of the 
Ethereum network while significantly increasing throughput and reducing transaction fees to 
negligible amounts. 

## Advanced zero-knowledge proof technology

By leveraging zero-knowledge (zk) proofs, Linea removes the seven-day lockup period associated with 
fraud proofs in other layer 2 solutions built according to the optimistic rollup model. Using zk
proofs ensures user funds are always available and can be withdrawn instantly and at no cost.

## True Ethereum equivalence

Linea supports all the features that Ethereum supports. It's the only zero-knowledge layer 2 network 
fully compatible with the Ethereum Virtual Machine (EVM). This means that any Ethereum-based 
projects and assets can be seamlessly deployed on and bridged to Linea without any code base 
changes. 

## Scale with MetaMask 

Linea is the best way for application developers to leverage MetaMask's products and distribution. 
Seamlessly integrate Linea through the MetaMask Developer portal, unlock easy on-ramping, bridging 
and swaps for your users, and access millions of the most engaged onchain users worldwide.


==================== FILE: /workspace/docs/get-started/how-to/get-testnet-eth.mdx ====================

---
title: Get Linea testnet ETH
description: Learn how to get testnet ETH for Linea Sepolia.
image: /img/socialCards/get-linea-testnet-eth.jpg
---

To get started with building on Linea you'll need some Linea Sepolia ETH. The most efficient method
is to use one of the many available faucets to drip testnet ETH directly to your chosen account.

## MetaMask faucet

The [MetaMask faucet](https://docs.metamask.io/developer-tools/faucet/) supports using Linea Names 
domains, and using one guarantees you'll receive the full 0.5 ETH daily maximum. [Learn how to get a
Linea Names domain](https://support.linea.build/explore/ens).

:::tip

See our [support guide to getting a Linea Names domain](https://support.linea.build/explore/ens).

:::

## Other faucets

- [Infura](https://infura.io/faucet/linea)
- [GetBlock](https://getblock.io/faucet/linea-sepolia/)
- [HackQuest](https://hackquest.io/en/faucets/59141) (and check out their [Linea Learning Track](https://hackquest.io/en/learning-track/9be129e7-575b-49bd-a64e-1bbe32427ace))

Alternatively, [use the Linea native bridge to bridge testnet ETH between Sepolia and Linea Sepolia](../how-to/bridge.mdx).

## Get testnet ERC-20 tokens

Testnet ERC-20 tokens may be useful for development purposes.

One method is to use the [OKX faucet](https://okx.com/xlayer/faucet/sepoliafaucet), which 
enables you to select from a handful of different testnet ERC-20 tokens.


==================== FILE: /workspace/docs/get-started/how-to/run-a-node/besu.mdx ====================

---
title: Besu
description: Install the Besu client to run a Linea node.
image: /img/socialCards/besu.jpg
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

import VolumeCreation from "./volume-creation.mdx";
import NodeSize from "../../../../src/components/NodeSize";
import LastUpdated from "../../../../src/components/LastUpdated";

[Besu](https://besu.hyperledger.org/) is an open-source Ethereum client developed under the
Apache 2.0 license and written in Java.

:::info important
Install and run a Besu node if you want to follow the Linea network by 
maintaining a local copy of the blockchain. However, if you want to interact with the network and use
Linea-specific methods and features, you should [install Linea Besu](./linea-besu.mdx) instead.
:::

You can run Besu from a [binary distribution](#run-using-the-binary-distribution) or [using Docker](#run-using-docker).

## Run using the binary distribution

### Step 1. Install Besu

[Download and install Besu](https://besu.hyperledger.org/public-networks/get-started/install/binary-distribution) using
the instructions in the official documentation. 

### Step 2. Download the genesis file and Besu configuration file 

Download the genesis file and Besu configuration file.

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
  
  Mainnet [`genesis-mainnet.json`](pathname:///files/besu/genesis-mainnet.json) file and Besu
  [`config-mainnet.toml`](pathname:///files/besu/config-mainnet.toml) file.

  :::note[bootnodes]
  You can choose from a range of bootnodes for Linea Mainnet. The above configuration file uses 
  all bootnodes by default.

  The [bootnodes page](bootnodes.mdx) contains a full list of available bootnodes.
  :::
  
  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
  
  Testnet [`genesis-sepolia.json`](pathname:///files/besu/genesis-sepolia.json) file and Besu
  [`config-sepolia.toml`](pathname:///files/besu/config-sepolia.toml) file.
  
  </TabItem>

</Tabs>

### Step 3. Define disk space volume (optional) \{#disk-space-besu}

Define a volume size appropriate to your expected usage. Besu nodes use: 

- Full node: <NodeSize network="mainnet" cluster="linea-prod-eks" pvc="data-linea-besu-full-0" />
- Archive node: <NodeSize network="mainnet" cluster="linea-prod-eks" pvc="data-linea-besu-archive-v3-0" />

<LastUpdated />

Use these figures as a basis to determine the extent to which you want to future-proof your node.

To limit disk space required, we recommend you configure Besu to use the [Bonsai](https://besu.hyperledger.org/public-networks/concepts/data-storage-formats#bonsai-tries)
data storage format, which prunes orphaned nodes and old branches.

Ensure you mount the Besu `data-path` to the custom volume when you start the node.

<VolumeCreation />

### Step 4. Configure the Besu configuration file

In your Besu configuration file (`config-mainnet.toml` or `config-sepolia.toml`), configure
the following options:

- Set `data-path` to the location you want to store your data. 
- Set `genesis-file` to the path of your downloaded genesis file.

### Step 5. Start the Besu client

Run the Besu client with the location of your configuration file. For example:

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
  
  ```bash
  besu --config-file=/Users/myuser/mainnet/config-mainnet.toml
  ```
  
  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
  
  ```bash
  besu --config-file=/Users/myuser/sepolia/config-sepolia.toml
  ```
  
  </TabItem>
</Tabs>

The Besu node will attempt to find peers to begin synchronizing and to download the world state. 

## Run using Docker

:::warning Important

The Besu Docker image doesn't run on Windows.

:::

### Prerequisites

Download and install [Docker](https://docker.com/products/docker-desktop/) and ensure it is 
running.

### Step 1. Download configuration files

Download the configuration files for the relevant network (in ZIP format) and extract them. The configuration
files include the network genesis file, Docker Compose file and Besu configuration file.

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
  
  Download the mainnet [`besu-mainnet` ZIP file](pathname:///files/besu/besu-mainnet.zip).

  :::note[bootnodes]
  You can choose from a range of bootnodes for Linea Mainnet. The Besu `.zip` includes a
  config file named `config-snap-mainnet.toml` where bootnodes are specified. The file uses all bootnodes
  by default.

  The [bootnodes page](bootnodes.mdx) contains a full list of available bootnodes.
  :::
  
  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
  
  Download the testnet [`besu-sepolia` ZIP file](pathname:///files/besu/besu-sepolia.zip).
  
  </TabItem>
</Tabs>

### Step 2. Update the Docker Compose file

In the `docker-compose.yaml` file, update the `--p2p-host` command to include your public IP address. For example:

```yaml
--p2p-host=103.10.10.10
```

:::tip

You can use [this page](https://whatismyip.com/) to find your public IP address.

:::

### Step 3. Start the Besu node

Open a terminal, in the directory containing the `docker-compose.yml` file, run `docker-compose up`. 

It can take up to 20 minutes for the node to find peers. If it takes any longer than that, try restarting the node.

:::tip Troubleshoot peering issues

Refer to the [Besu troubleshooting information](https://besu.hyperledger.org/public-networks/how-to/troubleshoot/peering)
for help if you experience peering issues.   

:::

## Confirm the node is running

You can call the JSON-RPC API methods to confirm the node is running. For example, call
[`eth_syncing`](https://besu.hyperledger.org/public-networks/reference/api#eth_syncing) to return the synchronization status.
For example the starting, current, and highest block, or `false` if not synchronizing (or if the head of the chain has been reached).

```bash

curl localhost:8545 \
        -X POST \
        -H "Content-Type: application/json" \
        -d '{"jsonrpc":"2.0","method":"eth_syncing","params":[],"id":1}'

```

You should get a result similar to:

```bash
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "startingBlock": "0x0",
    "currentBlock": "0x5d228",
    "highestBlock": "0x3cedec"
  }
}
```


==================== FILE: /workspace/docs/get-started/how-to/run-a-node/nethermind.mdx ====================

---
title: Nethermind
description: Install the Nethermind client to run a Linea node.
image: /img/socialCards/nethermind.jpg
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Nethermind is a high-performance Ethereum client written in C# that supports various networks, including Linea.

:::info important
Install and run a Nethermind client if you want to follow the Linea network by 
maintaining a local copy of the blockchain. However, if you want to interact with the network and use
Linea-specific methods and features, you should [install Linea Besu](./linea-besu.mdx) instead.
:::

## Run using the binary distribution

:::info
Ensure you review [Nethermind's installation Guidelines](https://docs.nethermind.io/get-started/installing-nethermind) 
before installing the Nethermind client.

If you're not comfortable with installing the binary distribution, consider using [Docker](#run-using-docker) 
instead.
:::

### Step 1. Install Nethermind

[Download and install the Nethermind client](https://docs.nethermind.io/get-started/installing-nethermind/#standalone-downloads).

### Step 2. Start the Nethermind client

Start the node using the following command:

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
  
    ```bash
    nethermind \
    --datadir ./nethermind-data \
    --config linea-mainnet \
    --JsonRpc.Enabled=true \
    --JsonRpc.Host=0.0.0.0 \
    --JsonRpc.Port=8545 \
    --Metrics.Enabled=true \
    --Metrics.ExposePort=8008
    ```

  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
  
    ```bash
    nethermind \
    --datadir ./nethermind-data \
    --config linea-sepolia \
    --JsonRpc.Enabled=true \
    --JsonRpc.Host=0.0.0.0 \
    --JsonRpc.Port=8545 \
    --Metrics.Enabled=true \
    --Metrics.ExposePort=8008
    ```
  </TabItem>
</Tabs>

The Nethermind node will attempt to find peers to begin synchronizing and to download the world 
state.

## Run using Docker

### Prerequisites

Download and install [Docker](https://docker.com/products/docker-desktop/) and ensure it is 
running throughout.

### Step 1. Download Docker image

Download the Nethermind docker image:

```
docker pull nethermind/nethermind:latest
```

### Step 2. Start the Nethermind node

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
  
    ```bash
    docker run -it \
  -v nethermind_data:/nethermind/nethermind_db \
  -p 8545:8545 \
  -p 8008:8008 \
  nethermind/nethermind \
  --datadir /nethermind/nethermind_db \
  --config linea-mainnet \
  --JsonRpc.Enabled=true \
  --JsonRpc.Host=0.0.0.0 \
  --JsonRpc.Port=8545 \
  --Metrics.Enabled=true \
  --Metrics.ExposePort=8008
    ```

  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
  
    ```bash
    docker run -it \
  -v nethermind_data:/nethermind/nethermind_db \
  -p 8545:8545 \
  -p 8008:8008 \
  nethermind/nethermind \
  --datadir /nethermind/nethermind_db \
  --config linea-sepolia \
  --JsonRpc.Enabled=true \
  --JsonRpc.Host=0.0.0.0 \
  --JsonRpc.Port=8545 \
  --Metrics.Enabled=true \
  --Metrics.ExposePort=8008
    ```
  </TabItem>
</Tabs>

:::note

Ensure that you correctly configure the Docker volume to persist data between container restarts. 
Without proper volume setup, data will be lost when the container is stopped. 
Additionally, make sure to expose the necessary ports (e.g., 8545 for JSON-RPC and 8008 for metrics) 
to enable external access to these services.

:::

## Confirm the node is running

You can call the JSON-RPC API methods to confirm the node is running. For example, call
`eth_syncing` to return the synchronization status.
For example the starting, current, and highest block, or `false` if not synchronizing (or if the head of the chain has been reached).

```bash
curl localhost:8545 \
        -X POST \
        -H "Content-Type: application/json" \
        -d '{"jsonrpc":"2.0","method":"eth_syncing","params":[],"id":1}'
```

You should get a result similar to:

```bash
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "startingBlock": "0x0",
    "currentBlock": "0x5d228",
    "highestBlock": "0x3cedec"
  }
}
```



==================== FILE: /workspace/docs/get-started/how-to/run-a-node/linea-besu.mdx ====================

---
title: Linea Besu
description: Install the Besu client to run a Linea node.
image: /img/socialCards/linea-besu.jpg
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

import VolumeCreation from "./volume-creation.mdx";
import NodeSize from "../../../../src/components/NodeSize";
import LastUpdated from "../../../../src/components/LastUpdated";

Linea Besu is an implementation of the Besu client that extends its functionality using plugins
adapted specifically for Linea, such as the
[Linea Sequencer plugin](https://github.com/Consensys/linea-sequencer).

Plugins enable full functionality for the node. For example,
Linea-specific API endpoints like `linea_estimateGas` require the `linea-sequencer` plugin.
Plugins are installed with the `advanced` profile during the configuration steps.

:::warning

The `advanced` profile option doesn't currently support macOS/ARM. Please use 
Linux/ARM or Windows/X86_64. 

:::

We recommend using Linea Besu over standard Besu if you intend to run a node to interact 
with the blockchain, rather than just following it. Use Linea Besu if:
- You are responsible for operating nodes as a service for others to use.
- You want to use Linea with a personal, private RPC endpoint.

## Run using the binary distribution

### Step 1. Download the Linea Besu package

[Download the latest version](https://github.com/Consensys/linea-monorepo/releases) of the
Linea Besu package from the releases page.

:::note
Find the **Assets** subheading on the latest release and download the file named
`linea-besu-package-<version>.tar.gz`.
:::

### Step 2. Extract the package contents

The `linea-besu-package-<version>.tar.gz` is a compressed file; move it to the directory of your choice 
and extract it.

```bash
tar -xzvf linea-besu-package-<version>.tar.gz
```

### Step 3. Define disk space volume (optional) \{#disk-space-besu}

Define a volume size appropriate to your expected usage. Besu nodes use: 

- Full node: <NodeSize network="mainnet" cluster="linea-prod-eks" pvc="data-linea-besu-full-0" />
- Archive node: <NodeSize network="mainnet" cluster="linea-prod-eks" pvc="data-linea-besu-archive-v3-0" />

<LastUpdated />

Use these figures as a basis to determine the extent to which you want to future-proof your node.

Ensure you mount the `data-path` to the custom volume when you start the node.

<VolumeCreation />

### Step 4. Select a profile

In the extracted directory, find `profiles`. The `.toml` configuration files in this folder define 
the parameters for each possible profile you can select for your Linea Besu node. 

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
    Select one according to your preferences:
    - `basic-mainnet`: Creates a basic follower node on Linea Mainnet with no plugins enabled.
    - `advanced-mainnet`: Creates an advanced node on Linea Mainnet with plugins that enable support for
    `linea_estimateGas` and the `finalized` block parameter tag.
  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
    Select one according to your preferences:
    - `basic-sepolia`: Creates a basic follower node on Linea Sepolia with no plugins enabled.
    - `advanced-sepolia`: Creates an advanced node on Linea Sepolia with plugins that enable support for
    `linea_estimateGas` and the `finalized` block parameter tag.
  </TabItem>
</Tabs>

### Step 5. Start the Linea Besu client

In a terminal, navigate to the `linea-besu-package-<version>` directory, where the `bin`, `genesis`, 
`profiles` etc. directories are. 

Now run Linea Besu, specifying your preferred profile. The `--plugin-linea-l1-rpc-endpoint` must 
only be defined if you are running an `advanced` node, since this is needed to query finalization
on L1.

<Tabs groupId="networks" className="my-tabs">
    <TabItem value="mainnet" label="Mainnet">
    ```bash
    bin/besu --profile=advanced-mainnet --plugin-linea-l1-rpc-endpoint=YOUR_L1_RPC_ENDPOINT
    ```
    </TabItem>
    <TabItem value="Linea Sepolia" label="Linea Sepolia">
    ```bash
    bin/besu --profile=advanced-sepolia --plugin-linea-l1-rpc-endpoint=YOUR_L1_RPC_ENDPOINT
    ```
    </TabItem>
</Tabs>

The node will attempt to find peers to begin synchronizing and to download the world state.

## Run using Docker

### Prerequisites

Download and install [Docker](https://docker.com/products/docker-desktop/) and ensure it is 
running.

### Step 1. Download the relevant `docker-compose.yaml` file

Access the [`/docker` directory](https://github.com/Consensys/linea-monorepo/tree/main/linea-besu-package/docker) 
in the Linea Besu repository. There are several `.yaml` files here corresponding to Besu profiles. 
Each profile enables you to run a node with different Linea Besu plugin configurations depending on
your use case.

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
    Download the appropriate `.yaml` file for your use case:
    - `basic-mainnet`: Creates a basic follower node on Linea Mainnet with no plugins enabled.
    - `advanced-mainnet`: Creates an advanced node on Linea Mainnet with plugins that enable support 
    for `linea_estimateGas` and the `finalized` block parameter tag.
  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
    Download the appropriate `.yaml` file for your use case:
    - `basic-sepolia`: Creates a basic follower node on Linea Sepolia with no plugins enabled.
    - `advanced-sepolia`: Creates an advanced node on Linea Sepolia with plugins that enable support 
    for `linea_estimateGas` and the `finalized` block parameter tag.
  </TabItem>
</Tabs>

### Step 2. Update IP address

In the `.yaml` file you downloaded, adjust the `--p2p-host` command with your public IP address:

```yaml
--p2p-host=103.10.10.10
```

:::tip

You can use [this page](https://whatismyip.com/) to find your public IP address.

:::

### Step 3. Configure your L1 RPC endpoint

If you're using an `advanced` profile, insert your preferred L1 RPC endpoint in the 
`docker-compose.yaml` file:

```yaml
--plugin-linea-l1-rpc-endpoint=YOUR_L1_RPC_ENDPOINT
```

If you only intend to run a `basic` profile, go straight to the next step.

### Step 4. Start the Linea Besu node

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
    In a terminal, navigate to your `.yaml` file's directory. Then start the node by running 
    `docker compose`: 

    ```bash
    docker compose -f ./your-file-path/docker-compose-advanced-mainnet.yaml up
    ```

    Alternatively, you can run a node without downloading a `.yaml` file with a `docker run` command. 
    For example:

    ```bash
    docker run -e BESU_PROFILE=advanced-mainnet consensys/linea-besu-package:latest
    ```

    Adjust the `BESU_PROFILE` to match one of the profiles listed in step 1. 
  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
      In a terminal, navigate to your `.yaml` file's directory. Then start the node by running 
      `docker compose`: 

      ```bash
      docker compose -f ./your-file-path/docker-compose-advanced-sepolia.yaml up
      ```

      Alternatively, you can run a node without downloading a `.yaml` file with a `docker run` command. 
      For example:

      ```bash
      docker run -e BESU_PROFILE=advanced-sepolia consensys/linea-besu-package:latest
      ```

      Adjust the `BESU_PROFILE` to match one of the profiles listed in step 1. 
    </TabItem>
</Tabs>


==================== FILE: /workspace/docs/get-started/how-to/run-a-node/volume-creation.mdx ====================

---
title: Creating a Custom Volume
image: /img/socialCards/creating-a-custom-volume.jpg
---

:::note

Blockchain clients can take up a lot of disk space. By defining the amount of disk space you're willing to
dedicate to your client (and the block data that it will be syncing), you can ensure that you still have enough room on
your disk for whatever else you need.

:::

Select the relevant operating system for the steps on how to create a custom volume.

<details>

<summary>Ubuntu</summary>

- Open Terminal
- Use the `df -h` command to check the available disk space
- Choose a maximum size for the volume. We'll use 100GB for this example.
- Use `fallocate` to create a file of the desired size, e.g. `fallocate -l 100G myfile.img`
- Use `mkfs.ext4` to format the file as an ext4 filesystem. e.g. `mkfs.ext4 myfile.img`
- Mount the file using `mount`, e.g. `mount -o loop myfile.img /mnt/myvolume`
- The contents will now be available in `/mnt/myvolume`, up to a maximum of 100GB

</details>

<details>
  
<summary>MacOS</summary>

- Open Terminal
- Use the `df -h` command to check the available disk space
- Choose a maximum size for the volume. We'll use 100GB for this example.
- Use `hdiutil` to create a sparse image of the desired size, e.g. `hdiutil create -size 100g -type SPARSE -fs HFS+X myfile.dmg`
- Mount the image using `hdiutil`, e.g. `hdiutil attach myfile.dmg`
- The contents will now be available mounted under `/Volumes`, up to a maximum of 100GB

</details>

<details>

<summary>Windows</summary>

<details>

<summary>Without Windows Subsystem Linux</summary>

- Open Command Prompt as Administrator
- Use the `dir` command to check available disk space on the volume you want to create the disk image
- Choose a maximum size for the volume. We'll use 100GB for this example.
- Use the `fsutil` command to create a sparse file of the desired size, e.g. `fsutil file createnew myfile.img 107374182400` (for a 100GB file)
- Initialize the disk image using `diskpart`:
  - `diskpart`
  - `select vdisk file="myfile.img"`
  - `create vdisk maximum=100000`
  - `attach vdisk`
  - `exit`
- Format the volume using `format`, e.g. `format F: /FS:NTFS /A:64K /Q`
- The new volume will now be available as drive letter F:, up to the maximum 100GB size

To mount an existing disk image:

- Open Command Prompt as Administrator
- Use `diskpart`
  - `select vdisk file="myfile.img"`
  - `attach vdisk`
- The disk image will be mounted and accessible under the assigned drive letter

</details>

<details>

<summary>With Windows Subsystem Linux</summary>

- Open WSL
- Use the `df -h` command to check the available disk space
- Choose a maximum size for the volume. We'll use 100GB for this example.
- Use `fallocate` to create a file of the desired size, e.g. `fallocate -l 100G myfile.img`
- Use `mkfs.ext4` to format the file as an ext4 filesystem. e.g. `mkfs.ext4 myfile.img`
- Mount the file using `mount`, e.g. `mount -o loop myfile.img /mnt/myvolume`
- The contents will now be available in `/mnt/myvolume`, up to a maximum of 100GB

</details>

</details>


==================== FILE: /workspace/docs/get-started/how-to/run-a-node/index.mdx ====================

---
title: Run a Linea node
image: /img/socialCards/run-a-linea-node.jpg
---

import DocCardList from "@theme/DocCardList";

This section guides you through running a Linea node using various compatible Ethereum clients.

:::info important
While Linea supports multiple clients, only Linea Besu currently allows you to access Linea-specific
features, such as using [Linea methods](../../../api/reference/index.mdx) (for example, `linea_estimateGas`)
or calling methods using the `finalized` tag.

Linea Besu is recommended for infrastructure providers and operators who intend to run a Linea
node, whether for offering node services to others or for using Linea with a personal, private RPC endpoint.
:::

The vanilla Ethereum clients such as Besu, Geth, and Erigon are recommended if you only want to follow the
Linea chain. They allow you to have a local copy of the Linea blockchain. This view of the state is
"trusted" until the transaction, or the block that transaction is in, has been finalized on L1.

The following table lists the clients covered in this guide, and whether they provide direct access
to Linea-specific features.

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Description</th>
      <th>Runs Linea-specific features?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Besu](./besu.mdx)</td>
      <td>An Java-based open-source Ethereum client that can be extended using plugins.</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>[Linea Besu](./linea-besu.mdx)</td>
      <td>Besu client with plugins that implement Linea-specific features, such as [API methods](../../../api/reference/index.mdx) and a [finalized](../finalized-block.mdx) tag.</td>
      <td>✅</td>
    </tr>
    <tr>
      <td>[Erigon](./erigon.mdx)</td>
      <td>A client implementation focused on performance and saving disk space, written in Go.</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>[Geth](./geth.mdx)</td>
      <td>The most widely used open-source Ethereum client, written in Go.</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>[Nethermind](./nethermind.mdx)</td>
      <td>A highly configurable .NET-based Ethereum client.</td>
      <td>❌</td>
    </tr>
  </tbody>
</table>


There are no financial incentives for running a Linea node, and there is currently no option to
vote on blocks as part of the consensus mechanism or
[fork-choice](https://eth2book.info/capella/part3/forkchoice/#whats-a-fork-choice) like on Ethereum.


<DocCardList />


==================== FILE: /workspace/docs/get-started/how-to/run-a-node/beta-v4-migration.mdx ====================

---
title: Beta v4 migration guide
description: Details of how to migrate your nodes following Beta v4 upgrade
image: /img/socialCards/beta-v4-migration-guide.jpg
---

Linea Beta v4 is a **mandatory hard fork** introducing **Maru**, the new consensus layer (CL).

This replaces Clique and aligns Linea with Ethereum's dual-layer design (execution and consensus).

After the fork:
- You must run **both** an execution layer (EL) client and Maru, a CL client
- Sequencer signatures move from EL `extraData` to the **Maru attestations API**.
- EL clients must be upgraded to Beta v4 compatible versions (any EL client that supports Prague 
  should be compatible).

## Breaking change: sequencer signatures

**Sequencer signatures will no longer be in EL block `extraData` after the upgrade.**

Before (pre-fork):

```
// on EL client
let signatures = block.extra_data;
```

After (post-fork):

```
// Must switch to Maru API
let signatures = maru_api.get("/eth/v2/beacon/blocks/{block_id}").data.message.body.attestations;
```

`attestations` returns a list containing the current block signature/attestation and the previous block 
signature/attestation.


## Key architecture changes

### Current

- Single layer: EL client only (Besu with Clique)
- Sequencer signatures: Stored in EL block `extraData`
- Block production: Clique handles execution and consensus

### After Beta v4

- Dual-layer architecture: Execution Layer (EL) client + Consensus Layer (CL) client (The CL is 
  currently powered by Maru, a consensus client implementing a customized variation of the QBFT 
  algorithm. While Maru is the only supported client today, the architecture is designed to support 
  future client diversity and algorithm evolution).
- Sequencer signatures: Moved to Maru's `SealedBeaconBlock.commitSeals`
- Block production: Maru (QBFT) coordinates consensus, EL executes transactions
- API: Signatures and consensus data available via Maru APIs

## EL client compatibility

By design, Linea with Maru will support any client compatible with L1. So any vanilla client compatible 
with Prague will work.

Supported EL clients (from [e2e tests](https://github.com/Consensys/maru/tree/main/e2e)):

- Besu: [25.8.0](https://github.com/hyperledger/besu/releases/tag/25.8.0) or higher
- Geth: Use the latest release (downtime required)
- Erigon: Use the latest release
- Nethermind: Use the latest release
- Linea-specific: A new `linea-besu-package` release will be provided separately

**⚠️ Geth-specific issue:**

- Geth v1.15+ → incompatible with Clique (pre-fork)
- Geth v1.13 → incompatible with Prague (post-fork)
- Result: No zero-downtime upgrade path; must plan maintenance window.

## Upgrade strategy

Depending on your EL client, follow the relevant upgrade path:

### Besu, Erigon, Nethermind (zero-downtime)

**Pre-upgrade**
- Prepare Docker setup (EL + Maru)
- Upgrade EL client to Prague-compatible version

**During upgrade**
- Start Maru before the fork timestamp
- Keep EL client running
- Monitor logs for sync and consensus:
  - `docker logs linea-maru | grep "imported block"`
  - `curl -s -X POST http://localhost:8545 -H "Content-Type: application/json" -d '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}'`

**Post-upgrade**
- Verify block import in Maru logs
- Confirm EL block height with `eth_blockNumber`

### ⚠️ Geth (downtime required):

**Pre-upgrade**
- Prepare Docker setup (EL + Maru)
- Plan a short maintenance window after the fork
- **Note: the genesis file provided for Besu should be used for Geth as well.**

**During upgrade**
- Stop Geth after fork timestamp
- Upgrade to Geth v1.15+ (Prague-compatible)
- Start both Maru and Geth together

**Post-upgrade**
- Same verification steps as above

## Installation and setup guide

### Prerequisites

- Docker and Docker Compose ([https://hub.docker.com/r/consensys/maru/tags](https://hub.docker.com/r/consensys/maru/tags) or https://github.com/Consensys/maru)
- 8GB+ RAM (16GB recommended)
- Open ports: 8545, 8550, 8080, 9090, 9000
- Synced EL client (for example Besu Sepolia)
- L1 (Sepolia) RPC URL — required for Maru to track zk-proof verification and determine which L2 
  blocks are finalized


### Step 1: Directory structure

```bash
mkdir -p ~/linea-node/{maru/config,besu/config}
cd ~/linea-node
```

### Step 2: Besu configuration (Sepolia)

Create `besu/config/config.toml`:

```toml
# Sepolia configuration
data-path="/opt/besu/data"
genesis-file="/opt/besu/genesis.json"

# Sepolia bootnodes
bootnodes=[
  "enode://6f20afbe4397e51b717a7c1ad3095e79aee48c835eebd9237a3e8a16951ade1fe0e66e981e30ea269849fcb6ba03d838da37f524fabd2a557474194a2e2604fa@18.221.100.27:31002",
  "enode://ce1e0d8e0500cb5c0ac56bdcdafb2d6320c3a2c5125b5ccf12f5dfc9b47ee74acbcafc32559017613136c9c36a0ce74ba4f83b7fb8244f099f3b15708d9d3129@3.23.75.47:31000",
  "enode://1b026a5eb0ae74300f58987d235ef0e3a550df963345cb3574be3b0b54378bd11f14dfd515a8976f2c2d2826090e9507b8ccc24f896a9ffffffcabcfd996a733@3.129.120.128:31001"
]

# Sync configuration
sync-mode="SNAP"
data-storage-format="BONSAI"

# P2P
p2p-port=30303
p2p-host="YOUR_PUBLIC_IP"  # Replace with your machine public IP
host-allowlist=["*"]
discovery-enabled=true
fast-sync-min-peers=1

# Engine API (CRITICAL for Maru connection)
engine-host-allowlist=["*"]
engine-rpc-port=8550
engine-jwt-disabled=true
engine-rpc-enabled=true # No JWT required for development/testing

# JSON-RPC
rpc-http-enabled=true
rpc-http-host="0.0.0.0"
rpc-http-port=8545
rpc-http-cors-origins=["*"]
rpc-http-api=["ENGINE","DEBUG","NET","ETH","WEB3"]
```

Update Besu `genesis.json` per the file [here](https://github.com/Consensys/linea-monorepo/tree/main/docker/linea-sepolia):

```json
{
      "config": {
        "chainId": 59141,
        "homesteadBlock": 0,
        "eip150Block": 0,
        "eip155Block": 0,
        "eip158Block": 0,
        "byzantiumBlock": 0,
        "constantinopleBlock": 0,
        "petersburgBlock": 0,
        "istanbulBlock": 0,
        "berlinBlock": 0,
        "londonBlock": 0,
        "terminalTotalDifficulty": 37331807,
        "shanghaiTime": 1759147200,
        "cancunTime": 1759233600,
        "depositContractAddress": "0x0bdae9550159eb73559e74d27fbc989641b24c8e",
        "withdrawalRequestContractAddress": "0x0e97F666F1d99A60590F7Ce7fA5A5a7C754Ff714",
        "clique":{
          "createemptyblocks": true,
          "blockperiodseconds": 1,
          "epochlength":30000
        },
        "blobSchedule": {
          "cancun": {
            "target": 0,
            "max": 0,
            "baseFeeUpdateFraction": 3338477
          },
          "prague": {
            "target": 0,
            "max": 0,
            "baseFeeUpdateFraction": 3338477
          }
        }
      },
      "nonce": "0x0",
      "timestamp": "0x6391BFF3",
      "extraData": "0x0000000000000000000000000000000000000000000000000000000000000000a27342f1b74c0cfb2cda74bac1628d0c1a9752f20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "gasLimit": "0x3A2C940",
      "baseFeePerGas": "0x8",
      "difficulty": "0x1",
      "mixHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
      "coinbase": "0x0000000000000000000000000000000000000000",
      "alloc": {
        "Ed8587afbDBb2504EC31583B3377447d6fA322B2": {
          "balance": "0x8AC7230489E80000"
        },
        "971e727e956690b9957be6d51Ec16E73AcAC83A7": {
          "balance": "0x33B2E3C9FD0803CE8000000"
        },
        "47C63d1E391FcB3dCdC40C4d7fA58ADb172f8c38": {
          "balance": "0x8AC7230489E80000"
        },
        "5948ccC8A59B464c6DcC87db4004Cf0a8d600C93": {
          "balance": "0x8AC7230489E80000"
        },
        "73259D1d7534D1b68542e3240Cf76A03a5C2530F": {
          "balance": "0x8AC7230489E80000"
        },
        "857dBFEbD7D29a75FF06d1423c418Da3b6E07292": {
          "balance": "0x8AC7230489E80000"
        },
        "C702eAfe94b232ed50A7d4aC204306b97cdDAB0B": {
          "balance": "0x8AC7230489E80000"
        },
        "Cc791070a5aA20f7C77CFd02E1713AfA30A23021": {
          "balance": "0x8AC7230489E80000"
        },
        "Cd6366E24283D5D2fA10350Ac75d8a0B798E1FAe": {
          "balance": "0x8AC7230489E80000"
        },
        "d83C3dC7257Eb2E304CBEB50b0B98bc2dd2cdCd9": {
          "balance": "0x8AC7230489E80000"
        },
        "df5443dBe811fF9a121466dDa3C96292a3F6f43D": {
          "balance": "0x8AC7230489E80000"
        },
        "0000000000000000000000000000000000000000": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000001": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000002": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000003": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000004": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000005": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000006": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000007": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000008": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000009": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000000a": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000000b": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000000c": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000000d": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000000e": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000000f": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000010": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000011": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000012": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000013": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000014": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000015": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000016": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000017": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000018": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000019": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000001a": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000001b": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000001c": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000001d": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000001e": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000001f": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000020": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000021": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000022": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000023": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000024": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000025": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000026": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000027": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000028": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000029": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000002a": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000002b": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000002c": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000002d": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000002e": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000002f": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000030": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000031": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000032": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000033": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000034": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000035": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000036": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000037": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000038": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000039": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000003a": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000003b": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000003c": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000003d": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000003e": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000003f": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000040": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000041": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000042": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000043": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000044": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000045": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000046": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000047": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000048": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000049": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000004a": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000004b": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000004c": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000004d": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000004e": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000004f": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000050": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000051": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000052": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000053": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000054": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000055": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000056": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000057": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000058": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000059": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000005a": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000005b": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000005c": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000005d": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000005e": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000005f": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000060": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000061": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000062": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000063": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000064": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000065": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000066": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000067": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000068": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000069": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000006a": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000006b": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000006c": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000006d": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000006e": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000006f": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000070": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000071": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000072": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000073": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000074": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000075": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000076": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000077": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000078": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000079": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000007a": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000007b": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000007c": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000007d": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000007e": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000007f": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000080": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000081": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000082": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000083": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000084": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000085": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000086": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000087": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000088": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000089": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000008a": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000008b": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000008c": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000008d": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000008e": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000008f": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000090": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000091": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000092": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000093": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000094": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000095": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000096": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000097": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000098": {
          "balance": "0x1"
        },
        "0000000000000000000000000000000000000099": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000009a": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000009b": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000009c": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000009d": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000009e": {
          "balance": "0x1"
        },
        "000000000000000000000000000000000000009f": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000a0": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000a1": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000a2": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000a3": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000a4": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000a5": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000a6": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000a7": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000a8": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000a9": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000aa": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000ab": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000ac": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000ad": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000ae": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000af": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000b0": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000b1": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000b2": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000b3": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000b4": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000b5": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000b6": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000b7": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000b8": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000b9": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000ba": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000bb": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000bc": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000bd": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000be": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000bf": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000c0": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000c1": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000c2": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000c3": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000c4": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000c5": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000c6": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000c7": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000c8": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000c9": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000ca": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000cb": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000cc": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000cd": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000ce": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000cf": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000d0": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000d1": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000d2": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000d3": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000d4": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000d5": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000d6": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000d7": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000d8": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000d9": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000da": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000db": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000dc": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000dd": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000de": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000df": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000e0": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000e1": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000e2": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000e3": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000e4": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000e5": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000e6": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000e7": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000e8": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000e9": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000ea": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000eb": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000ec": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000ed": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000ee": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000ef": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000f0": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000f1": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000f2": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000f3": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000f4": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000f5": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000f6": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000f7": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000f8": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000f9": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000fa": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000fb": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000fc": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000fd": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000fe": {
          "balance": "0x1"
        },
        "00000000000000000000000000000000000000ff": {
          "balance": "0x1"
        }
      },
      "number": "0x0",
      "gasUsed": "0x0",
      "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000"
    }
```

### Step 3: Maru configuration (follower node)

Cleanup existing data in `/opt/maru/data` directory that will be used as `data-path` in Maru Configuration

Create `maru/config/maru-config.toml`:

```toml
# IMPORTANT: No [qbft] section = follower node (not validator)

# [linea]
# contract-address = "0xB218f8A4Bc926cF1cA7b3423c154a0D627Bdb7E5"
# l1-eth-api = { endpoint = "<your Sepolia RPC endpoint>" }
# l1-polling-interval = "6 seconds"
# l1-highest-block-tag = "finalized"

[persistence]
data-path = "/data"
private-key-path = "/data/private-key"

[p2p]
port = 9000  # Default port (can be same as discovery)
ip-address = "0.0.0.0"
static-peers = ["/ip4/3.129.120.128/tcp/31005/p2p/16Uiu2HAmR33t8RZiAHovuH9iH2UuUrajrbfyYowiYDAQo3D5Y9wg", "/ip4/3.129.120.128/tcp/31006/p2p/16Uiu2HAm9HB5oNmnmj8yY6T7dfhLVidVzYqa8QVDtEthkMr6b8tx"]
reconnect-delay = "500ms"

[p2p.discovery]
port = 9000
bootnodes = []
refresh-interval = "3s"

[payload-validator]
engine-api-endpoint = { endpoint = "http://linea-besu:8550" }  # Match Besu port!
eth-api-endpoint = { endpoint = "http://linea-besu:8545" }

[observability]
port = 9090
jvm-metrics-enabled = true
prometheus-metrics-enabled = true

[api]
port = 8080

[syncing]
peer-chain-height-polling-interval = "5s"
el-sync-status-refresh-interval = "5s"
sync-target-selection = "Highest"
desync-tolerance = 0

[syncing.download]
block-range-request-timeout = "10s"
blocks-batch-size = 10
blocks-parallelism = 10
max-retries = 5
backoff-delay = "1s"
use-unconditional-random-download-peer = false
```

### Step 4: Maru genesis file

Create `maru/config/maru-genesis.json`:

```json
{
      "chainId": 59141,
      "config": {
        "0": {
          "type": "difficultyAwareQbft",
          "blockTimeSeconds": 2,
          "postTtdConfig": {
            "validatorSet": ["0x20e2654209c3f5a7b4728fb228778f1261f1013f"],
            "elFork": "Paris"
          },
          "terminalTotalDifficulty": 37331807
        },
        "1759147200": {
          "type": "qbft",
          "validatorSet": ["0x20e2654209c3f5a7b4728fb228778f1261f1013f"],
          "blockTimeSeconds": 2,
          "elFork": "Shanghai"
        },
        "1759233600": {
          "type": "qbft",
          "validatorSet": ["0x20e2654209c3f5a7b4728fb228778f1261f1013f"],
          "blockTimeSeconds": 2,
          "elFork": "Cancun"
        }
      }
    }
```
### Step 5: Create log4j.xml file

Create `maru/config/log4j.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="warn">
    <Appenders>
        <Console name="console" target="SYSTEM_OUT">
            <PatternLayout pattern="[%-5level] %d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %c{1} - %msg%n"/>
        </Console>
    </Appenders>
    <Loggers>
        <Root level="INFO" additivity="false">
            <appender-ref ref="console"/>
        </Root>
    </Loggers>
</Configuration>
```

### Step 6: Docker Compose setup

Create `docker-compose.yml`:

```yaml
networks:
  linea: {}

services:
  besu:
    image: hyperledger/besu:25.8.0
    container_name: linea-besu
    restart: unless-stopped
    networks: [linea]
    ports:
      - "8545:8545"        # JSON-RPC
      - "8550:8550"        # Engine API
      - "30303:30303"      # P2P TCP
      - "30303:30303/udp"  # P2P UDP
    environment:
      - JAVA_OPTS=-Xmx4g
    volumes:
      - ./besu/data:/opt/besu/data
      - ./besu/config/config.toml:/opt/besu/config.toml:ro
      - ./besu/genesis.json:/opt/besu/genesis.json:ro
    command:
      - --config-file=/opt/besu/config.toml

  maru:
    image: consensys/maru:dbb6c73
    container_name: linea-maru
    restart: unless-stopped
    depends_on:
      - besu
    networks: [linea]
    ports:
      - "8080:8080"         # Beacon/REST API
      - "9000:9000/tcp"     # P2P main port
      - "9000:9000/udp"     # P2P discovery port (UDP only)
      - "9090:9090"         # Metrics optionnal
    environment:
      - JAVA_OPTS=-Xmx2g
    volumes:
      - ./maru/config:/opt/consensys/maru/configs:ro
      - ./maru/data:/data
    command:
      - "java"
      - "-Dlog4j2.configurationFile=/opt/consensys/maru/configs/log4j.xml"
      - "-jar"
      - "/opt/consensys/maru/maru.jar"
      - "--maru-genesis-file"
      - "/opt/consensys/maru/configs/maru-genesis.json"
      - "--config"
      - "/opt/consensys/maru/configs/maru-config.toml"
```

### Step 7: Launch and verify

```bash
# Start both services (Besu first then Maru)
docker-compose up -d

# Check Besu is syncing
curl -X POST http://localhost:8545 -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}'

# Check Maru health
curl -X GET "http://localhost:8080/eth/v1/node/health"

# Verify P2P connection
docker logs linea-maru | grep "Currently connected peers"
# Should show: peers=[16Uiu2HAmR33t8RZiAHovuH9iH2UuUrajrbfyYowiYDAQo3D5Y9wg]
```

## JWT Authentication

For production environments, you should enable JWT authentication:

### Generate JWT secret

```bash
openssl rand -hex 32 > ~/linea-node/jwt/jwt.hex
```

### Update Besu config

```toml
# Replace engine-jwt-disabled=true with:
engine-jwt-enabled=true
engine-jwt-file="/opt/besu/jwt.hex"
```

### Update Maru config

```toml
[payload-validator]
engine-api-endpoint = { endpoint = "http://linea-besu:8550", jwt-secret-path = "/jwt.hex" }
```

### Update Docker volumes

```yaml
# Add to both Besu and Maru:
volumes:
  - ./jwt/jwt.hex:/jwt.hex:ro
```

## Private key management

**Development**: Maru auto-generates private keys at startup if none exist. (TBC)

**Production**: Generate and backup your private key (not mandatory):

```bash
# Option 1: Let Maru auto-generate, then backup:
docker cp linea-maru:/data/private-key ./backup/

# Option 2: Generate using Maru's key generation tool:
# https://github.com/Consensys/maru/tree/main/jvm-libs/utils
```

:::info[Important]

Maintaining the same private key preserves node identity across restarts.

:::

## Troubleshooting

### Debug commands

```bash
# EL client block height
curl -s -X POST http://localhost:8545 -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}'

# Maru health
curl http://localhost:8080/eth/v1/node/health

# Check block headers
curl http://localhost:8080/eth/v1/beacon/headers/head
```


==================== FILE: /workspace/docs/get-started/how-to/run-a-node/geth.mdx ====================

---
title: Geth
description: Install the Geth client to run a Linea node.
image: /img/socialCards/geth.jpg
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

import VolumeCreation from "./volume-creation.mdx";
import NodeSize from "../../../../src/components/NodeSize";
import LastUpdated from "../../../../src/components/LastUpdated";

[Geth](https://geth.ethereum.org/) is an open-source Go implementation of Ethereum.

:::info important
Install and run a Geth node if you want to follow the Linea network by 
maintaining a local copy of the blockchain. However, if you want to interact with the network and use
Linea-specific methods and features, you should [install Linea Besu](./linea-besu.mdx) instead.
:::

You can run Geth from a [binary distribution](#run-using-the-binary-distribution) or [using Docker](#run-using-docker).

## Run using the binary distribution

### Step 1. Install Geth

[Download and install](https://geth.ethereum.org/docs/getting-started/installing-geth) the Geth client. 

:::warning

Linea only supports Geth _up to_ v1.13.15 or lower. v1.14.0 and subsequent versions aren't 
supported. 

:::

### Step 2. Download the genesis file

Download the genesis file for the relevant network.

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
  
  Mainnet [`genesis.json`](pathname:///files/geth/mainnet/genesis.json) file.
  
  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
  
  Sepolia [`genesis.json`](pathname:///files/geth/sepolia/genesis.json) file.
  
  </TabItem>
</Tabs>

### Step 3. Define disk space volume (optional) \{#disk-space-geth}

Define a volume size appropriate to your expected usage. A Geth archive node uses:
<NodeSize network="mainnet" cluster="linea-prod-eks" pvc="data-linea-geth-archive-v2-0" />

<LastUpdated />

Use these figures as a basis to determine the extent to which you want to future-proof your node.

Ensure you mount the Geth `datadir` to the custom volume.

If you run out of space, or need to actively maintain how much space is being used, consider
[pruning](https://geth.ethereum.org/docs/fundamentals/pruning).

<VolumeCreation />

### Step 4. Bootstrap your node

Bootstrap the node using the following command:

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
  
    ```bash
    geth --datadir ./geth-linea-data init ./genesis.json
    ```
  
  </TabItem>
  
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
  
  ```bash
  geth --datadir ./geth-sepolia-data init ./genesis.json
  ```
  
  </TabItem>
</Tabs>

### Step 5. Start the Geth client

Start the node using the following command:

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
  
    ```bash
    geth \
    --datadir $HOME/geth-linea-data \
    --networkid 59144 \
    --rpc.allow-unprotected-txs \
    --txpool.accountqueue 50000 \
    --txpool.globalqueue 50000 \
    --txpool.globalslots 50000 \
    --txpool.pricelimit 1000000 \
    --txpool.pricebump 1 \
    --txpool.nolocals \
    --http --http.addr '127.0.0.1' --http.port 8545 --http.corsdomain '*' --http.api 'web3,eth,txpool,net' --http.vhosts='*' \
    --ws --ws.addr '127.0.0.1' --ws.port 8546 --ws.origins '*' --ws.api 'web3,eth,txpool,net' \
    --bootnodes "enode://069800db9e6e0ec9cadca670994ef1aea2cfd3d88133e63ecadbc1cdbd1a5847b09838ee08d8b5f02a9c32ee13abeb4d4104bb5514e5322c9d7ee19f41ff3e51@3.132.73.210:31002,enode://a8e03a71eab12ec4b47bb6e19169d8e4dc7a58373a2476969bbe463f2dded6003037fa4dd5f71e15027f7fc8d7340956fbbefed67ddd116ac19a7f74da034b61@3.132.73.210:31003,enode://97706526cf79df9d930003644f9156805f6c8bd964fc79e083444f7014ce10c9bdd2c5049e63b58040dca1d4c82ebef970822198cf0714de830cff4111534ff1@18.223.198.165:31004,enode://24e1c654a801975a96b7f54ebd7452ab15777fc635c1db25bdbd4425fdb04e7f4768e9e838a87ab724320a765e41631d5d37758c933ad0e8668693558125c8aa@18.223.198.165:31000,enode://27010891d960f73d272a553f72b6336c6698db3ade98d631f09c764e57674a797be5ebc6829ddbb65ab564f439ebc75215d20aa98b6f351d12ea623e7d139ac3@3.132.73.210:31001,enode://228e1b8a4931e46f383e30721dac21fb8fb4e5e1b32c870e13b25478c82db3dc1cd9e7ceb93d302a766466b55638cc9c5cbfc43aa48fa41ced19baf365951f76@3.1.142.64:31002,enode://c22eb0d40fc3ad5ea710aeddea906567778166bfe18c157955e8c39b23a46c45db18a0fa2ba07f2b64c81178a8c796aec2a29151533920ead06fcdfc6d8d03c6@47.128.192.57:31004,enode://8ce733abe39fd7ae0a278b9893f85c1193c611a3886168690dd843435460f22cc4d61f9e8d0ace7f5905836a665319a31cccdaacdada2acc69972c382ecce7db@3.1.142.64:31003,enode://b7c1b2bed65a855f7a2104aac9a14674dfdf018fdac763415b373b29ce18cdb81d36328ba4e5c9f12629f3a50c3e8f9ee048f22dbdbe93a82813da89c6b81334@51.20.235.126:31004,enode://95270e0550848a72fb141cf27f1c4ea10714edde365b411dc0fa06c81c0f282ce155eb9fa472b6b8bb9ee98395eeaf4c5a7b02a01fe58b37ea98ba152eda4c37@13.50.94.193:31000,enode://72013391755f24f08567b932feeeec4c893c06e0b1fb480890c83bf87fd277ad86a5ab9cb586db9ae9970371a2f8cb0c96f6c9f69045abca0fb801db7f047138@51.20.235.126:31001" \
    --syncmode full \
    --metrics \
    --verbosity 3
    ```

  :::note[bootnodes]
  You can choose from a range of bootnodes for Linea Mainnet. The above command uses 
  all bootnodes by default.

  See our [bootnodes page](bootnodes.mdx) for a full list of available bootnodes.
  :::
  
  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
  
    ```bash
    geth \
    --datadir $HOME/geth-sepolia-data \
    --networkid 59141 \
    --rpc.allow-unprotected-txs \
    --txpool.accountqueue 50000 \
    --txpool.globalqueue 50000 \
    --txpool.globalslots 50000 \
    --txpool.pricelimit 1000000 \
    --txpool.pricebump 1 \
    --txpool.nolocals \
    --http --http.addr '0.0.0.0' --http.port 8545 --http.corsdomain '*' --http.api 'web3,eth,txpool,net' --http.vhosts='*' \
    --ws --ws.addr '0.0.0.0' --ws.port 8546 --ws.origins '*' --ws.api 'web3,eth,txpool,net' \
    --bootnodes "enode://6f20afbe4397e51b717a7c1ad3095e79aee48c835eebd9237a3e8a16951ade1fe0e66e981e30ea269849fcb6ba03d838da37f524fabd2a557474194a2e2604fa@18.221.100.27:31002,enode://ce1e0d8e0500cb5c0ac56bdcdafb2d6320c3a2c5125b5ccf12f5dfc9b47ee74acbcafc32559017613136c9c36a0ce74ba4f83b7fb8244f099f3b15708d9d3129@3.23.75.47:31000,enode://1b026a5eb0ae74300f58987d235ef0e3a550df963345cb3574be3b0b54378bd11f14dfd515a8976f2c2d2826090e9507b8ccc24f896a9ffffffcabcfd996a733@3.129.120.128:31001" \
    --syncmode full \
    --metrics \
    --verbosity 3
    ```
  </TabItem>
</Tabs>

The Linea network only produces blocks if there is currently at least 1 pending transaction. If you see no incoming blocks
to your node, **that doesn't mean that the node is not syncing**.

**If you don't see any incoming blocks**, check and make sure that you have **at least one peer from the bootnodes**;
otherwise, you might not be connected to the Linea network.

Contact us at the [Linea Discord](https://discord.gg/linea) if you have any issues.

## Run using Docker

### Prerequisites

Download and install [Docker](https://docker.com/products/docker-desktop/) and ensure it is 
running.

### Step 1. Download configuration files

Download the configuration files for the relevant network. Ensure that you download the files to the same directory.

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
  
  Download the mainnet [`docker-compose.yml`](pathname:///files/geth/mainnet/docker-compose.yml) and [`genesis.json`](pathname:///files/geth/mainnet/genesis.json)
  files.

  :::note[bootnodes]
  You can choose from a range of bootnodes for Linea Mainnet. The Geth `docker-compose.yml`
  file uses all bootnodes by default. 

  See our [bootnodes page](bootnodes.mdx) for a full list of available bootnodes.
  :::
  
  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
  
  Download the Sepolia testnet [`docker-compose.yml`](pathname:///files/geth/sepolia/docker-compose.yml) and [`genesis.json`](pathname:///files/geth/sepolia/genesis.json)
  files.
  
  </TabItem>
</Tabs>

### Step 2. Start the Geth node

Open up a terminal where the both `docker-compose.yml` and `genesis.json` are located (they should be in the same directory)
and run `docker compose up`

The node should now be running and looking for peers to sync.

## Confirm the node is running

You can call the JSON-RPC API methods to confirm the node is running. For example, call
`eth_syncing` to return the synchronization status.
For example the starting, current, and highest block, or `false` if not synchronizing (or if the head of the chain has been reached).

```bash

curl localhost:8545 \
        -X POST \
        -H "Content-Type: application/json" \
        -d '{"jsonrpc":"2.0","method":"eth_syncing","params":[],"id":1}'

```

You should get a result similar to:

```bash
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "startingBlock": "0x0",
    "currentBlock": "0x5d228",
    "highestBlock": "0x3cedec"
  }
}
```


==================== FILE: /workspace/docs/get-started/how-to/run-a-node/erigon.mdx ====================

---
title: Erigon
description: Install the Erigon client to run a Linea node.
image: /img/socialCards/erigon.jpg
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

import VolumeCreation from "./volume-creation.mdx";

Erigon is a client implementation focused on performance and saving disk space, written in Go.

:::info important
Install and run an Erigon if you want to follow the Linea network by 
maintaining a local copy of the blockchain. However, if you want to interact with the network and use
Linea-specific methods and features, you should [install Linea Besu](./linea-besu.mdx) instead.
:::

You can run Erigon from a [binary distribution](#run-using-the-binary-distribution) or [using Docker](#run-using-docker).

## Run using the binary distribution

:::info
Ensure you review [Erigon's software prerequisites](https://erigon.gitbook.io/erigon/basic-usage/getting-started#software-prerequisites)
before installing the Erigon client.

If you're not comfortable with installing the binary distribution, consider using [Docker](#run-using-docker) instead.
:::

### Step 1. Install Erigon

[Download and install the Erigon client](https://erigon.gitbook.io/erigon/basic-usage/getting-started).

### Step 2. Download the genesis file

Download the genesis file for the relevant network. In the example, we'll download the file to the
directory specified by [`datadir` in Step 4](#step-4-bootstrap-your-node).

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
  
  Mainnet [`genesis.json`](pathname:///files/erigon/mainnet/genesis.json) file.
  
  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
  
  Sepolia [`genesis.json`](pathname:///files/erigon/sepolia/genesis.json) file.
  
  </TabItem>
</Tabs>

### Step 3. Define disk space volume (optional)

Define a volume size appropriate to your expected usage. As of October 8, 2024, Erigon nodes use:
- Full nodes: 122GB.
- Archive nodes: 472GB.

Use these figures as a basis to determine the extent to which you want to future-proof your node.

Ensure you mount the Erigon `datadir` to the custom volume.

If you run out of space, or need to actively maintain how much space is being used, consider
[pruning](https://erigon.gitbook.io/erigon/advanced-usage/options).

<VolumeCreation />

### Step 4. Bootstrap your node

Bootstrap the node using the following command:

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
  
    ```bash
    erigon --datadir $HOME/erigon-mainnet-data/ init $HOME/erigon-mainnet-data/genesis.json
    ```
  
  </TabItem>
  
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
  
  ```bash
  erigon --datadir $HOME/erigon-sepolia-data/ init $HOME/erigon-sepolia-data/genesis.json
  ```
  
  </TabItem>
</Tabs>

### Step 5. Start the Erigon client

Start the node using the following command:

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
  
    ```bash
    erigon \
    --datadir $HOME/erigon-mainnet-data/ \
    --networkid 59144 \
    --rpc.allow-unprotected-txs \
    --txpool.accountqueue 50000 \
    --txpool.globalqueue 50000 \
    --txpool.globalslots 50000 \
    --txpool.pricelimit 1000000 \
    --txpool.pricebump 1 \
    --txpool.nolocals \
    --http --http.addr '127.0.0.1' --http.port 8545 --http.corsdomain '*' --http.api 'web3,eth,txpool,net' --http.vhosts='*' \
    --ws \
    --bootnodes "enode://069800db9e6e0ec9cadca670994ef1aea2cfd3d88133e63ecadbc1cdbd1a5847b09838ee08d8b5f02a9c32ee13abeb4d4104bb5514e5322c9d7ee19f41ff3e51@3.132.73.210:31002,enode://a8e03a71eab12ec4b47bb6e19169d8e4dc7a58373a2476969bbe463f2dded6003037fa4dd5f71e15027f7fc8d7340956fbbefed67ddd116ac19a7f74da034b61@3.132.73.210:31003,enode://97706526cf79df9d930003644f9156805f6c8bd964fc79e083444f7014ce10c9bdd2c5049e63b58040dca1d4c82ebef970822198cf0714de830cff4111534ff1@18.223.198.165:31004,enode://24e1c654a801975a96b7f54ebd7452ab15777fc635c1db25bdbd4425fdb04e7f4768e9e838a87ab724320a765e41631d5d37758c933ad0e8668693558125c8aa@18.223.198.165:31000,enode://27010891d960f73d272a553f72b6336c6698db3ade98d631f09c764e57674a797be5ebc6829ddbb65ab564f439ebc75215d20aa98b6f351d12ea623e7d139ac3@3.132.73.210:31001,enode://228e1b8a4931e46f383e30721dac21fb8fb4e5e1b32c870e13b25478c82db3dc1cd9e7ceb93d302a766466b55638cc9c5cbfc43aa48fa41ced19baf365951f76@3.1.142.64:31002,enode://c22eb0d40fc3ad5ea710aeddea906567778166bfe18c157955e8c39b23a46c45db18a0fa2ba07f2b64c81178a8c796aec2a29151533920ead06fcdfc6d8d03c6@47.128.192.57:31004,enode://8ce733abe39fd7ae0a278b9893f85c1193c611a3886168690dd843435460f22cc4d61f9e8d0ace7f5905836a665319a31cccdaacdada2acc69972c382ecce7db@3.1.142.64:31003,enode://b7c1b2bed65a855f7a2104aac9a14674dfdf018fdac763415b373b29ce18cdb81d36328ba4e5c9f12629f3a50c3e8f9ee048f22dbdbe93a82813da89c6b81334@51.20.235.126:31004,enode://95270e0550848a72fb141cf27f1c4ea10714edde365b411dc0fa06c81c0f282ce155eb9fa472b6b8bb9ee98395eeaf4c5a7b02a01fe58b37ea98ba152eda4c37@13.50.94.193:31000,enode://72013391755f24f08567b932feeeec4c893c06e0b1fb480890c83bf87fd277ad86a5ab9cb586db9ae9970371a2f8cb0c96f6c9f69045abca0fb801db7f047138@51.20.235.126:31001" \
    --prune hrtc \
    --metrics \
    --verbosity 3
    ```

  :::note[bootnodes]
  You can choose from a range of bootnodes for Linea Mainnet. The above command uses 
  all bootnodes by default.

  The [bootnodes page](bootnodes.mdx) contains a full list of available bootnodes.
  :::
  
  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
  
    ```bash
    erigon \
    --datadir $HOME/erigon-sepolia-data \
    --networkid 59141 \
    --rpc.allow-unprotected-txs \
    --txpool.accountqueue 50000 \
    --txpool.globalqueue 50000 \
    --txpool.globalslots 50000 \
    --txpool.pricelimit 1000000 \
    --txpool.pricebump 1 \
    --txpool.nolocals \
    --http --http.addr '127.0.0.1' --http.port 8545 --http.corsdomain '*' --http.api 'web3,eth,txpool,net' --http.vhosts='*' \
    --ws \
    --bootnodes "enode://6f20afbe4397e51b717a7c1ad3095e79aee48c835eebd9237a3e8a16951ade1fe0e66e981e30ea269849fcb6ba03d838da37f524fabd2a557474194a2e2604fa@18.221.100.27:31002,enode://ce1e0d8e0500cb5c0ac56bdcdafb2d6320c3a2c5125b5ccf12f5dfc9b47ee74acbcafc32559017613136c9c36a0ce74ba4f83b7fb8244f099f3b15708d9d3129@3.23.75.47:31000,enode://1b026a5eb0ae74300f58987d235ef0e3a550df963345cb3574be3b0b54378bd11f14dfd515a8976f2c2d2826090e9507b8ccc24f896a9ffffffcabcfd996a733@3.129.120.128:31001" \
    --prune hrtc \
    --metrics \
    --verbosity 3
    ```
  </TabItem>
</Tabs>

The Erigon node will attempt to find peers to begin synchronizing and to download the world state.

## Run using Docker

### Prerequisites

Download and install [Docker](https://docker.com/products/docker-desktop/) and ensure it is 
running.

### Step 1. Download configuration files

Download the configuration files for the relevant network. Ensure that you download the files to the same directory.

<Tabs groupId="networks" className="my-tabs">
  <TabItem value="mainnet" label="Mainnet">
  
  Download the mainnet [`docker-compose.yml`](pathname:///files/erigon/mainnet/docker-compose.yml) and [`genesis.json`](pathname:///files/erigon/mainnet/genesis.json)
  files.

  :::note[bootnodes]
  You can choose from a range of bootnodes for Linea Mainnet. The above command uses 
  all bootnodes by default.

  The [bootnodes page](bootnodes.mdx) contains a full list of available bootnodes.
  :::
  
  </TabItem>
  <TabItem value="Linea Sepolia" label="Linea Sepolia">
  
  Download the Sepolia testnet [`docker-compose.yml`](pathname:///files/erigon/sepolia/docker-compose.yml) and [`genesis.json`](pathname:///files/erigon/sepolia/genesis.json)
  files.

  </TabItem>
</Tabs>

### Step 2. Start the Erigon node

Open up a terminal where the both `docker-compose.yml` and `genesis.json` are located (they should be in the same directory)
and run `docker compose up`

The node should now be running and looking for peers to sync.

## Confirm the node is running

You can call the JSON-RPC API methods to confirm the node is running. For example, call
`eth_syncing` to return the synchronization status.
For example the starting, current, and highest block, or `false` if not synchronizing (or if the head of the chain has been reached).

```bash

curl localhost:8545 \
        -X POST \
        -H "Content-Type: application/json" \
        -d '{"jsonrpc":"2.0","method":"eth_syncing","params":[],"id":1}'

```

You should get a result similar to:

```bash
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "startingBlock": "0x0",
    "currentBlock": "0x5d228",
    "highestBlock": "0x3cedec"
  }
}
```


==================== FILE: /workspace/docs/get-started/how-to/run-a-node/bootnodes.mdx ====================

---
title: Bootnodes
description: Bootnodes available for Linea Mainnet
image: /img/socialCards/bootnodes.jpg
---

The following bootnodes enable your node to find a peer node when initializing. To 
optimize performance, we recommend you select a location that corresponds to you:
- `us-east-2`: United States
- `ap-southeast-1`: Asia-Pacific
- `eu-north-1`: Europe

Choosing a closer region will minimize latency, but any enode will work regardless of the location 
you choose.

:::info

Only bootnodes listening to `31004` are bootnodes, as they are used by nodes to find other peers,
and do not process any transactions. Others, listening to `31000`-`31003` are peer-to-peer nodes, 
which do process transactions. 

Any of the nodes on this page can be used for peer discovery.

:::

## `us-east-2`

- `enode://069800db9e6e0ec9cadca670994ef1aea2cfd3d88133e63ecadbc1cdbd1a5847b09838ee08d8b5f02a9c32ee13abeb4d4104bb5514e5322c9d7ee19f41ff3e51@3.132.73.210:31002`
- `enode://a8e03a71eab12ec4b47bb6e19169d8e4dc7a58373a2476969bbe463f2dded6003037fa4dd5f71e15027f7fc8d7340956fbbefed67ddd116ac19a7f74da034b61@3.132.73.210:31003`
- `enode://97706526cf79df9d930003644f9156805f6c8bd964fc79e083444f7014ce10c9bdd2c5049e63b58040dca1d4c82ebef970822198cf0714de830cff4111534ff1@18.223.198.165:31004`
- `enode://24e1c654a801975a96b7f54ebd7452ab15777fc635c1db25bdbd4425fdb04e7f4768e9e838a87ab724320a765e41631d5d37758c933ad0e8668693558125c8aa@18.223.198.165:31000`
- `enode://27010891d960f73d272a553f72b6336c6698db3ade98d631f09c764e57674a797be5ebc6829ddbb65ab564f439ebc75215d20aa98b6f351d12ea623e7d139ac3@3.132.73.210:31001`

## `ap-southeast-1`

- `enode://228e1b8a4931e46f383e30721dac21fb8fb4e5e1b32c870e13b25478c82db3dc1cd9e7ceb93d302a766466b55638cc9c5cbfc43aa48fa41ced19baf365951f76@3.1.142.64:31002`
- `enode://c22eb0d40fc3ad5ea710aeddea906567778166bfe18c157955e8c39b23a46c45db18a0fa2ba07f2b64c81178a8c796aec2a29151533920ead06fcdfc6d8d03c6@47.128.192.57:31004`
- `enode://8ce733abe39fd7ae0a278b9893f85c1193c611a3886168690dd843435460f22cc4d61f9e8d0ace7f5905836a665319a31cccdaacdada2acc69972c382ecce7db@3.1.142.64:31003`

## `eu-north-1`

- `enode://b7c1b2bed65a855f7a2104aac9a14674dfdf018fdac763415b373b29ce18cdb81d36328ba4e5c9f12629f3a50c3e8f9ee048f22dbdbe93a82813da89c6b81334@51.20.235.126:31004`
- `enode://95270e0550848a72fb141cf27f1c4ea10714edde365b411dc0fa06c81c0f282ce155eb9fa472b6b8bb9ee98395eeaf4c5a7b02a01fe58b37ea98ba152eda4c37@13.50.94.193:31000`
- `enode://72013391755f24f08567b932feeeec4c893c06e0b1fb480890c83bf87fd277ad86a5ab9cb586db9ae9970371a2f8cb0c96f6c9f69045abca0fb801db7f047138@51.20.235.126:31001`


==================== FILE: /workspace/docs/get-started/how-to/deploy-subdomain.mdx ====================

---
title: Deploy a Linea subdomain
description: Guide to deploy a subdomain for any L1 .eth domain on Linea
image: /img/socialCards/deploy-a-linea-subdomain.jpg
---

This guide is for developers who want to manage subdomains on Linea for domains they own
on [L1 ENS](https://app.ens.domains/).

For example, if you own the domain `example.eth` on L1, you can create and manage subdomains like
`sub.example.eth` on Linea that resolves to the L1 domain, ensuring seamless integration and resolution
across both layers.

## Requirements 

- [L2 contracts](https://github.com/Consensys/linea-ens/tree/main/packages/linea-ens-contracts): 
    These Linea contracts handle all operations on your subdomains, including registrations and setting records.
- [L1 contracts](https://github.com/Consensys/linea-ens/tree/main/packages/linea-ens-resolver): 
    These contracts enable subdomains created on Linea to resolve on L1. You can reuse the
    existing Linea contracts, unless you require customizations.
- User interface (UI): The UI for managing subdomains; you can adapt the [Linea Names app](https://names.linea.build/)
    in the [Linea Names GitHub repository](https://github.com/Consensys/linea-ens/tree/main/packages/linea-ens-app). 
    If you decide to deploy this UI, you will also need to deploy the
    [Linea Names Subgraph](https://github.com/Consensys/linea-ens/tree/main/packages/linea-ens-subgraph), and
    include your own values into the [`env.ts`](https://github.com/Consensys/linea-ens/blob/main/packages/linea-ens-subgraph/src/env.ts)
    file.

    :::tip
    Follow the [quickstart guide](https://github.com/Consensys/linea-ens/tree/main/packages/linea-ens-app#quick-start-on-localhost) 
    to test it locally. Replace the environment variables `BASE_DOMAIN`, `BASE_NODE`, `BASE_LABEL`, and
    `BASE_LABEL_HASH` in the `.env` files (`.env.example` and `env.ts`) with the values matching your ENS domain.
    :::

## Available deployment methods

Use one of the following deployment methods to deploy your subdomain.

### Use the same approach as `linea.eth`

Manage your subdomains the same way `linea.eth` subdomains are managed using the deployment [steps below](#steps).
This includes using the Proof of Humanity (PoH) check for registering subdomains.

### Deploy registrar contracts only 

Deploy only your `Registrar` contracts while using the same `Registry` and `Resolver` contract
addresses deployed for the `linea.eth` subdomain. Contact [Linea Support](https://support.linea.build/)
to gain ownership of an L1 domain on Linea. This solution allows you to deploy only the registrar contracts.

### Use ENS contracts 

Modify the [original ENS contracts deployed on Ethereum Mainnet](https://github.com/ensdomains/ens-contracts).
You must modify the node managed by the Registrar contract to match your domain's node. 

For example, for `linea.eth`, we set the node in the [contract's constructor](https://github.com/Consensys/linea-ens/blob/49c1bd707467daa3a77d06592e2523d74825bdfb/packages/linea-ens-contracts/contracts/ethregistrar/ETHRegistrarController.sol#L162). 

:::warning 

If you modify the `PublicResolver` contract and it impacts storage, you must deploy your own 
`L1Resolver` contract on L1 to match those modifications, as the `L1Resolver` uses hard-coded 
storage slots (as seen [here](https://github.com/Consensys/linea-ens/blob/1b896c9f6f77c6258926957af370bb3d692f540a/packages/linea-ens-resolver/contracts/L1Resolver.sol#L36)).

:::

## Steps

The following steps show how to deploy and configure subdomain contracts on Linea in the same way that 
they were used to create the `linea.eth` subdomain.

### 1. Deploy subdomain contracts

Deploy the subdomain contracts on the Linea network:

1. Clone the [Linea Names repository](https://github.com/Consensys/linea-ens) and execute the 
    following commands:

    ```bash
    cd ./packages/linea-ens-contracts
    yarn
    cp .env.org .env
    ```

1. Replace the following keys in the `.env` file with your own information:

    :::danger
    Do not commit the `.env` file to your repository if it contains sensitive data. You can
    create a `.gitignore` file to prevent accidentally committing the file.
    :::

    ```
    DEPLOYER_PRIVATE_KEY=
    OWNER_PRIVATE_KEY=
    INFURA_API_KEY=
    BASE_DOMAIN=
    ```

   :::note
   Replace `BASE_DOMAIN` environment variable with the L1 ENS domain you own. For example, for `linea.eth`,
   it's `linea`.
   :::

1. Deploy the contract: 

    ```bash
    yarn hardhat deploy --network lineaMainnet
    ```

1. Copy the `PublicResolver` contract address from the `./deployments/lineaMainnet/PublicResolver.json` 
file:

    ```
    "address": "0x86c5AED9F27837074612288610fB98ccC1733126",
    ```

    Copy this address — you'll need it in the next step.

The contracts to manage your subdomains on Linea have now been deployed. The next step is to link 
these subdomains to your L1 domain on L1 for [CCIP resolution](../tooling/cross-chain/ccip-read.mdx) to work.

### 2. Set the Linea target resolution

Set the Linea target resolution on the L1 ENS domain:

1. Retrieve the DNS encoded name for your ENS domain by running:

    ```bash
    ts-node scripts/getENSHashes.ts yourdomain.eth
    ```

    For example, `ts-node scripts/getENSHashes.ts linea.eth`

    Example output:

    ```bash
    The namehash of 'linea.eth' is: 0x527aac89ac1d1de5dd84cff89ec92c69b028ce9ce3fa3d654882474ab4402ec3
    The DNS encoded name of 'linea.eth' is: 0x056c696e65610365746800
    ```

    Keep the DNS encoded name result, for example `0x056c696e65610365746800`.

1. Go to the [Linea Custom Resolver contract on Etherscan](https://etherscan.io/address/0xde16ee87B0C019499cEBDde29c9F7686560f679a#writeContract).

1. In the **Write Contract** tab, connect your wallet using the **Connect with web3** button.
    Make sure to connect with the wallet containing the account that owns your L1 ENS domain.
    In the `setTarget` function add the following parameters:
    - `name`: The DNS encoded name you got from step 1.
    - `target`: The Linea resolver target address you copied from the `PublicResolver.json` file
        in the previous step.

    Then select **Write** and approve the transaction.

1. Go to the [ENS app](https://app.ens.domains/).

1. Search for your ENS domain and go to the profile page.

1. Select the **More** tab, and in the **Resolver** section select **Edit**.

1. Select **Custom Resolver** and add the address `0xde16ee87B0C019499cEBDde29c9F7686560f679a`.

1. Select **Update** and approve the transaction.

The setup to manage subdomains on Linea for your ENS domain is now complete and configured 
similarly to `linea.eth`. This means anyone with an active PoH on Linea can now register a 
`subdomain.yourdomain.eth` that will be resolved on the L1 ENS.


==================== FILE: /workspace/docs/get-started/how-to/gas-fees.mdx ====================

---
description: How to estimate Linea gas costs
sidebar_position: 6
image: /img/socialCards/how-to-estimate-linea-gas-costs.jpg
---

import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';

# Estimate transaction costs

## How gas works on Linea

Linea supports the [Ethereum EIP-1559 gas price model](https://ethereum.org/developers/docs/gas):
```
total fee = units of gas used * (base fee + priority fee)
```

Linea is EVM-equivalent, and gas therefore works extremely similarly to Ethereum. The main difference 
is that **the base fee effectively stabilizes at 7 wei.** Linea blocks use up to around 50% of the 
maximum block size of 2 billion gas, and the base fee decreases or increases by 12.5% per block 
according to network traffic, identically to Ethereum. However, when the base fee reaches 7 wei, 
12.5% is less than 1 wei, and the reduction is rounded down to zero; so the fee remains 7 wei. 
The base fee is also burned, like on Ethereum.

The gas cost to submit your transaction and include it on Ethereum involves the following fee 
components:

- **Layer 2 cost**: The execution fee; the cost of including your transaction on the Linea 
  sequencer, and calculated using a similar formula to Ethereum (as described above). 
- **Layer 1 cost**: The cost of publishing your L2 transaction on Ethereum, which varies 
  based on the blob fee market.

These two resource costs are abstracted by the rollup and covered by the recommended L2 gas price
and gas used.

> Learn more about gas on Linea on our [support page](https://support.linea.build/getting-started/what-does-gas-pay-for) 
and release notes for [Alpha v2](../../release-notes.mdx#alpha-v2) and [Alpha v3](../../release-notes.mdx#alpha-v3).

`linea_estimateGas` is the recommended method for estimating gas on Linea. See our 
[reference page](../../api/reference/linea-estimategas.mdx) for more information. 

Linea also supports:
- [`eth_estimateGas`](https://docs.infura.io/api/networks/linea/json-rpc-methods/eth_estimategas)
- [`eth_gasPrice`](https://docs.infura.io/api/networks/linea/json-rpc-methods/eth_gasprice)
- [`eth_feeHistory`](https://docs.infura.io/api/networks/linea/json-rpc-methods/eth_feehistory).

## Gas pricing

The gas price returned by `linea_estimateGas` is based on the variable data cost of the previous 
block with a multiplier applied as a buffer to ensure inclusion.

Each Linea block's `extraData` field is populated with the following gas price values that are used 
by `linea_estimateGas` to calculate the cost of a transaction:
- A `FIXED_COST` of 0.03 Gwei, which reflects infrastructure costs;
- `ADJUSTED_VARIABLE_COST`, which is the cost per byte of data submitted to L1, and;
- `ETH_GAS_PRICE`, used to set a more accurate return value for any `eth_gasPrice` calls. 

:::note

The `extraData` field is a 32-byte space used to store arbitrary data, such as metadata or 
additional information relevant to the block. 

On Linea, it's used by the sequencer and Linea Besu nodes running the correct plugins to expose 
`linea_estimateGas`.

:::

Variable cost is calculated with the following formula:

```bash
ADJUSTED_VARIABLE_COST = max(base_variable_cost, previous_variable_cost * ( 1 + delta / CHANGE_DENOMINATOR )
```

Where:
- `base_variable_cost` is calculated with the below formula:
  ```python
  variable_cost (4 bytes) = min(max(
  (
    (
      ((averageWeightedBaseFee + averageWeightedPriorityFee) * 
      blob-submission-expected-execution-gas + averageWeightedBlobBaseFee * expected-blob-gas
    ) / bytes-per-data-submission) * profit-margin
  )
  , min-bound), max-bound)
  ```
  The `profit-margin` ensures the network is sustainable. `min-bound` and `max-bound` are variable, 
  and guarantee the gas price stays within a reasonable range.
- `previous_variable_cost` is the value of the last `ADJUSTED_VARIABLE_COST` calculation
- `delta` is a decimal number that fluctuates between `-1.0` and `1.0` and is calculated as:
  ```bash
  delta = (sum(block_calldata_size over BLOCK_COUNT) - calldata_target) / calldata_target
  ```
  Where:
  - `BLOCK_COUNT` is a constant at `5`
  - `block_calldata_size` is the total calldata size of the target block 
  - `calldata_target`  = `109,000 * BLOCK_COUNT / 2` (given that 109,000 is the maximum calldata 
    size allowed in each L2 block)
- `CHANGE_DENOMINATOR` is a constant, currently set to `32`,  designed to control the rate of change
  of `ADJUSTED_VARIABLE_COST`

### Base variable cost

The variable cost formula enables `linea_estimateGas` to price according to the variable costs of 
submitting blob data to L1, working out the per-byte cost of that data. The amount of the blob data 
in each block stays roughly consistent, though the amount _per transaction_ varies, so the 
`linea_estimateGas` API accounts for this, and ensures a gas price is returned for the transaction 
that reflects the amount of data it contains. In turn, it ensures that the network is sustainable,
and that the cost to the protocol of L1 data availability is covered. 

### Adjusted variable cost

The overarching adjusted variable cost formula enables the gas price for the end user to 
automatically adjust to prevent denial-of-service (DoS) attacks where a malicious actor could submit
a large volume of low-compute, high-data transactions at minimal cost. In theory, such a scenario
could prevent good-faith users from submitting transactions because all of the block's space for
data would be taken up by the malicious actor's transactions.

If the calldata space of successive blocks was fully occupied, `ADJUSTED_VARIABLE_COST` would 
increase exponentially: `1 + 1 / 32` (i.e. `1 + delta / CHANGE_DENOMINATOR`) would cause the 
variable cost to double every 22 blocks (44 seconds) — 10,000x over 10 minutes. The gas cost for the
attacker — who needs to fund many transactions — would quickly snowball to a prohibitively high 
number, while remaining acceptable for regular users who only need to submit a handful of 
transactions.

This effect also works in the reverse: when calldata space usage falls, the variable cost will
exponentially decrease and eventually revert to `base_variable_cost`, depending on calldata usage.

### Variable cost and `linea_estimateGas`

To determine the priority fee per gas, `linea_estimateGas` takes the previous block's `VARIABLE_COST` 
into account:
```python
min-gas-price = previousBlock.extraData.variable_cost
baseFeePerGas = vanillaProtocolBaseFee
priorityFeePerGas = MINIMUM_MARGIN * (min-gas-price * L2_compressed_tx_size_in_bytes / L2_tx_gas_used + extraData.fixed_cost)
```

Where:
- `extraData.variable_cost` is where the previous block's `VARIABLE_COST` is stored
block
- `MINIMUM_MARGIN` varies depending on the stage of the transaction:
  - RPC method, i.e. calling `linea_estimateGas`: `1.2`
  - In the transaction pool: `0.8`
  - At transaction selection stage: `1.0`

:::note
The RPC method and transaction pool values are configurable by RPC providers or those running their 
own nodes according to preference; the transaction selection stage value is fixed. For example, 
it may be preferable to set a lower margin to facilitate lower gas prices, but this risks 
transactions not being included.
:::

`linea_estimateGas` simulates the transaction ordering logic that the sequencer uses when building 
blocks, and then obtains a gas price that will ensure that the priority fee is high enough for 
inclusion. The sequencer's transaction ordering policy includes transactions in block in order of 
highest priority fee, a system known as a priority gas auction. It also checks that the priority 
fees offered by each transaction are high enough to support network sustainability, and cover L1 
data costs.

In some cases, transactions with lower priority fees are included ahead of others with higher 
priority fees. This is because the nonce order of transactions submitted from the same account 
takes precedence. 

## [`linea_estimateGas`](../../api/reference/linea-estimategas.mdx)

`linea_estimateGas` is the recommended method for estimating gas on Linea. It returns `gasLimit`, 
`baseFeePerGas`, and `priorityFeePerGas`, and therefore provides a more precise gas estimate than 
the alternatives.

It can also help prevent transactions from being rejected due to exceeding [module limits](../../technology/prover/prover-limits.mdx).

### Example

#### Request

```bash
curl https://linea-mainnet.infura.io/v3/YOUR-API-KEY \
-X POST \
-H "Content-Type: application/json" \
-d '{"jsonrpc": "2.0","method": "linea_estimateGas","params": [{"from": "0x971e727e956690b9957be6d51Ec16E73AcAC83A7","gas":"0x21000"}],"id": 53}'
```

#### Response

```JSON
{
  "jsonrpc": "2.0",
  "id": 53,
  "result": {
    "baseFeePerGas": "0x7",
    "gasLimit": "0xcf08",
    "priorityFeePerGas": "0x43a82a4"
  }
}
```

See the [reference page](../../api/reference/linea-estimategas.mdx) for full usage.


==================== FILE: /workspace/docs/get-started/how-to/migrate-dapp.mdx ====================

---
title: Migrate a dapp to Linea
description: An overview of the steps to move a dapp from an EVM-compatible chain to Linea.
image: /img/socialCards/migrate-a-dapp-to-linea.jpg
---

Linea is EVM-equivalent, which means any dapp running on another chain compatible with the 
Ethereum Virtual Machine (EVM) can run on Linea with no changes. Accordingly, all you'll need to do 
is: 
- Duplicate your existing smart contracts and deploy them on Linea.
- Configure your dapp to interact with Linea.

## Deploy smart contracts

Your dapp's existing contracts must be deployed on Linea. [Part one](../build/quickstart/deploy.mdx) 
of our quickstart covers this, or you can pick one of multiple [contract deployment tooling guides](./deploy-smart-contract/index.mdx).

## Chain information

You may need to update your dapp with Linea chain information, which our [network information page](../build/network-info.mdx)
covers.

## RPC providers

Most major RPC providers support Linea RPC endpoints. Visit our [RPC providers page](../tooling/node-providers/index.mdx) 
for a non-exhaustive list of public and private endpoints.

:::note
Not all RPC providers support Linea-specific JSON-RPC API methods such as `linea_estimateGas`. The
node providers page details which providers do support these methods.
:::

## Wallet connection

Multiple [libraries](../tooling/libraries), including Wagmi and Viem, support Linea wallet 
connectors. 

Check out our [wallet connection guide](../how-to/connect-wallet.mdx) for additional information.

## Moving your token

If your project has its own token, we recommend you: 

### Deploy a canonical token

[Deploy](../how-to/deploy-smart-contract/) and [verify](../how-to/verify-smart-contract/) your 
token on Linea as you would on any other EVM-compatible chain. 

### Add to the token list

With your token deployed, you should make a pull request to add it to the token shortlist on Linea's 
[canonical token list repository](https://github.com/Consensys/linea-token-list/tree/main), after 
which it will be reviewed by our team.

Being on the shortlist means that your token will be displayed in the [native bridge](https://linea.build/hub/bridge/) 
UI. 

### Submit metadata to Lineascan

Adding token metadata to Lineascan is not essential, but strongly recommended to support a 
positive user experience. 

See the [Lineascan guide](https://info.lineascan.build/how-to-update-token-info/).

## Linea brand assets

The Linea site has a zip file of official Linea logos and icons [available for download](https://linea.build/assets),
available as both PNGs and SVGs for use in your dapp. If you need some assets or media that aren't 
covered here, please reach out on Discord.


==================== FILE: /workspace/docs/get-started/how-to/verify-smart-contract/atlas.mdx ====================

---
title: Atlas
image: /img/socialCards/atlas.jpg
---

Your contracts verify automatically on Atlas 😊


==================== FILE: /workspace/docs/get-started/how-to/verify-smart-contract/index.mdx ====================

---
title: Verify a smart contract
sidebar: developersSidebar
description: Verify a contract on Linea using a variety of libraries.
image: /img/socialCards/verify-a-smart-contract.jpg
---

import DocCardList from '@theme/DocCardList';

<DocCardList />


==================== FILE: /workspace/docs/get-started/how-to/verify-smart-contract/hardhat.mdx ====================

---
title: Hardhat
image: /img/socialCards/hardhat.jpg
---

To verify your Hardhat contracts, use [Hardhat's Etherscan plugin](https://hardhat.org/hardhat-runner/plugins/nomiclabs-hardhat-etherscan) to verify contracts on Lineascan.

:::note

This is included as part of the `hardhat-toolbox` plugin.

:::

These steps assume you stored your secret keys in a `.env` file, which you can read more about
[in the Hardhat deployment instructions](../deploy-smart-contract/hardhat.mdx#deploy-the-contract).

## Download the plugin

If you aren't already using `@nomicfoundation/hardhat-toolbox`, you can use `@nomicfoundation/hardhat-verify` instead. Find the instructions on how to add it to your project [here](https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-verify#installation).

## Add your Lineascan API Key

Obtain a Lineascan (Linea instance of Etherscan) key by creating an account at
[https://lineascan.build/myapikey](https://lineascan.build/myapikey). Grab your key, and add it to the `.env` file:

```
LINEASCAN_API_KEY=YOUR_API_KEY_HERE
```

Then, add the key to your `hardhat.config.js` as follows:

```javascript
const { PRIVATE_KEY, LINEASCAN_API_KEY } = process.env;
```

## Add the custom chain

:::note


These instructions verify using the Linea instance of Etherscan, which currently doesn't support Yul. If you
would like to verify using Blockscout, please use the [Blockscout API URL for the required network](../../build/block-explorers.mdx).

:::

import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';

First, we'll need to add a custom chain like so:

<Tabs>
  <TabItem value="Mainnet" label="Mainnet" default>

```javascript
networks: {
  linea_mainnet: {
    ...
  }
},
etherscan: {
  apiKey: {
    linea_mainnet: LINEASCAN_API_KEY
  },
  customChains: [
    {
      network: "linea_mainnet",
      chainId: 59144,
      urls: {
        apiURL: "https://api.lineascan.build/api",
        browserURL: "https://lineascan.build/"
      }
    }
  ]
}
```

  </TabItem>
  <TabItem value="Testnet" label="Testnet">

```javascript
networks: {
  linea_sepolia: {
    ...
  }
},
etherscan: {
  apiKey: {
    linea_sepolia: LINEASCAN_API_KEY
  },
  customChains: [
    {
      network: "linea_sepolia",
      chainId: 59141,
      urls: {
        apiURL: "https://api-sepolia.lineascan.build/api",
        browserURL: "https://sepolia.lineascan.build/address"
      }
    }
  ]
}
```

  </TabItem>
</Tabs>

:::note


The Etherscan `apiKey` and network name for your custom chain must match the network name under `networks` in your `hardhat.config.js`.

:::

## Verify the smart contract

To verify your contract, run the following command:

<Tabs>
  <TabItem value="Mainnet" label="Mainnet" default>

```bash
npx hardhat verify --network linea_mainnet <DEPLOYED_CONTRACT_ADDRESS> <CONTRACT_ARGUMENTS>
```

  </TabItem>
  <TabItem value="Testnet" label="Testnet">

```bash
npx hardhat verify --network linea_sepolia <DEPLOYED_CONTRACT_ADDRESS> <CONTRACT_ARGUMENTS>
```

  </TabItem>
</Tabs>

You should see something that looks a little like this if verifying on Linea Sepolia:

```bash
npx hardhat verify --network linea_sepolia 0x3Af089fee468eb7fcf750e929321b0D7f7845f5C "1893456000"

[INFO] Sourcify Verification Skipped: Sourcify verification is currently disabled. To enable it, add the following entry to your Hardhat configuration:

sourcify: {
  enabled: true
}

Or set 'enabled' to false to hide this message.

For more information, visit https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-verify#verifying-on-sourcify
Successfully submitted source code for contract
contracts/Lock.sol:Lock at 0x3Af089fee468eb7fcf750e929321b0D7f7845f5C
for verification on the block explorer. Waiting for verification result...

Successfully verified contract Lock on the block explorer.
https://sepolia.lineascan.build/address/0x3Af089fee468eb7fcf750e929321b0D7f7845f5C#code
```

:::note


If you get an error saying that the address doesn't have bytecode, it probably means that Etherscan has not indexed your contract yet. In that case, wait for a while and then try again.

:::

You can check that it was verified correctly by navigating to the [testnet block explorer](https://sepolia.lineascan.build/) or the [mainnet block explorer](https://lineascan.build/) and pasting in the deployed contract address.

:::info


[Learn more about different configurations for verifying your smart contracts](https://hardhat.org/hardhat-runner/docs/guides/verifying).

:::


==================== FILE: /workspace/docs/get-started/how-to/verify-smart-contract/foundry.mdx ====================

---
title: Foundry
image: /img/socialCards/foundry.jpg
---

import Tabs from '@theme/Tabs'; 
import TabItem from '@theme/TabItem';

To verify your Foundry contracts, you can use Foundry's [`verify-contract`](https://book.getfoundry.sh/reference/forge/forge-verify-contract) 
to verify contracts on Lineascan.

You'll need to get a Lineascan (Linea instance of Etherscan) API key by creating an account at 
[https://lineascan.build/myapikey](https://lineascan.build/myapikey).

## Verify your smart contract

:::note

These instructions verify using the Linea instance of Etherscan, which currently doesn't support 
Yul. If you would like to verify using Blockscout, please use the [Blockscout API URL for the required network](../../build/block-explorers.mdx).

:::

### Verify a contract that has already been deployed

If you want to verify a contract that has already been deployed, you can use the following commands:

<Tabs>
  <TabItem value="Mainnet" label="Mainnet" default>

```bash
forge verify-contract --etherscan-api-key LINEASCAN_API_KEY --verifier-url https://api.lineascan.build/api CONTRACT_ADDRESS path_to_contract:contract_name --watch
```

  </TabItem>
  <TabItem value="Testnet" label="Testnet">

```bash
forge verify-contract --etherscan-api-key LINEASCAN_API_KEY --verifier-url https://api-sepolia.lineascan.build/api CONTRACT_ADDRESS path_to_contract:contract_name --watch
```

  </TabItem>
</Tabs>

You should see something a little like this:

```bash
Start verifying contract 0x8de6e9b6c774c8b7aba587ed84e5ad0a45837b16 deployed on mainnet

Submitting verification for [src/Counter.sol:Counter] "0x8dE6e9b6c774c8B7AbA587ED84E5AD0A45837b16".
Submitted contract for verification:
        Response: OK
        GUID: `ynnfyvwcqev9i5xr1urdqt9kdwx4zkurvpu7rgh2ywmyp22dpy`
        URL:
        https://etherscan.io/address/0x8de6e9b6c774c8b7aba587ed84e5ad0a45837b16
Contract verification status:
Response: `NOTOK`
Details: `Pending in queue`
Contract verification status:
Response: `OK`
Details: `Pass - Verified`
Contract successfully verified
```

### Verify a contract upon creation

If you want to verify a contract as it is being deployed for the first time, you can use the following commands:

<Tabs>
  <TabItem value="Mainnet" label="Mainnet" default>

```bash
forge create --rpc-url https://linea.infura.io/v3/INFURA_API_KEY src/Counter.sol:Counter --private-key YOUR_PRIVATE_KEY --verify --verifier-url https://api.lineascan.build/api --etherscan-api-key LINEASCAN_API_KEY
```

  </TabItem>
  <TabItem value="Testnet" label="Testnet">

```bash
forge create --rpc-url https://linea-sepolia.infura.io/v3/INFURA_API_KEY src/Counter.sol:Counter --private-key YOUR_PRIVATE_KEY --verify --verifier-url https://api-sepolia.lineascan.build/api --etherscan-api-key LINEASCAN_API_KEY
```

  </TabItem>
</Tabs>

You can check that it was verified correctly by navigating to the [testnet block explorer](https://sepolia.lineascan.build/) or the [mainnet block explorer](https://lineascan.build/) and pasting in the deployed contract address.

## Using `.env` and `foundry.toml` to store Lineascan information

If you don't want to paste your keys inline and have multiple Etherscan API keys to manage, you can use
the `.env` and `foundry.toml` files to set up custom configurations.

These steps assume you stored your secret keys in a `.env` file. which you can read more about
[in the Foundry deployment instructions](../deploy-smart-contract/foundry.mdx#deploy-a-smart-contract-using-a-env-file).

```bash
LINEASCAN_API_KEY=YOUR_LINEASCAN_API_KEY
```

Then, run:

```bash
source .env
```

Finally, modify `foundry.toml` to include the Etherscan configurations:

```bash
[etherscan]
linea-sepolia = { key = "${LINEASCAN_API_KEY}", chain = 59141, url = "https://api-sepolia.lineascan.build/api" }
linea-mainnet = { key = "${LINEASCAN_API_KEY}", chain = 59144, url = "https://api.lineascan.build/api" }
```

Then, to verify your smart contracts, you can simply run:

<Tabs>
  <TabItem value="Mainnet" label="Mainnet" default>

```bash
forge verify-contract --chain linea-mainnet YOUR_CONTRACT_ADDRESS path_to_contract:contract_name --watch
```

  </TabItem>
  <TabItem value="Testnet" label="Testnet">

```bash
forge verify-contract --chain linea-sepolia YOUR_CONTRACT_ADDRESS path_to_contract:contract_name --watch
```

  </TabItem>
</Tabs>

:::info
Learn more about different configurations for verifying your smart contracts using the
[`forge verify-contract`](https://book.getfoundry.sh/reference/forge/forge-verify-contract#forge-verify-contract)
command and the [Forge deployment instructions](https://book.getfoundry.sh/forge/deploying).
:::


==================== FILE: /workspace/docs/get-started/how-to/deploy-smart-contract/atlas.mdx ====================

---
title: Atlas
description: Deploy a smart contract using Atlas.
image: /img/socialCards/atlas.jpg
---

Atlas is a browser-based IDE with an integrated AI assistant that allows you to write, test and deploy smart contracts directly from your browser.

## Deploy a contract

1. Go to `https://app.atlaszk.com`.
1. Go to the top right and change the network to the Linea mainnet or testnet.
1. Select **Deploy**.

You can write tests for your contract (Foundry is built-in), and ask the AI to help you write your
contracts, deployment scripts, and more.

View [the tutorial](https://youtube.com/embed/mnyYizj3l_8?si=eVXHsWWZxlg9EU4D), which shows how to build a
DEX from scratch on Linea. You can also [open and run the tutorial](https://app.atlaszk.com/projects?template=https://github.com/sameesiddiqui/LilDex&open=LilDex.sol) in one click.

<div class="center-container">
    <div class="video-container">
      <iframe
        class="video-iframe"
        src="https://youtube.com/embed/mnyYizj3l_8?si=eVXHsWWZxlg9EU4D"
        title="How to build a DEX (like uniswap) in 1 smart contract"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
        allowFullScreen></iframe>
    </div>
</div>


==================== FILE: /workspace/docs/get-started/how-to/deploy-smart-contract/remix.mdx ====================

---
title: Remix
description: Deploy a smart contract using Remix.
image: /img/socialCards/remix.jpg
---

import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';

In this tutorial, we'll walk through creating a basic Remix project and deploying a sample contract.

## Explore the Remix workspace

To start using Remix, navigate to their [website](https://remix.ethereum.org/). The default project includes a
code sample with a configured smart contract.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/how_to/deploy_smart_contract/remix/Linea_deploy_smart_contract_Remix_1.png"
      alt="Remix configured smart contract code"
    />
  </div>
</div>

## Compile a Remix contract

Navigate to the **Solidity compiler** tab on the left navigation and click **Compile contract**.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/how_to/deploy_smart_contract/remix/Linea_deploy_smart_contract_Remix_2.png"
      alt="Remix compile contract"
    />
  </div>
</div>

## Deploy the contract

You can deploy a smart contract using the injected provider, meaning Remix can auto-detect the network you're
on and your account information. To do this, navigate to the **Deploy & run transactions** tab.

:::caution

The public endpoints are rate limited and not meant for production systems. To use Infura, you'll need to
[get an API key](https://docs.infura.io/api/getting-started).
Then, [manually add a network to your MetaMask wallet](https://support.metamask.io/hc/en-us/articles/360043227612-How-to-add-a-custom-network-RPC#h_01G63GGJ83DGDRCS2ZWXM37CV5) using the
[network information](../../build/network-info.mdx).

:::

Switch to the Linea network (mainnet or testnets) in your MetaMask wallet, and from the **ENVIRONMENT** drop down, select
**Injected provider - MetaMask**.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/how_to/deploy_smart_contract/remix/Linea_deploy_smart_contract_Remix_3.png"
      alt="Remix deploy contract"
    />
  </div>
</div>

Then, select **Deploy** and confirm the transaction. This deploys the contract to the network selected in MetaMask.

## Customize and deploy with Linea integration

With the latest update, you can now easily integrate the Linea network into Remix using the **Customize this list...** feature. This simplifies the deployment process by allowing you to enable Linea as an environment directly within Remix.

### Enable Linea in the environment list

1. Navigate to the **Deploy & run transactions** tab.
2. Under the **ENVIRONMENT** dropdown menu, click on **Customize this list...**.
3. In the **Deploy using a Browser Extension** section, check the **L2 - Linea - MetaMask** option.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/how_to/deploy_smart_contract/remix/Linea_deploy_smart_contract_Remix_4.png"
      alt="Enable Linea in Remix environment"
    />
  </div>
</div>

4. The **L2 - Linea - MetaMask** option will now appear in the **ENVIRONMENT** dropdown.

### Deploy a contract on Linea

1. From the **ENVIRONMENT** dropdown, select **L2 - Linea - MetaMask**.
2. Connect your MetaMask wallet, ensuring it is set to the Linea mainnet or testnet.
3. Compile your smart contract as described earlier in this tutorial.
4. Click **Deploy** and confirm the transaction in MetaMask.


==================== FILE: /workspace/docs/get-started/how-to/deploy-smart-contract/cookbook.mdx ====================

---
title: Cookbook.dev
description: Deploy a smart contract using Cookbook.dev.
image: /img/socialCards/cookbookdev.jpg
---

import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';

[Cookbook.dev](https://contracts.cookbook.dev/) is an open-source smart contract registry where
developers can find solidity primitives, libraries, and smart contracts for protocols. It provides an easy and
fast way to develop smart contracts by integrating with a variety of blockchain-native developer tools.

Here, we'll walk through searching for a protocol on Cookbook and deploying it to Linea using
Cookbook's no-code deploy and using Cookbook with Remix, Hardhat and Foundry.

## Search Cookbook's smart contract registry

Navigate to [cookbook.dev/chains/Linea](https://contracts.cookbook.dev/chains/Linea) and explore **Protocols** on Linea, or search for specific smart contracts in the search bar.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/how_to/deploy_smart_contract/cookbook/Linea_deploy_smart_contract_Cookbook_1.png"
      alt="Cookbook Search"
    />
  </div>
</div>

To learn about a smart contract on Cookbook, select the protocol, and select **Expand**. This opens the code
alongside ChefGPT, Cookbook's AI Solidity assistant.

Highlight selections of the code and press **Analyze Snippet** to get more information about the smart contract
code you're looking at, or ask ChefGPT questions about Linea, solidity, or your smart contract.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/how_to/deploy_smart_contract/cookbook/Linea_deploy_smart_contract_Cookbook_2.png"
      alt="Cookbook Analyze Code Snippet"
    />
  </div>
</div>

## Import smart contract code into Cookbook

Import verified smart contract code into Cookbook to fork, learn about, or build with by inputting any smart contract address that's verified on an EVM-based block explorer into the Cookbook.dev search bar.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/how_to/deploy_smart_contract/cookbook/Linea_deploy_smart_contract_Cookbook_3.png"
      alt="Cookbook Import Contract"
    />
  </div>
</div>

## Deploy a smart contract without coding

The **No-Code Deploy** filter enables you to view (usually simpler) smart contracts on [Cookbook](https://contracts.cookbook.dev/search?filter=No-Code+Deploy) that don't require coding to deploy.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/how_to/deploy_smart_contract/cookbook/Linea_deploy_smart_contract_Cookbook_4.png"
      alt="Cookbook No Code Deploy"
    />
  </div>
</div>

1. Connect your MetaMask Wallet to Cookbook.dev.

1. Set your smart contract arguments in the Cookbook UI (if applicable).

1. Select **Linea** or **tLinea** (Linea Testnet) under **Pick Chain**.

1. Select **Deploy** and pay the network fee.

Manage your deployed smart contract under **My Dashboard** in Cookbook.

## Deploy your smart contract using Remix

### Method 1 - Use the Cookbook.dev website and open in Remix

On a smart contract or protocol page in Cookbook, select the **Open in Remix** option. Your smart contract will
automatically be opened in a new Remix workspace.

Select **Compile** to compile your smart contract in Remix. Most contracts opened with Cookbook will automatically
compile within Remix.

Refer to the [Remix instructions](./remix.mdx) for more information on how to compile and deploy smart
contracts in the Remix IDE.

### Method 2 - Use the Cookbook Remix plug-in within the Remix IDE

1. Go to [Remix.Ethereum.org](https://remix.ethereum.org) website.

1. Add the Cookbook Plugin to Remix by clicking the Cookbook Logo under **Featured Plugins** on the Remix Homepage.

    <div class="center-container">
      <div class="img-medium">
          <img
          src="/img/get_started/how_to/deploy_smart_contract/cookbook/Linea_deploy_smart_contract_Cookbook_8.png"
          alt="Cookbook Remix Featured Plugin"
        />
      </div>
    </div>

    Alternatively, search Cookbook and select **Activate** in the Remix Plugin Manager.

    <div class="center-container">
      <div class="img-small">
          <img
          src="/img/get_started/how_to/deploy_smart_contract/cookbook/Linea_deploy_smart_contract_Cookbook_9.png"
          alt="Cookbook Remix Add Plugin"
        />
      </div>
    </div>

1. Search for any protocol or smart contract and click the search result to import the smart contract code into Remix.

    Cookbook's AI solidity co-pilot, ChefGPT, is available within the Remix plugin to answer questions about
    Linea, Solidity, or the smart contract you're working with.

    <div class="center-container">
      <div class="img-small">
          <img
          src="/img/get_started/how_to/deploy_smart_contract/cookbook/Linea_deploy_smart_contract_Cookbook_10.png"
          alt="Cookbook Remix Search"
        />
      </div>
    </div>

1. Compile and deploy the smart contract as described in [the Remix instructions](./remix.mdx).

## Deploy your smart contract with Hardhat

After finding the smart contract or protocol you want to work with in [Cookbook](https://contracts.cookbook.dev/),
select the **Download Source** option and select **Hardhat** to download the contract boilerplate. For
this example, we'll use the OpenZeppelin [Simple ERC-20 Token Smart Contract](https://contracts.cookbook.dev/contracts/simple-token).


### Compile the smart contract

In the project folder, install the required packages and dependencies:

```
npm install
```

Then, compile the smart contract:

```
npx hardhat compile
```

Add arguments to the `constructorArgs` array in the `deploy.js` file in the `scripts` folder and save. If you
do not need any arguments, leave the array empty.

### Deploy the smart contract

<Tabs>

<TabItem value="Linea Sepolia" label="Linea Sepolia">

1. In your `.env` file, add your Infura Linea API key and add your wallet private key.

    ```
    INFURA_API_KEY_LINEA_SEPOLIA = "<YOUR API KEY HERE>"
    WALLET_PRIVATE_KEY = "<YOUR PRIVATE KEY HERE>"
    ```

1. In the `hardhat.config.js` file, add the following lines:

    ```js
    const INFURA_API_KEY_LINEA_SEPOLIA = process.env.INFURA_API_KEY_LINEA;
    ```

    ```js
    lineaSepolia: {
    url: `https://linea-sepolia.io/v3/${INFURA_API_KEY_LINEA}`,
    accounts: [PRIVATE_KEY],
    },
   ```

1. In the `hardhat.config.js` file, uncomment the following line:

    ```js
    const PRIVATE_KEY = process.env.PRIVATE_KEY;
    ```

1. Deploy the smart contract to the Linea Sepolia testnet

```
npx hardhat run --network (lineaSepolia) scripts/deploy.js
```

Hardhat will return the deployed smart contract address in your terminal. View and verify your smart contract
on the [Linea Sepolia block explorer](https://sepolia.lineascan.build/).
</TabItem> 

<TabItem value="Mainnet" label="Mainnet">

1. In your `.env` file, add your Infura Linea API key and add your wallet private key.

    ```
    INFURA_API_KEY_LINEA = "<YOUR API KEY HERE>"
    WALLET_PRIVATE_KEY = "<YOUR PRIVATE KEY HERE>"
    ```

1. In the `hardhat.config.js` file, add the following lines:

    ```js
    const INFURA_API_KEY_LINEA = process.env.INFURA_API_KEY_LINEA;
    ```

    ```js
    linea: {
    url: `https://linea-mainnet.io/v3/${INFURA_API_KEY_LINEA}`,
    accounts: [PRIVATE_KEY],
    },
    ```

1. In the `hardhat.config.js` file, uncomment the following line:

    ```js
    const PRIVATE_KEY = process.env.PRIVATE_KEY;
    ```

1. Deploy the smart contract to the Linea Mainnet:

```
npx hardhat run --network (linea) scripts/deploy.js
```

Hardhat will return the deployed smart contract address in your terminal. View and verify your smart contract
on the [Linea Mainnet block explorer](https://lineascan.build/). 
</TabItem> 

</Tabs>

## Deploy your smart contract with Foundry

After finding the smart contract or protocol you want to work with in [Cookbook](https://contracts.cookbook.dev/),
select the **Download Source** option and select **Foundry** to download the contract boilerplate. For this
example, we'll use [Cookbook's Simple ERC-20 Token Smart Contract](https://contracts.cookbook.dev/contracts/simple-token).

**Prerequisites**:

- [Install Rust](https://doc.rust-lang.org/book/ch01-01-installation.html).
- [Install Foundry](https://book.getfoundry.sh/getting-started/installation#using-foundryup).

1. In the project directory, build the contracts:

    ```sh
    forge build
    ```

    If you encounter a "stack too deep" error, try running the following command instead

    ```sh
    forge build --via
    ```

1. In the `scripts` directory, uncomment all the code in the `contract.s.sol` file.
    Replace `"ARG1"`, `"ARG2"`, `2000` with your `Token Name`, `Token Symbol` and desired
    `Token Quantity` where you see the code below:

    ```solidity
    FixedToken _contract = new FixedToken("ARG1", "ARG2", 2000);
    ```

1. Update the `.env` file with your [Linea RPC URL](https://docs.metamask.io/services/reference/linea/quickstart/), followed
    by your [MetaMask wallet private key](https://metamask.io/) and your
    [Etherscan API key token values](https://etherscan.io/apis).

    :::note

    The example uses Sepolia, but you can update it to use Mainnet instead.

    :::

1. Run the command to define your environment variables globally:

    ```sh
    source .env
    ```

1. Deploy your contracts:

    ```sh
    forge script script/contract.s.sol:ContractScript --rpc-url $SEPOLIA_RPC_URL --broadcast --verify -vvvv
    ```

    :::note
    If using Mainnet, then update the `--rpc-url` accordingly with the variable in the `.env` file. 
    :::

Your contract will be verified on the Linea Sepolia explorer automatically upon deployment. You can manage and
interact with your newly deployed smart contract in the [Linea Sepolia block explorer](https://sepolia.lineascan.build/).

:::note

The tests in the `contract.t.sol` file are only examples, please generate your own.

:::

## Resources

For more information on using Cookbook to find, learn about or build with smart contracts, see
the following resources:

- [Blog](https://medium.com/@cookbookdev)
- [X (Twitter)](https://x.com/cookbook_dev)
- [Community](https://discord.gg/cookbook)


==================== FILE: /workspace/docs/get-started/how-to/deploy-smart-contract/index.mdx ====================

---
title: Deploy a smart contract
sidebar: developersSidebar
description: Deploy a contract to Linea using a variety of libraries.
image: /img/socialCards/deploy-a-smart-contract.jpg
---

import DocCardList from '@theme/DocCardList';

<DocCardList />


==================== FILE: /workspace/docs/get-started/how-to/deploy-smart-contract/thirdweb.mdx ====================

---
title: thirdweb
description: Deploy a smart contract using thirdweb.
image: /img/socialCards/thirdweb.jpg
---

thirdweb is a complete web3 development framework that provides everything you need to connect your apps and games to decentralized networks.

## Create a smart contract

To create a new smart contract using thirdweb [CLI](https://portal.thirdweb.com/cli), follow these steps:

1. In your CLI run the following command:

   ```
   npx thirdweb create contract
   ```

2. Input your preferences for the command line prompts:
   1. Give your project a name
   2. Choose your preferred framework: Hardhat or Foundry
   3. Name your smart contract
   4. Choose the type of base contract: Empty, [ERC-20](https://portal.thirdweb.com/contracts/build/base-contracts/erc-20/base), [ERC-721](https://portal.thirdweb.com/solidity/base-contracts/erc721base), or [ERC-1155](https://portal.thirdweb.com/solidity/base-contracts/erc1155base)
   5. Add any desired [extensions](https://portal.thirdweb.com/solidity/extensions)
3. Once created, navigate to your project’s directory and open in your preferred code editor.
4. If you open the `contracts` folder, you will find your smart contract; this is your smart contract written in Solidity.

   The following is code for an `ERC721Base` contract without specified extensions. It implements all of the logic inside the [ERC721Base.sol](https://github.com/thirdweb-dev/contracts/blob/main/contracts/base/ERC721Base.sol) contract; which implements the [ERC-721A](https://github.com/thirdweb-dev/contracts/blob/main/contracts/eip/ERC721A.sol) standard.

   ```bash
   // SPDX-License-Identifier: MIT
   pragma solidity ^0.8.0;

   import "@thirdweb-dev/contracts/base/ERC721Base.sol";

   contract Contract is ERC721Base {
       constructor(
           string memory _name,
           string memory _symbol,
           address _royaltyRecipient,
           uint128 _royaltyBps
       ) ERC721Base(_name, _symbol, _royaltyRecipient, _royaltyBps) {}
   }
   ```

   This contract inherits the functionality of `ERC721Base` through the following steps:

   - Importing the `ERC721Base` contract
   - Inheriting the contract by declaring that our contract is an `ERC721Base` contract
   - Implementing any required methods, such as the constructor.

5. After modifying your contract with your desired custom logic, you may deploy it to the [Linea testnet](https://thirdweb.com/linea-sepolia) using [`deploy`](https://portal.thirdweb.com/deploy).

---

Alternatively, you can deploy a prebuilt contract for NFTs, tokens, or marketplace directly from the thirdweb Explore page:

1. Navigate to the thirdweb Explore page: [https://thirdweb.com/explore](https://thirdweb.com/explore)

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/how_to/deploy_smart_contract/thirdweb/Linea_thirdweb_explore_page.png"
      alt="thirdweb explore page"
    />
  </div>
</div>

2. Choose the type of contract you want to deploy from the available options: NFTs, tokens, marketplace, and more.
3. Follow the on-screen prompts to configure and deploy your contract.

> For more information on different contracts available on Explore, check out [thirdweb’s documentation.](https://portal.thirdweb.com/pre-built-contracts)

## Deploy a smart contract

Deploy allows you to deploy a smart contract to any EVM-compatible network without configuring RPC URLs, exposing your private keys, writing scripts, and other additional setup such as verifying your contract.

1. To deploy your smart contract using `deploy`, navigate to the root directory of your project and execute the following command:

   ```bash
   npx thirdweb deploy
   ```

   Executing this command will trigger the following actions:

   - Compiling all the contracts in the current directory.
   - Providing the option to select which contract(s) you wish to deploy.
   - Uploading your contract source code (ABI) to IPFS.

2. When this process is completed, a dashboard interface will open, where you will need to finish filling out the parameters:
   - `_name`: contract name
   - `_symbol`: symbol or "ticker"
   - `_royaltyRecipient`: wallet address to receive royalties from secondary sales
   - `_royaltyBps`: basis points (bps) that will be given to the royalty recipient for each secondary sale, e.g. 500 = 5%
3. Select [Linea testnet](https://thirdweb.com/linea-sepolia) as the network
4. Manage additional settings on your contract’s dashboard as needed, such as uploading NFTs, configuring permissions, and more.

> For additional information on `deploy`, please reference [thirdweb’s documentation](https://portal.thirdweb.com/deploy).

If you have any further questions or encounter any issues during the process, please [reach out to thirdweb support](https://support.thirdweb.com).


==================== FILE: /workspace/docs/get-started/how-to/deploy-smart-contract/hardhat.mdx ====================

---
title: Hardhat
description: Deploy a smart contract using Hardhat.
image: /img/socialCards/hardhat.jpg
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

In this quickstart, we'll create a basic [Hardhat](https://hardhat.org/) project. Here's a video
walkthrough:

<div class="center-container">
    <div class="video-container">
      <iframe
        class="video-iframe"
        src="https://youtube.com/embed/aECCf2P9pgw?si=fV5n0nySuUITbLm8"
        title="How to deploy a smart contract on Linea with Hardhat"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
        allowFullScreen></iframe>
    </div>
</div>

## Prerequisites

Before you begin, ensure you set up your environment using [Hardhat's recommended instructions](https://hardhat.org/tutorial/setting-up-the-environment#2.-setting-up-the-environment).

## Create a Hardhat project

To create an empty Hardhat project:

1. Create your project directory:

    ```bash
    mkdir linea-tutorial; cd linea-tutorial
    ```
1.  Initialize your Node.js project:

     ```bash
    npm init
    ```

1. Install Hardhat:

     ```bash
    npm install --save-dev hardhat
    ```

1. Initialize the Hardhat project:

     ```bash
    npx hardhat init
    ```

    In the menu that appears, select **Create a JavaScript project** and press **Enter**. Accept all
    the default values in the questionnaire.

You should now have a sample contract that deploys and tests a `Lock` contract that locks funds for a set time.

:::note


The default script in `ignition/modules/Lock.js` locks 1 GWEI in the contract upon deployment, you can modify this
value in the script.

:::

## Deploy the contract

You can use the public endpoints or node provider (such as Infura) to deploy your contract to the Linea mainnet or
testnets. 

:::important

The public endpoints are rate limited and not meant for production systems. We recommend using a
node provider such as Infura. You can [sign up for a free Infura account to get an API key](https://docs.infura.io/api/getting-started).

:::

The sample project already includes the deployment script. To deploy on Linea, you'll just need to make
a few modifications to the `hardhat.config.js` file:

1. Create a `.env` file in the root folder with your wallet's private key and Infura API (if using Infura).

   ```
   PRIVATE_KEY=YOUR_PRIVATE_KEY
   INFURA_API_KEY=INFURA_API_KEY
   ```

   :::warning

   Please do not check your keys into source control. Please add `.env` to your `.gitignore`

   :::

1. Download and install `dotenv`

   ```
   npm i -D dotenv
   ```

1. Add Linea to your `hardhat.config.js` file. The following example shows how to add an Infura endpoint and
    public endpoint to the configuration file.

    <Tabs className="my-tabs">
      <TabItem value="Infura" label="Infura" default>

      ```javascript
      require("@nomicfoundation/hardhat-toolbox");
      require("dotenv").config();
      const { PRIVATE_KEY, INFURA_API_KEY } = process.env;

      module.exports = {
        solidity: "0.8.19",
        networks: {
          linea_sepolia: {
            url: `https://linea-sepolia.infura.io/v3/${INFURA_API_KEY}`,
            accounts: [PRIVATE_KEY],
          },
          linea_mainnet: {
            url: `https://linea-mainnet.infura.io/v3/${INFURA_API_KEY}`,
            accounts: [PRIVATE_KEY],
          },
        },
      };
      ```
      </TabItem>
      <TabItem value="Public endpoint" label="Public endpoint">

      
      ```javascript
      require("@nomicfoundation/hardhat-toolbox");
      require("dotenv").config();
      const { PRIVATE_KEY } = process.env;

      module.exports = {
        solidity: "0.8.24",
        networks: {
          linea_sepolia: {
            url: `https://rpc.sepolia.linea.build/`,
            accounts: [PRIVATE_KEY],
          },
          linea_mainnet: {
            url: `https://rpc.linea.build/`,
            accounts: [PRIVATE_KEY],
          },
        },
      };
      ```

      </TabItem>

    </Tabs>

1. Deploy your contract. Replace `NETWORK` with a relevant network defined in the `hardhat.config.js` file. For
    example `linea_mainnet`.

    ```bash
    npx hardhat ignition deploy ./ignition/modules/Lock.js --network NETWORK
    ```

Your output should look something like this:

```bash
Deployed Addresses

LockModule#Lock - 0x2c73d6f093A2032D3371bFB9a29f7cE666080c4A
```

Next, you can optionally [verify your contract on the network](../verify-smart-contract/hardhat.mdx).


==================== FILE: /workspace/docs/get-started/how-to/deploy-smart-contract/foundry.mdx ====================

---
title: Foundry
description: Deploy a smart contract using Foundry.
image: /img/socialCards/foundry.jpg
---

import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';

In this quickstart, we'll create a basic [Foundry](https://book.getfoundry.sh/) project. Here's a video walkthrough:

<div class="center-container">
    <div class="video-container">
      <iframe
        class="video-iframe"
        src="https://youtube.com/embed/nvRvlel3iTQ?si=no67QFjDpeyyfwsG"
        title="How to deploy a smart contract on Linea with Foundry"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
        allowFullScreen></iframe>
    </div>
</div>

## Prerequisites

Before you begin, ensure you download and install Foundry:

    ```bash
    curl -L https://foundry.paradigm.xyz | bash
    ```

Then, open a new terminal, and call `foundryup` to install the latest release.

## Create a Foundry project

To create a Foundry project, run:

```bash
forge init linea-tutorial
```

Running `forge init` sets up a sample contract, test, and script for `Counter.sol`.

Now change into the directory:

```bash
cd linea-tutorial
```

## Deploy a smart contract

To deploy a smart contract we highly recommend using an Infura endpoint, as the public endpoint may 
experience rate limiting and is not meant for production use.

[Sign up for an Infura account](https://docs.infura.io/api/getting-started) to get an API key that
provides access to the Linea endpoints. Assign the Linea endpoints you want to access to your API key.

:::caution

These instructions use API keys and private keys inline. We highly recommend hiding them
[in `.env` files](#deploy-a-smart-contract-using-a-env-file)

:::

Deploy your contract using the following syntax:

```bash
forge create --rpc-url YOUR_LINEA_ENDPOINT src/Counter.sol:Counter --private-key YOUR_PRIVATE_KEY
```

In the command:

- Replace `YOUR_LINEA_ENDPOINT` with the URL of a
    [supported Infura Linea network](https://docs.metamask.io/services/get-started/endpoints/)
    or [public endpoint URL](../../build/network-info.mdx).
- Replace `YOUR_PRIVATE_KEY` with your wallet's private key.

Your output should look similar to:

```bash
Deployer: YOUR_ACCOUNT_NUMBER
Deployed to: 0xED0Ff7E8B655dFFfCA471ea3B6B649ce7C2C1b83
Transaction hash: 0x967e1290b285e67b3d74940ee19925416734c345f58bd1ec64dcea134647d7ee
```

## Deploy a smart contract using a `.env` file

Directly pasting your private key into the command line poses security risks. To avoid exposing 
sensitive information such as wallet private keys or API keys, use files with the `.env` extension 
to store private data. Create a `.env` file, then add the file to the `.gitignore` file to prevent 
committing it. Populate the `.env` file with the relevant private information:

```bash
PRIVATE_KEY=YOUR_PRIVATE_KEY
INFURA_API_KEY=YOUR_INFURA_API_KEY
```

Then, run:

```bash
source .env
```

Finally, modify the `foundry.toml` file to store the various RPC endpoints we might be working with. For example:

```bash
[profile.rpc-endpoints]
linea-sepolia = "https://linea-sepolia.infura.io/v3/${INFURA_API_KEY}"
linea-mainnet = "https://linea-mainnet.infura.io/v3/${INFURA_API_KEY}"
```

To deploy the smart contract, run:

<Tabs className="my-tabs">
  <TabItem value="Mainnet" label="Mainnet" default>

```bash
forge create --rpc-url linea-mainnet src/Counter.sol:Counter --private-key $PRIVATE_KEY
```

</TabItem>

<TabItem value="Sepolia" label="Sepolia">

```bash
forge create --rpc-url linea-sepolia src/Counter.sol:Counter --private-key $PRIVATE_KEY
```

  </TabItem>
</Tabs>

Next, you can optionally [verify your contract on the network](../verify-smart-contract/foundry.mdx).


==================== FILE: /workspace/docs/get-started/how-to/poh-api.mdx ====================

---
title: Check Proof of Humanity
description: Use the Linea Proof of Humanity API to verify the authenticity of your users.
image: /img/socialCards/check-proof-of-humanity.jpg
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Proof of Humanity was originally created to verify community members taking part in the Linea Voyage. 
It aggregates many attestation providers, giving users many options (onchain transaction history, 
biometrics, zero-knowledge KYC, etc.) to demonstrate their personhood, using the [Verax Attestation Registry](https://ver.ax/) 
under the hood.

Even though PoH was originally created for our own needs, the API is publicly available to the 
community. This enables projects to check and verify if an address is owned by a genuine user. It 
can be used to gate access to rewards or special services onchain (for example, to register a Linea 
Name).

To check and secure PoH status, visit the [Linea PoH page](https://poh.linea.build/).

## Offchain verification

The API endpoint for the service is: `https://linea-xp-poh-api.linea.build/`

### Usage

Call the endpoint with the format:

```
https://linea-xp-poh-api.linea.build/poh/{address}
```

For example: 

```bash
curl -X GET "https://linea-xp-poh-api.linea.build/poh/0xc5fd29cC1a1b76ba52873fF943FEDFDD36cF46C6"
```

### Rate limiting

The API is rate-limited to 5 requests per second.  
Exceeding this limit will result in a 429 error.

### Response

The main focus of the response is the `poh` field:
- `false` = address does not have PoH status.
- `true` = address has PoH status.

Response schema:

```json
{
    "poh": boolean,  // Proof of Humanity status
    "isFlagged": boolean,  // Indicates PoH status
    "attestations": [
        {
        "validated": boolean,  // Whether the attestation is verified
        "issuerName": string,  // Attestation provider name
        "issuerSlugName": string,  // Unique identifier for the issuer
        "issuerDescription": string,  // Description of the attestation
        "issuerWebsiteUrl": string,  // URL to the issuer’s website
        "issuerLogoUrl": string,  // Logo URL of the issuer
        "group": integer  // Category of the attestation
        }
    ]
}
```

### Reference

See the [Swagger UI](https://linea-xp-poh-api.linea.build/#/PoH/PohController_getOnePOH) for more 
information. 

## Signed onchain verification

The [PohVerifier.sol contract](https://lineascan.build/address/0xBf14cFAFD7B83f6de881ae6dc10796ddD7220831) 
can be used together with a trusted source of PoH status data.

### Usage

#### Get signed PoH status

Call the signer endpoint `https://linea-poh-signer-api.linea.build/` in the format:

```
https://linea-poh-signer-api.linea.build/poh/{address}
```

This is the _trusted source_ of PoH status data. 

For example:
```bash
curl -X GET https://linea-poh-signer-api.linea.build/poh/0xc5fd29cC1a1b76ba52873fF943FEDFDD36cF46C6
```

This returns a signed message that contains the PoH status of the provided address. For example:

```
0xa11a6c92fa0027d9de2a0c8ab363b1af083497da57f871c93aeb9efcd32ffaeb677fafb2c005e8165181713220b8a1da2f70ed31d7820b8fa086a8e7361dbf121c
```

#### Call `PohVerifier.sol`

Call the `PohVerifier.sol` smart contract's `verify()` function with the signed message and the 
address of the account being queried. The contract confirms that the signed message provided in the 
previous step was signed by the signer defined in the contract, and returns a boolean demonstrating
whether the address has PoH status.

```
verify(bytes memory signature, address human)
```

Parameters:
- `signature`: The signed message from the previous step.
- `address`: The address of the account being queried.

`verify()` returns a boolean:
- `true`: The account has PoH status.
- `false`: The account does not have PoH status.


==================== FILE: /workspace/docs/get-started/how-to/finalized-block.mdx ====================

---
title: Retrieve finalized L2 blocks
image: /img/socialCards/retrieve-finalized-l2-blocks.jpg
---

A finalized L2 block is a block on an L2 blockchain (Linea) that has been confirmed and validated
by the L1 blockchain (Ethereum), ensuring its immutability and security.

There are two methods to obtain the current finalized block:

- [Use the `finalized` block parameter tag](#use-the-finalized-tag) in JSON-RPC API calls.
- [Query the Linea L1 rollup contract](#query-the-rollup-contract).

## Use the `finalized` tag

Use the `finalized` tag in API calls to specify a block that has been confirmed by the L1
network. For example, here the `eth_getBlockByNumber` method returns information about the current
finalized block:

```bash
curl https://rpc.linea.build \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","method":"eth_getBlockByNumber","params":["finalized",false],"id":1}'
```

### Supported methods

The `finalized` tag is supported by all applicable JSON-RPC API methods on Linea Mainnet and Linea 
Sepolia with the exception of `eth_call`.

## Query the rollup contract

Using the `finalized` tag in JSON-RPC API calls is recommended. As an alternative, you can query 
the [Linea L1 rollup contract](https://etherscan.io/address/0xd19d4b5d358258f05d7b411e21a1460d11b0876f#readProxyContract)
to retrieve the value of the current finalized L2 block number stored in the `currentL2BlockNumber` 
variable.

### Prerequisites

- [Download and install Node.js](https://nodejs.org/en)

### Create the script

1. In your project folder, initialize the project and install the `web3` package:

    ```bash
    npm init -y
    ```

    ```bash
    npm install web3
    ```

1. Create a JavaScript file (for example `index.js`) and copy the following code:

    :::info
    Update the Infura endpoint with your API key, or add a different RPC provider.
    :::

    ```JavaScript title="index.js"
    const { Web3 } = require("web3")

    // Connect to an Ethereum node (e.g., Infura)
    const web3 = new Web3(
      new Web3.providers.HttpProvider(
        `https://mainnet.infura.io/v3/<YOUR-API-KEY>`
      )
    )
    // Define the minimal ABI to obtain the current finalized block number
    const lineaRollupAbi = [
      {
        "constant": true,
        "inputs": [],
        "name": "currentL2BlockNumber",
        "outputs": [
          {
            "name": "",
            "type": "uint256"
          }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      }
    ];

    // Define the contract address
    const lineaRollupAddress = '0xd19d4b5d358258f05d7b411e21a1460d11b0876f';

    // Create a contract instance
    const lineaRollupContract = new web3.eth.Contract(lineaRollupAbi, lineaRollupAddress);

    // Function to get the finalized L2 block number
    async function getFinalizedL2BlockNumber() {
      try {
        const currentL2BlockNumber = await lineaRollupContract.methods.currentL2BlockNumber().call();
        const blockNumberHex = '0x' + BigInt(currentL2BlockNumber).toString(16); // Convert BigInt to hex string

        console.log('Finalized L2 Block Number:', currentL2BlockNumber.toString()); // Print BigInt as string
        console.log('Finalized L2 Block Number (Hex):', blockNumberHex);

        return { blockNumber: currentL2BlockNumber, blockNumberHex };
      } catch (error) {
        console.error('Error fetching L2 block number:', error);
      }
    }

    // Call the function
    getFinalizedL2BlockNumber();
    ```

1. In the project directory, run the script:

    ```bash
    node index.js
    ```


==================== FILE: /workspace/docs/get-started/how-to/linea-safe.mdx ====================

---
title: Create a multi-signature smart contract wallet
description: Use Safe to create a multi-signature smart contract wallet on Linea
image: /img/socialCards/create-a-multi-signature-smart-contract-wallet.jpg
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Safe is a multi-signature smart contract wallet, which means it requires a minimum number of 
signatures to approve a transaction before it can occur. For example, if your business has three 
main stakeholders, you can configure the wallet to require approval from either two out of three 
or all three individuals before a transaction can proceed. This security measure ensures that no 
single person can compromise the funds.

On top of that, Linea Safe gives complete self-custody over funds. In other words, the smart
contract deployed for the wallet has complete control over the wallet's contents, and doesn't
rely on any trusted external party for execution.

To create your Safe wallet click [here](https://app.safe.global/), and select Linea as the network.
To use the app on Linea Sepolia, click [here](https://safe.linea.build).

If you need guidance on using the Safe app, check out their support page [here](https://help.safe.global/).

## Contracts

<Tabs className="my-tabs">
    <TabItem value="mainnet" label="Linea Mainnet">
        <table>
            <tr>
                <th>Contract</th>
                <th>Address</th>
            </tr>
            <tr>
                <td>`CompatibilityFallbackHandler`</td>
                <td><a href="https://lineascan.build/address/0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4#code">0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4</a></td>
            </tr>
            <tr>
                <td>`CreateCall`</td>
                <td><a href="https://lineascan.build/address/0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4#code">0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4</a></td>
            </tr>
            <tr>
                <td>`DefaultCallbackHandler`</td>
                <td><a href="https://lineascan.build/address/0x1AC114C2099aFAf5261731655Dc6c306bFcd4Dbd#code">0x1AC114C2099aFAf5261731655Dc6c306bFcd4Dbd</a></td>
            </tr>
            <tr>
                <td>`GnosisSafe`</td>
                <td><a href="https://lineascan.build/address/0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552#code">0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552</a></td>
            </tr>
            <tr>
                <td>`GnosisSafeL2`</td>
                <td><a href="https://lineascan.build/address/0x3E5c63644E683549055b9Be8653de26E0B4CD36E#code">0x3E5c63644E683549055b9Be8653de26E0B4CD36E</a></td>
            </tr>
            <tr>
                <td>`GnosisSafeProxyFactory`</td>
                <td><a href="https://lineascan.build/address/0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2#code">0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2</a></td>
            </tr>
            <tr>
                <td>`MultiSend`</td>
                <td><a href="https://lineascan.build/address/0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761#code">0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761</a></td>
            </tr>
            <tr>
                <td>`MultiSendCallOnly`</td>
                <td><a href="https://lineascan.build/address/0x40A2aCCbd92BCA938b02010E17A5b8929b49130D#code">0x40A2aCCbd92BCA938b02010E17A5b8929b49130D</a></td>
            </tr>
            <tr>
                <td>`SignMessageLib`</td>
                <td><a href="https://lineascan.build/address/0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2#code">0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2</a></td>
            </tr>
            <tr>
                <td>`SimulateTxAccessor`</td>
                <td><a href="https://lineascan.build/address/0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da#code">0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da</a></td>
            </tr>
        </table>
    </TabItem>
    <TabItem value="sepolia" label="Linea Sepolia">
        <table>
            <tr>
                <th>Contract</th>
                <th>Address</th>
            </tr>
            <tr>
                <td>`CompatibilityFallbackHandler`</td>
                <td><a href="https://sepolia.lineascan.build/address/0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4#code">0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4</a></td>
            </tr>
            <tr>
                <td>`CreateCall`</td>
                <td><a href="https://sepolia.lineascan.build/address/0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4#code">0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4</a></td>
            </tr>
            <tr>
                <td>`DefaultCallbackHandler`</td>
                <td><a href="https://sepolia.lineascan.build/address/0x1AC114C2099aFAf5261731655Dc6c306bFcd4Dbd#code">0x1AC114C2099aFAf5261731655Dc6c306bFcd4Dbd</a></td>
            </tr>
            <tr>
                <td>`GnosisSafe`</td>
                <td><a href="https://sepolia.lineascan.build/address/0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552#code">0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552</a></td>
            </tr>
            <tr>
                <td>`GnosisSafeL2`</td>
                <td><a href="https://sepolia.lineascan.build/address/0x3E5c63644E683549055b9Be8653de26E0B4CD36E#code">0x3E5c63644E683549055b9Be8653de26E0B4CD36E</a></td>
            </tr>
            <tr>
                <td>`GnosisSafeProxyFactory`</td>
                <td><a href="https://sepolia.lineascan.build/address/0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2#code">0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2</a></td>
            </tr>
            <tr>
                <td>`MultiSend`</td>
                <td><a href="https://sepolia.lineascan.build/address/0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761#code">0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761</a></td>
            </tr>
            <tr>
                <td>`MultiSendCallOnly`</td>
                <td><a href="https://sepolia.lineascan.build/address/0x40A2aCCbd92BCA938b02010E17A5b8929b49130D#code">0x40A2aCCbd92BCA938b02010E17A5b8929b49130D</a></td>
            </tr>
            <tr>
                <td>`SignMessageLib`</td>
                <td><a href="https://sepolia.lineascan.build/address/0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2#code">0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2</a></td>
            </tr>
            <tr>
                <td>`SimulateTxAccessor`</td>
                <td><a href="https://sepolia.lineascan.build/address/0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da#code">0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da</a></td>
            </tr>
        </table>
    </TabItem>
</Tabs>




==================== FILE: /workspace/docs/get-started/how-to/connect-wallet.mdx ====================

---
title: Connect a wallet to your dapp
description: >-
  Learn how to connect a wallet to your dapp so users can interact with your
  contracts
image: /img/socialCards/connect-a-wallet-to-your-dapp.jpg
---

Enabling users' wallets to connect to your dapp is critical, since it's the only way they can
send transactions and sign messages that enable them to interact with underlying smart contracts. 

In this guide, we'll go through several methods for connecting wallets to a React dapp.

## Wagmi

Wagmi is a library of React hooks for developing dapps that interact with Ethereum-based blockchains
like Linea. 

To get started, install the packages:

```bash
npm install wagmi viem@2.x @tanstack/react-query
```

### Wagmi configuration

Create a file named `wagmi.ts` in your in your project directory, and add this code:

```ts
import { http, createConfig } from 'wagmi'
import { linea, lineaSepolia, mainnet } from 'wagmi/chains'
import { injected } from 'wagmi/connectors'

const projectId = '<WALLETCONNECT_PROJECT_ID>'

export const config = createConfig({
  chains: [lineaSepolia, linea, mainnet],
  connectors: [injected()],
  transports: {
    [lineaSepolia.id]: http(),
    [linea.id]: http(),
    [mainnet.id]: http(),
  },
})
```

This configuration file ensures Wagmi works with Linea, Linea Sepolia, and Ethereum Mainnet, and 
also defines that we should use the `injected` wallet connector, which works with any wallet that
uses the common EIP-1193 standard. There are a few wallets that also have [separate connectors](https://wagmi.sh/react/api/connectors).

### Add Wagmi and query providers

Next, head to your app file. 

Import the relevant providers from Wagmi and TanStack Query, as well as the `QueryClient` 
function we'll use: 

```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from './wagmi' // path your wagmi.ts config file
```

:::info TanStack Query

TanStack Query, formerly known as React Query, is a library that adds state management for the 
onchain data your dapp requests from the blockchain using Wagmi hooks. It's not essential, but 
recommended.

:::

Then add the following code, so that your dapp is wrapped within the Wagmi and TanStack Query 
providers:

```tsx
'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from './wagmi'

const queryClient = new QueryClient()

export default function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <AppContent />
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```

### Add a wallet connection

There are several ways you could use Wagmi to connect wallets. The simplest is to create a wallet
connector component that uses the `useConnect` hook. 

:::tip Multi-wallet discovery 

If you're up for the challenge, and particularly if you're creating a production dapp, we recommend 
you set up your dapp to support EIP-6963, a standard that defines "multi-wallet discovery". In short, 
this means that your dapp can detect the presence of multiple wallets on the user's device and give 
them the choice of which wallet to connect. 

To see how, follow a guide like [this one](https://hackmd.io/@VydelHxmR0CbKxAe4TjhbQ/BJ9Bf4XD6) or 
[this one](https://metamask.io/news/developers/how-to-implement-eip-6963-support-in-your-web3-dapp/).

:::

To proceed with the simpler implementation, we'll create a new component, in a `/components` 
directory if you prefer, and add the below code. We'll call it `ConnectButton.js`, but choose 
whatever filename you like:

```js
import { useConnect } from 'wagmi'
import { injected } from 'wagmi/connectors'

export function ConnectButton() {
  const { connect } = useConnect()

  return (
    <button onClick={() => connect({ connector: injected() })}>
      Connect wallet
    </button>
  )
}
```

The `useConnect` hook is the main object of note here. 

Now that we've defined the component, we can import and insert it into the dapp:

```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from './wagmi'
import { ConnectButton } from '../components/ConnectButton'

const queryClient = new QueryClient()

export default function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <ConnectButton />
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```

Now if you run `npm run dev`, you should be able to connect your wallet, such as MetaMask, on 
Linea, Linea Sepolia, or Ethereum Mainnet.

Note that this is a very basic implementation, with no CSS styling and missing a few other necessary
features, such as displaying the connected wallet's address ([useAccount](https://wagmi.sh/react/api/hooks/useAccount#address)), 
[connection status](https://wagmi.sh/react/api/hooks/useConnections), and a [disconnect button](https://wagmi.sh/react/api/hooks/useDisconnect). 

## Dynamic

Install the Dynamic SDK and the Ethereum connectors:

```bash
npm install @dynamic-labs/sdk-react-core @dynamic-labs/ethereum
```

The latter contains wallet connectors for all chains compatible with the Ethereum Virtual Machine 
(EVM), Linea included.

### Set up Dynamic dashboard

To properly configure the Dynamic component we're about to use, you need to sign up for Dynamic to
access the [Dynamic dashboard](https://app.dynamic.xyz/).

Once you're in the dashboard, you need to:
1. Enable Linea (and Linea Sepolia, if you need it). [See the guide to configuring your chains](https://docs.dynamic.xyz/chains/enabling-chains).
2. Get the `environmentId` from Developers > SDK & API Keys. 

### Add the provider

To set up the dapp to work with the Dynamic wallet connector button, we need to:
- Wrap dapp contents in the `DynamicContextProvider` component.
- Import the Dynamic Ethereum wallet connectors and pass these to the `DynamicContextProvider` in
its `settings`.

Then, paste the following code into your dapp:

```tsx
import { DynamicContextProvider } from "@dynamic-labs/sdk-react-core";
import { EthereumWalletConnectors } from "@dynamic-labs/ethereum";

export default function App() {
  return (
    <DynamicContextProvider
        settings={{
            environmentId: "YOUR_ENVIRONMENT_ID",
            walletConnectors: [EthereumWalletConnectors]
        }}
    >
      <AppContent />
    </DynamicContextProvider>
  );
}
```

Replace `YOUR_ENVIRONMENT_ID` with the `environmentId` with your own. This enables Dynamic to pull
your configured chains and any other preferences you set up in the dashboard.

:::note

If you intend to use Wagmi in your project, you also need to add a [`DynamicWagmiProvider`](https://docs.dynamic.xyz/react-sdk/providers/dynamicwagmiconnector) 
component and wrap it with [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider), like this:

```tsx
<DynamicContextProvider>
    <WagmiProvider>
        <DynamicWagmiProvider>
            <AppContent />
        </DynamicWagmiProvider>
    </WagmiProvider>
</DynamicContextProvider>
```

:::

### Add the component

Next, [select a wallet component](https://docs.dynamic.xyz/react-sdk/components/components-introduction).
For example, you can use the `DynamicWidget` component if you want a wallet connector button that 
you can configure to use various user onboarding methods such as email, phone number, or even
embedded wallets. 

For simplicity, let's go with [`DynamicConnectButton`](https://docs.dynamic.xyz/react-sdk/components/dynamicconnectbutton), 
which is a classic wallet connection button for connecting external wallets. 

Add it to your import statement:

```tsx
import { DynamicContextProvider, DynamicConnectButton } from "@dynamic-labs/sdk-react-core";
```

Then slot it into your dapp, adding some text:

```tsx
import { DynamicContextProvider, DynamicConnectButton } from "@dynamic-labs/sdk-react-core";
import { EthereumWalletConnectors } from "@dynamic-labs/ethereum";

export default function App() {
  return (
    <DynamicContextProvider
        settings={{
            environmentId: "7cc1f95f-6015-4f0b-888d-e52178b1b27d",
                walletConnectors: [EthereumWalletConnectors]
        }}
    >
       <DynamicConnectButton>
          Connect wallet
       </DynamicConnectButton>
    </DynamicContextProvider>
  );
}
```

Now, run your dapp locally and click the button to test your work:

```bash
npm run dev
```

You should be able to connect to Linea and Linea Sepolia. 

## Privy

[Privy](https://docs.privy.io/) provides multiple SDKs for building dapps. Their [React SDK](https://docs.privy.io/guide/react/)
is an easy way to get a flexible, configurable wallet connection component into your dapp. 

Install the Privy SDK with this command:

```bash
npm install @privy-io/react-auth@latest
```

### Set up Privy dashboard

[Sign up for Privy](https://dashboard.privy.io/) to access the dashboard.

Go to Login Methods in the sidebar to configure login methods for your dapp, and make sure that 
external wallets are enabled. Optionally, feel free to toggle any other methods you want to use.

Now go to App Settings and get your App ID. We'll need to add this to the dapp code to ensure Privy
functions correctly.

### Add the provider

Now we need to import the Privy provider to the dapp and then use it to wrap the dapp contents:

```tsx
'use client'

import { PrivyProvider } from '@privy-io/react-auth';

export default function App() {
  return (
    <PrivyProvider
    appId="your-privy-app-id" // add your App ID here
    config={{
      appearance: {
        theme: 'dark',
      },
    }}
  >
      <AppContent />
    </PrivyProvider>
  );
}
```

The [`appearance` configuration](https://docs.privy.io/guide/react/configuration/appearance) is 
optional.

### Configure Linea

To enable Privy to use Linea, we need to import it from Viem. First, install Viem with this command:

```bash
npm install viem
```

And then add this import statement to your dapp:

```tsx
import { linea, lineaSepolia } from 'viem/chains'
```

Now we need to add the Linea chains to the `PrivyProvider` `config`:

```tsx
'use client'

import { PrivyProvider } from '@privy-io/react-auth';
import { linea, lineaSepolia } from 'viem/chains'

export default function App() {
  return (
    <PrivyProvider
    appId="cm4tv4knx03yv4baen04ozlhv"
    config={{
      appearance: {
        theme: 'dark',
      },
      defaultChain: linea,
      supportedChains: [linea, lineaSepolia],
    }}
  >
      <AppContent />
    </PrivyProvider>
  );
}
```

We've chosen Linea Mainnet as the `defaultChain`, but you can set this with Linea Sepolia instead,
if you prefer.

### Add the component

To implement the wallet connection button, we'll create a new component that uses the `usePrivy` 
hook, which enables you to trigger the Privy login modal to appear.

Create a new file named `ConnectButton.js` in your `/components` directory, and add the following 
code:

```js
import { usePrivy } from '@privy-io/react-auth';

function ConnectButton() {
  const { login } = usePrivy();

  return (
    <button onClick={login}>
      Connect wallet
    </button>
  );
}
```

Now we can import the component and insert it into the dapp. Ensure your dapp reflects this code:

```tsx
'use client'

import { PrivyProvider } from '@privy-io/react-auth';
import { linea, lineaSepolia } from 'viem/chains'
import { ConnectButton } from '../components/ConnectButton';

export default function App() {
  return (
    <PrivyProvider
    appId="cm4tv4knx03yv4baen04ozlhv"
    config={{
      appearance: {
        theme: 'dark',
      },
      defaultChain: linea,
      supportedChains: [linea, lineaSepolia],
    }}
  >
      <ConnectButton />
    </PrivyProvider>
  );
}
```

Now if you run your dapp with `npm run dev`, the Privy modal will appear when you click the button.


==================== FILE: /workspace/docs/get-started/how-to/linea-inscriptions.mdx ====================

---
title: Create an inscription
image: /img/socialCards/create-an-inscription.jpg
---

Bitcoin inscriptions are a method of adding metadata to the smallest unit of Bitcoin, a satoshi (sat). Various types of data, including images, videos, messages, etc., can be "inscribed" onto the Bitcoin blockchain to create NFTs. This concept has been adapted for the Ethereum blockchain, where it's known as ["Ethscriptions"](https://docs.ethscriptions.com/overview/introducing-ethscriptions).

## Implementation

Traditionally, calldata is the most straightforward method for implementing inscriptions. However, this approach can become expensive on L1 during finalization by the sequencer, which in turn can drive up the price on L2 for users to maintain profitability.

To avoid this increase in costs, Linea recommends following [ESIP-3](https://docs.ethscriptions.com/esips/accepted-esips/esip-3-smart-contract-ethscription-creations), for creating inscriptions. This is because events and subcalls do not involve any finalization costs on L1, making them a more cost-effective option for users.

:::info[attention]

**We want to emphasize that this is the best and only method for creating inscriptions on Linea that we will support.** Any team building tools for inscriptions or issuing inscriptions will receive our support, including marketing support, only if they use this pattern documented in ESIP-3. Special thanks to the Lins20 and Carpenter teams! Their collaboration and support were invaluable in creating this reference implementation.

:::

This is implemented by emitting an event:

```bash
event ethscriptions_protocol_CreateEthscription(
    address indexed initialOwner,
    string contentURI
);
```

:::tip

- `initialOwner`is usually the msg.sender.
- `contentURI` should be crafted by minimizing the amount of calldata.

We recommend loading it from the contract code to reduce the amount of calldata that has to be passed to the contract.

:::

## Code examples

<!-- We need some more here.
- What are the addresses? List them here, and link them on important contracts page.
- Explain what these are
- Explain at a high level what you do with them
- Sample code for interacting with them, getting information from them
  - List the methods available? Is `mint` the only one? 
  - We could point to Lineascan's built-in contract interaction capabilities, etc.-->

### Ethscription.sol

```
solidity

// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;


import "./IEthscription.sol";


  /**
  * @title Contract for writing inscriptions.
  * @author Insert your name here.
  * @notice The inscription points to an external CONTENT_URI for the data.
  * @dev See the full ESIP-3 specification for URI format, all events and functions.
  */
contract Ethscription is IEthscription {
    string constant CONTENT_URI = '0x646174613a2c7b2270223a226572632d3230222c226f70223a226d696e74222c227469636b223a2266616972222c22616d74223a2231303030227d';


   /**
   * @notice Mints a new Ethscription.
   * @dev CONTENT_URI is set on contract deployment.
   */
    function mint() external {
        emit ethscriptions_protocol_CreateEthscription(msg.sender, CONTENT_URI);
    }
}
```

### IEthscription.sol

```
solidity

// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;


  /**
  * @title Contract for writing inscriptions.
  * @author Insert your name here.
  * @notice The inscription points to an external CONTENT_URI for the data.
  * @dev See the full ESIP-3 specification for URI format, all events and functions.
  */
  interface IEthscription {
    event ethscriptions_protocol_CreateEthscription(
        address indexed initialOwner,
        string contentURI
    );


    event ethscriptions_protocol_TransferEthscriptionForPreviousOwner(
        address indexed previousOwner,
        address indexed recipient,
        bytes32 indexed id
    );
}
```


==================== FILE: /workspace/docs/get-started/how-to/bridge.mdx ====================

---
title: Bridge tokens to Linea
image: /img/socialCards/bridge-tokens-to-linea.jpg
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

The [Linea bridge app](https://linea.build/hub/bridge) provides multiple ways to 
get funds onto Linea:
- **Native bridge**: Built by our team to provide an interface for the [canonical token bridge](../../technology/canonical-token-bridge.mdx). 
**Best suited for tech operators, protocols, or moving large liquidity**.
- **All bridges**: A bridge aggregator powered by Li.Fi, supporting numerous networks (EVM chains and 
Solana) and tokens. Faster than the native bridge, and the **best option for most users**.
- **Buy**: A fiat onramp aggregator provided by Onramper, enabling you to buy funds on Linea.

:::tip Testnets

Testnet bridging is only possible on the native bridge.

:::

See the below sections for instructions on each option.

## Bridge aggregator

Find the bridge aggregator under the "All Bridges" tab. It's powered by Li.Fi and supports a 
range of chains and tokens. Available networks include most major EVM networks and L2s, plus Solana. 
The optimal bridging routes are automatically selected based on your priority (speed or price, 
configurable in settings), and use a combination of decentralized exchanges (DEXs) and bridges.

Transfers initiated using the bridge aggregator are much faster than those created with the native
bridge, but cost slightly more. (The same applies in reverse for the native bridge: it's slower,
but cheaper.)

For a guide on using the bridge aggregator and FAQs, see our [support guide](https://support.linea.build/bridging/how-to-bridge-to-linea).

## Native bridge

### Bridge ETH or other tokens

Head to the [bridge app](https://linea.build/hub/bridge) and select the "Native Bridge" tab.

<div class="center-container">
  <div class="img-medium">
    <img
      src="/img/get_started/how_to/bridge/bridge/Linea_native_bridge_tab_button.png"
      alt="Linea native bridge tab button"
    />
  </div>
</div>

1. Select the direction of your transfer — either L1 &rarr; L2 or L2 &rarr; L1. 

<div class="center-container">
  <div class="img-medium">
    <img
      src="/img/get_started/how_to/bridge/bridge/Linea_native_bridge_select_transfer_direction.png"
      alt="Linea native bridge select transfer direction"
    />
  </div>
</div>

2. Select the asset you'd like to bridge: ETH or an ERC-20 token. Available ERC-20 tokens are
based on a shortlist we maintain [here](https://github.com/Consensys/linea-token-list/tree/main/json).

:::warning

For some combinations of origin and destination chains and assets, you may need to submit an 
additional transaction on the destination network to claim your funds. This is **manual claiming**,
and is required for any transfers:
- From Linea to Ethereum (L2 &rarr; L1)
- Involving USDC.

Automatic claiming is selected by default for all transfers where it is possible, and manual
claiming is automatically applied when necessary. [See below for more information](#claiming).

:::

<div class="center-container">
  <div class="img-medium">
    <img
      src="/img/get_started/how_to/bridge/bridge/Linea_native_bridge_select_token_button.png"
      alt="Linea native bridge select token button"
    />
  </div>
</div>

<div class="center-container">
  <div class="img-medium">
    <img
      src="/img/get_started/how_to/bridge/bridge/Linea_native_bridge_select_token_modal.png"
      alt="Linea native bridge select token modal"
    />
  </div>
</div>

3. Enter the amount you'd like to bridge.

<div class="center-container">
  <div class="img-medium">
    <img
      src="/img/get_started/how_to/bridge/bridge/Linea_native_bridge_select_amount.png"
      alt="Linea native bridge select amount"
    />
  </div>
</div>

4. If needed, you can nominate a recipient address different to the origin address. To do so, click
the wallet icon in the bottom-right of the widget and input the recipient address you need:

<div class="center-container">
  <div class="img-medium">
    <img
      src="/img/get_started/how_to/bridge/bridge/Linea_native_bridge_add_recipient_address_field.png"
      alt="Linea native bridge add recipient address field"
    />
  </div>
</div>

:::note Approve tokens

If you're bridging an ERC-20 token that you haven't bridged before, you'll need to complete an
additional transaction at this point to approve a spending cap before you can bridge:

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/get_started/how_to/bridge/bridge/Linea_native_bridge_spending_cap_request_MetaMask_prompt3.png"
      alt="Linea native bridge spending cap request MetaMask prompt"
    />
  </div>
</div>

The spending cap enables the bridge app to access the funds you want to transfer.

:::

5. Click "Bridge", and then confirm the details and sign the transaction to proceed.

<div class="center-container">
  <div class="img-medium">
    <img
      src="/img/get_started/how_to/bridge/bridge/Linea_native_bridge_confirm_and_bridge_button.png"
      alt="Linea native bridge confirm and bridge button"
    />
  </div>
</div>

After the transaction is confirmed, your bridge transfer will be visible in your transaction history,
accessible via the icon next to settings in the top-right of the widget.

<div class="center-container">
  <div class="img-medium">
    <img
      src="/img/get_started/how_to/bridge/bridge/Linea_native_bridge_confirmed_transaction_history.png"
      alt="Linea native bridge confirmed transaction history"
    />
  </div>
</div>

### Bridge USDC

USDC is handled differently by the native bridge. Since Linea has [native USDC](https://linea.build/blog/lineas-seamless-upgrade-to-native-usdc-a-game-changer-for-onchain-payments), 
the bridge uses the [Cross-Chain Transfer Protocol](https://circle.com/cross-chain-transfer-protocol) 
(CCTP) rather than the [canonical token bridge](../../technology/canonical-token-bridge.mdx) 
that underpins other native bridge transfers.

USDC transfers currently require [manual claiming](#manual-claiming).

While CCTP does allow for "[fast transfers](https://developers.circle.com/stablecoins/cctp-getting-started)", this option is currently not being offered for Linea.
This is in order to ensure low, transparent pricing to users.

### Claiming

The native bridge allows you to claim your bridged funds manually or automatically. 

- **Manual claiming** requires two transactions to be approved. One on the source layer to initiate 
the bridging process and the other on the target layer by the recipient to receive the funds, which 
we call "claiming". To claim, the recipient has to pay a fee on the target layer.
- **Automatic claiming** requires one transaction to be approved on the source layer. The recipient 
will automatically receive their funds because a "postman" will handle the claiming process for them.

Manual claiming is required for any transfers:
- From Linea to Ethereum (L2 &rarr; L1)
- Involving USDC.

#### Manual claiming

:::warning

If you have an unclaimed manual claim transaction that is older than 90 days, you'll need to claim
it manually, as it will no longer be displayed in the native bridge app. See our [message service reference page](../../technology/message-service/reference.mdx#claim-old-messages) 
for guidance. This situation could arise, for example, because the postman failed for some reason,
such as a network issue.

:::

Go to the transaction history page by clicking the receipt icon in the top-right of the widget.

<div class="center-container">
  <div class="img-medium">
    <img
      src="/img/get_started/how_to/bridge/bridge/Linea_native_bridge_transaction_history_button.png"
      alt="Linea native bridge transaction history button"
    />
  </div>
</div>

If your manual claim transaction is ready to claim, it will be marked as "Ready to claim":

<div class="center-container">
  <div class="img-medium">
    <img
      src="/img/get_started/how_to/bridge/bridge/Linea_native_bridge_manual_ready_to_claim.png"
      alt="Transaction history entry marked as ready to claim"
    />
  </div>
</div>

When you click the transaction, you'll see its details and a "Claim" button — click it to prompt
a transaction in your wallet:

<div class="center-container">
  <div class="img-medium">
    <img
      src="/img/get_started/how_to/bridge/bridge/Linea_native_bridge_claim_manual_transaction_modal.png"
      alt="Claim transaction button in modal"
    />
  </div>
</div>

Once the transaction is complete, your funds will be available in your wallet and the transaction 
history will update accordingly:

<div class="center-container">
  <div class="img-medium">
    <img
      src="/img/get_started/how_to/bridge/bridge/Linea_native_bridge_manual_claim_completed.png"
      alt="Transaction history entry marked as complete"
    />
  </div>
</div>

If you encounter any issues, contact us via our [support site](https://support.linea.build) or 
[Discord](https://discord.gg/linea).

#### Configure claiming

Automatic claiming is the default option wherever possible, though for the following transfers, 
manual claiming is required:
- Linea to Ethereum (L2 &rarr; L1)
- Any transfer involving USDC.

Although manual claiming is mandatory depending on the context, you can toggle between manual and
automatic claiming where applicable by clicking the gear icon in the "Receive" panel:

<div class="center-container">
  <div class="img-medium">
    <img
      src="/img/get_started/how_to/bridge/bridge/Linea_native_bridge_advanced_settings_gear_icon.png"
      alt="Receive panel with gear icon"
    />
  </div>
</div>

The manual claiming toggle will then be available:

<div class="center-container">
  <div class="img-medium">
    <img
      src="/img/get_started/how_to/bridge/bridge/Linea_native_bridge_advanced_settings_manual_claim_toggle.png"
      alt="Manual claiming toggle"
    />
  </div>
</div>

### Execution fees

:::tip Free postman fees for L1 &rarr; L2

The postman fee for L1 &rarr; L2 transfers (i.e. deposits to Linea) is now sponsored for all users for 
all transfers using less than 250,000 gas, covering the majority of bridging use cases. 

This means that most automatic claiming transfers from L1 to L2 now have no fees, apart from a few 
cases [outlined above](#configure-claiming). You will, however, still need to cover the costs of 
the L1 transaction.

:::

The only fees you'll pay on the native bridge are those required to complete the transaction — 
other than network fees, the native bridge is fee-free and Linea does not profit from it.

Two types of execution fees can be applied when bridging with the native bridge: the postman fee and 
the anti-DDOS fee.

Refer to the table for which fees will apply to your bridge transfer. These fees apply to both
ETH and ERC-20 transfers. 

<table>
    <tr>
        <th>Type</th>
        <th>Transaction fee</th>
        <th>Anti-DDOS fee</th>
        <th>Postman fee</th>
    </tr>
    <tr>
        <td>L1 to L2 (Manual claiming)</td>
        <td>:white_check_mark:</td>
        <td>:x:</td>
        <td>:x:</td>
    </tr>
    <tr>
        <td>L1 to L2 (Automatic claiming)</td>
        <td>:white_check_mark:</td>
        <td>:x:</td>
        <td>:x:</td>
    </tr>
    <tr>
        <td>L2 to L1 (Manual claiming)</td>
        <td>:white_check_mark:</td>
        <td>:white_check_mark:</td>
        <td>:x:</td>
    </tr>
</table>

Key:
- Transaction fee: The transaction (gas) fee required for the bridge operation.
- Anti-DDOS fee: A 0.001 ETH fee applied when bridging from L2 to L1.
- Postman fee: `target layer gas price * (gas estimated + gas limit surplus) * margin`, where:
  - `target layer gas price` = `eth_gasPrice` on the target layer
  - `gas estimated` = 100,000
  - `gas limit surplus` = 6000
  - `margin` = 2
  
  Previously the postman fee was applied to automatic claiming transfers from L1 to L2, but is now 
  free.

### How long do bridge transfers take?

For ETH or ERC-20 tokens:
- L2 &rarr; L1: 2-16 hours
- L1 &rarr; L2: ~20 minutes

## Centralized exchange (CEX)

Head to the [Layerswap documentation](https://docs.layerswap.io/user-docs/layerswap-app/transfer-from-cex) 
for guides on transferring from CEXs.

An integration with Layerswap enables you to withdraw funds to Linea from one of several supported 
CEXs. This enables you to move funds from a CEX to Linea even if the CEX doesn't support Linea.

Generally, this process involves these steps:
1. Configure your source CEX and transfer amount.
2. Layerswap generates a unique deposit address.
3. Go to the CEX and transfer the required funds to the deposit address. 
4. Layerswap handles the cross-chain transfer to Linea.

The process can differ slightly depending on the CEX. The [Layerswap docs](https://docs.layerswap.io/user-docs/layerswap-app/transfer-from-cex)
contain guides specific to each CEX.

## Buy

Under the "Buy" tab, you'll find the [Onramper](https://onramper.com/) widget, which enables you
to buy funds on Linea using fiat currency. 

For a guide on using Onramper, see [their resources](https://knowledge.onramper.com/how-to-buy-crypto-using-onramper).

Onramper is an aggregator, and aims to select the best option for your payment method, location, and
token.

KYC is required to use Onramper. 

Onramp options may differ based on your location — check the Onramper [coverage page](https://onramper.com/coverage) 
to see what's available.

## Custom options for moving large liquidity

### Use the canonical token bridge with a custom `BridgedToken` implementation

This is suited for protocols that want to implement special features for the bridged ERC-20 on L2.
**This is only possible if the token has not yet been bridged from L1 to L2 in order to avoid
unexpected changes for end-users.**

Protocols that want to use a custom BridgedToken will be able to incorporate arbitrary logic on the L2
ERC-20, while still relying on the Token Bridge lock and mint logic and cross-chain communication.
**For this to work, protocols need to keep compatibility with the Token Bridge by enabling it to 
call the ERC-20 mint and burn functions.**

If you are interested in this option, please contact the Linea team to get started. The process is 
as follows:

- The token issuer deploys a custom BridgedToken which should enable the Token Bridge to call mint 
and burn functions.
- Linea team will configure the bridge so that it will use your custom contract to mint and burn 
tokens on L2.

:::note

If you are not yet ready with your own implementation, you can deploy the standard BridgedToken 
implementation behind a dedicated upgradable proxy that you will be able to upgrade later

:::

### Build a dedicated token bridge

This is intended for partners who need full control over the bridge and want to implement complex 
cross-chain logic.

The partner will be in charge of building, auditing and operating their own token bridge.

If you are interested by this option, please get in touch with us so that we can:

- Block your L1 token from being bridged on L1 in order to avoid having several copies on Linea
- Provide guidance if you want to rely on our cross-chain messaging system



==================== FILE: /workspace/docs/get-started/how-to/state-recovery.mdx ====================

---
title: Recover state from a finalized block
description: How to reconstruct Linea's state as it was at a given block number.
image: /img/socialCards/recover-state-from-a-finalized-block.jpg
---

In the highly unlikely event that Linea's sequencer fails, it must be possible to reconstruct
Linea's state as it was at the last point in time data was finalized, using L1 data. Conceivably,
any entity could then resume transaction sequencing, confident that state was resuming from the 
correct point. 

State recovery insures against the risks of a single point of failure that could cripple the network.
Since this system can be used by any independent actor to validate state roots against L1-published 
data, it also reduces the need for trust in the Linea [sequencer and coordinator](../../technology/architecture.mdx).

To this end, the Linea Besu execution client has a state recovery plugin that:

1. Retrieves finalized blobs from L1; 
2. Decompresses the blob data;
3. Replays the transactions in the execution client, and, finally,
4. Checks that the resulting `stateRootHash` matches the one finalized on L1. 

Linea Besu executes the fetched transactions in the blob, while the state management plugin, Shomei, 
rebuilds state.

## Prerequisites

:::note Availability

The state recovery plugin only works from the following block numbers onwards:
- Linea Mainnet: TBC (once Beta v2 is live)
- Linea Sepolia: `9572301` (the block where the 2B gas limit was implemented)

:::

State recovery requires that you run:

- Linea Besu with the following plugins:
  - State recovery
  - Shomei
- [Shomei state manager](https://github.com/Consensys/shomei).

### Linea Besu node

The Linea Besu node being used must have been running with the following configuration in the `.toml` 
file since genesis (i.e. from when it started to sync):
- [`FULL`](https://besu.hyperledger.org/public-networks/concepts/node-sync#full-synchronization) sync
mode:
    ```toml
    sync-mode="FULL"
    ```
- [`BONSAI`](https://besu.hyperledger.org/public-networks/reference/cli/options#data-storage-format) 
data storage:
    ```toml
    data-storage-format="BONSAI"
    ```

To learn how to run a Linea Besu node, see our [guide](../how-to/run-a-node/linea-besu.mdx).

### Shomei 

Shomei is a state manager that communicates with Linea Besu (via the corresponding plugin) to 
maintain and update state. 

See the Shomei repository for information on how to run it; [you can access a binary distribution
or pull the latest build from Docker Hub](https://github.com/Consensys/shomei?tab=readme-ov-file#binary-releases). 

## Configuration

Update your Linea Besu node and your Shomei configuration using the below instructions.

### Linea Besu node

:::info 

Only enable state recovery if you intend the node to be used specifically for state recovery. Even 
if you do not specify a block from which state recovery should start, default behavior will 
ensure that state recovery will replace standard P2P syncing. It's therefore not possible to add
the state recovery plugin and configuration without it affecting your node's behavior.

:::

To proceed with state recovery, your node must have been running normally, in line with the above 
conditions (i.e. `FULL` sync mode and `BONSAI` data storage enabled).

Only then can you proceed by adding the following configuration parameters.

Insert them into the `.toml` configuration file alongside any existing plugin configurations, or via
the command line by adding `--` before each parameter:

```toml
### Plugin Configuration ###
Xplugins-external-enabled=true
Xbonsai-limit-trie-logs-enabled=false
plugins=["BesuShomeiRpcPlugin","ZkTrieLogPlugin","LineaStateRecoveryPlugin"]
plugin-shomei-http-host="..." // Replace with your Shomei host IP address
plugin-shomei-http-port= ... // Replace with your Shomei port
plugin-staterecovery-linea-sequencer-beneficiary-address="0xa27342f1b74c0cfb2cda74bac1628d0c1a9752f2"
plugin-staterecovery-l1-smart-contract-address="0xb218f8a4bc926cf1ca7b3423c154a0d627bdb7e5"
plugin-staterecovery-l1-endpoint="https://sepolia.infura.io/v3/INFURA_APP_KEY"
plugin-staterecovery-l1-polling-interval="PT12S"
plugin-staterecovery-l1-success-backoff-delay="PT2S"
plugin-staterecovery-l1-retry-backoff-delay="PT4S"
plugin-staterecovery-l1-earliest-search-block="7316705"
plugin-staterecovery-l1-highest-search-block="FINALIZED"
plugin-staterecovery-shomei-endpoint="http://shomei-sr-sepolia:8888"
plugin-staterecovery-blobscan-endpoint="https://api.sepolia.blobscan.com"
plugin-staterecovery-overriding-recovery-start-block-number=9572301
```

:::note

The `plugin-staterecovery-l1-endpoint` parameter assumes that you have the variable `INFURA_APP_KEY` 
stored in your environment. If not, or if you want to use a different RPC endpoint, ensure you
update this.

:::

`plugin-staterecovery-overriding-recovery-start-block-number=9572301` will instruct the client to
sync as normal, via P2P, until block `9572300`, the block before the one specified. After this, it 
will begin using the state recovery plugin and sync based on data recovered from L1 blobs. 

If your node has already synced to a block number greater than the one you specify in this parameter,
the state recovery plugin will start on the next block (`head block + 1`).

### Shomei

Run Shomei in [mode 1](https://github.com/Consensys/shomei?tab=readme-ov-file#mode-1-trace-generation),
which involves enabling these flags, either via the command line or in the configuration file:

```toml
--enable-trace-generation=true
--trace-start-block-number=BLOCK_NUMBER // Choose a more recent block for faster syncing
```

And then ensure that you configure Shomei to be aware of where the Linea Besu node is running:

```toml
--besu-rpc-http-host=... // Replace with your Linea Besu node's host
--besu-rpc-http-port=... // Replace with your Linea Besu node's port
```


==================== FILE: /workspace/docs/risk-disclosures/index.mdx ====================

---
title: Risk disclosures
sidebar_position: 8
image: /img/socialCards/risk-disclosures.jpg
---

## Risk disclosures

The Linea Mainnet will be upgraded on a continuous basis. Security is a top priority and we will seek to improve the guarantees that users have when using the system. This page reflects the current threats and security measures users should be aware of prior to using the Linea network.

### Potential threats and security measures

Given that the current network is an Alpha version of the Linea Mainnet, rather than a full release, we are currently in the process of ongoing security audits and assessments. As such, your data and crypto-assets might face certain risks, potentially originating from software bugs or similar issues.

Linea employs novel, cutting-edge technology which could potentially harbor unanticipated risks and issues. Possible consequences could include data loss or the disappearance of crypto-assets.

Processes involving cross-blockchain bridging could potentially become targets for cyber threats and attacks, including but not limited to exploits that target vulnerabilities in the software, hardware, infrastructure, or equipment associated with bridge components, smart contracts, and other related systems.

### Network accessibility and efficiency

Given the Alpha status of the Mainnet, there may be occasional periods where Linea's performance slows down or becomes temporarily unavailable without advance warning. These instances could potentially result in the unforeseen loss of access, data, or crypto-assets. Users engaging in high-value transactions should be aware that transaction completion might be delayed.

### The journey towards decentralization

The team behind Linea is actively pursuing further decentralization of the system. This implies a progressive enhancement of the system's decentralization and trust minimization over time.

The Mainnet Alpha will integrate some centralized components like the Sequencer, Prover and Security Council, maintained by the Linea team to help bootstrap the network. The Sequencer possesses the capability to postpone transaction inclusion and rearrange transactions.

Additionally, the validity proofs used to verify the computation of Linea batches do not prove 100% of EVM opcodes and precompiles. This means that the proof doesn't have full completeness and a level of trust is placed on the Linea operator to not maliciously alter the state of the system.

Ensuring the Linea Mainnet Alpha’s security is an ongoing endeavor. This involves addressing security issues, a task that falls under the jurisdiction of our Security Council. The Council, consisting of eight members, holds the authority to pause the rollup and upgrade the Linea Mainnet Alpha immediately without submitting a validity proof, given the threshold of 75% signatories, in order to respond to urgent security problems. If council members were to act with malice or collude, it could compromise system integrity, potentially leading to network upgrades that may result in the loss of crypto-assets.

Given the centralized nature of the Sequencer and Prover during the Mainnet Alpha phase, there exist potential risks related to network downtime and outages, some of which may be outside of the control of the Linea team.

During the initial launch of the Mainnet Beta, users won't be able to force transactions on Layer 1 and withdrawal limits are placed on the bridge to minimize the impact of any potential malicious actors.

For more details on the Linea Decentralization and Trust Minimization Roadmap, see [here](https://docs.linea.build/decentralization-roadmap).

### Third-party dapps

Just as Ethereum does, Linea also operates on a permissionless framework, meaning that any individual is free to launch any smart contract code they choose. When engaging with contracts on Linea, users should adhere to the same precautions as with Ethereum - that is, they should only interact with an application if they are confident in its security and trustworthiness.

### Audits and security checks

Linea's implementation has undergone careful construction, with continuous internal and external audits from leading web3 security companies, including Consensys Diligence, as well as reviews and testing in alignment with engineering best practices. Despite this, it's improbable that all potential bugs or vulnerabilities have been identified, implying that undiscovered vulnerabilities might put user funds at risk. Users should keep this risk in mind when deciding the amount of value to put onto the Linea Mainnet Alpha.

To ensure thorough security checks, we have initiated an extensive bug bounty program for Linea. This is to motivate the community to identify critical bugs in the system. More details can be found on the Linea Bug Bounty page on [Immunefi](https://immunefi.com/bounty/linea/).


==================== FILE: /workspace/docs/zero-knowledge-glossary/index.mdx ====================

---
title: Zero knowledge glossary
description: An open source glossary to aid your zero knowledge journey!
sidebar_position: 7
image: /img/socialCards/zero-knowledge-glossary.jpg
---

This glossary is open source and consistently being updated. If you'd like a term to be added, please [create an issue](https://github.com/Consensys/doc.linea/issues) or create a pull request and define one yourself!

## A

### arithmetization

Arithmetization is the process of turning computational problems into equations. It can be summarized as turning computer programs into "math," so that they can be analyzed using cryptographic algebraic techniques.

### appchain

A blockchain network custom-made and optimized for a specific application's needs. An appchain is generally not a full-blown blockchain, but offers an optimized execution environment for the application, while still relying on an underlying blockchain for consensus.

Deploying appchains on top of L2 networks like Linea offers significant cost and customization capabilities.

See also: "blockchain trilemma", "modular blockchain", "Layer 2", "Layer 3".

## B

### blockchain trilemma

Blockchain network builders face a tradeoff between three factors: decentralization, security, and scalability (or speed). Often, designing a system that optimizes for one compromises another.

### Brakedown

The first built system that provides linear-time SNARKs for NP, meaning the prover incurs O(N) finite field operations to prove the satisfiability of an N-sized R1CS instance. Brakedown’s prover is faster, both concretely and asymptotically, than prior SNARK implementations.

Brakedown doesn't require a trusted setup and is plausibly post-quantum secure.

## C

### circuit

A circuit uses logic gates to depict the flow of data and the sequence of operations performed on that data in a given computational task. Circuits are used at many levels to create processing capability, including virtual machines like the Ethereum Virtual Machine, and Linea's implementation of a zkEVM.

### constraint

A constraint refers to a condition imposed on mathematical operations or computation to ensure the correctness, efficiency, or security of an algorithm.

## D

### data availability

Data availability is the guarantee that the block proposers are required to publish the data for each block, which nodes participating in Ethereum's consensus store locally. Rather than having to trust that block producers are honest, all nodes on the Ethereum network execute the transactions to verify that the new information is valid.

Data availability is one of the ways in which a [L2](#layer-2) differs from a [sidechain](#sidechain).

## E

### elliptic curve cryptography

A method of encrypting information used in many applications, including in public blockchain networks. It is commonly used to create "public-private key pairs": a pair of cryptographic elements. The public key can be used to encrypt things which can then only be decrypted by the private key.

ECC uses mathematical theories surrounding elliptic curves to render the encryption extremely difficult to decipher without the correct private key.

### Ethereum Virtual Machine (EVM)

A stack-based virtual machine that executes bytecode. In Ethereum, the execution model specifies how the system state is altered given a series of bytecode instructions and a small tuple of environmental data. This is specified through a formal model of a virtual state machine.

### execution trace

This is a record of what happened during the execution of a transaction. This is usually represented as a list, in which each item is the state of the machine at a specific clock time, which includes information such as:

- Who was the caller
- Block number
- What contracts were invoked
- What data was changed
- And more!

This is relevant to zk-rollups because execution traces are used to construct the [validity proof](#validity-proof) verified by the verifier contract on Ethereum.

## F

### Fraud proof

In optimistic rollups, fraud proofs (fault proofs) are the evidence a verifier provides to question the validity of a batch of transactions. Depending on how they are executed, these proofs scrutinize a section of transactions and endeavor to confirm their validity.

## G

### gnark

gnark is a software library that offers users the ability to design and run computational circuits in zk-SNARKs through a high-level API.

The library is open source and developed under the Apache 2.0 license.

### Groth16

Groth16 is a circuit-specific preprocessing general-purpose zk-SNARK construction. It has become a de-facto standard used in several blockchain projects due to the constant size of its proof, and its appealing verifier time.

On the downside, Groth16 needs a circuit-specific trusted setup for its preprocessing phase.

## H

### hash function

A mathematical function that converts a data input of any chosen length and size into an output that is encrypted and has a fixed length and size. Once converted, the hash cannot be reverse-engineered to reveal the original input of data. This makes the data input more secure against decryption.

## I

## J

## K

### keccak

Keccak (pronounced “ketchak”) is a versatile cryptographic function best known for its uses in hashing. It provides increased levels of security when compared to older hash algorithms.

See also: SHA, hash function.

## L

### Layer 1

Layer 1 (L1) is the underlying foundation and base blockchain that various layer 2 (L2) networks build on top of. For example, Ethereum is an L1 that is comprised of node operators to secure and validate the network, block producers, the history of transaction data, and the consensus mechanism of the blockchain itself.

### Layer 2

Layer 2 (L2) is a separate blockchain that increases transaction speed and throughput, while fully or partially deriving its security from Ethereum. Additionally, L2 projects must rely on Ethereum for data availability by posting their transaction data onto Ethereum. L2s decrease L1 congestion by bundling transactions to be submitted to Ethereum, thus increasing scalability while inheriting Ethereum’s data availability, security, and decentralization.

## M

## N

## O

### Oracle

This is a computational entity or service that provides information or answers to specific queries.

### Optimistic rollup

A rollup of transactions that use [fraud proofs](#fraud-proof) to offer increased [L2](#layer-2) transaction throughput while using the security provided by Mainnet ([L1](#layer-1)). Unlike Plasma, a similar [L2](#layer-2) solution, optimistic rollups can handle more complex transaction types – anything possible in the EVM. However, in order to release assets back on the L1, users must wait for a seven-day challenge period. Liquidity providers can help alleviate distributing L1 ETH immediately, but this relies on trust in the security of the provider, and doesn't provide a mechanism for transferring NFTs.

## P

### Polynomial commitment

A polynomial commitment scheme is a cryptographic primitive that allows a party to publicly commit to a value or a piece of information without ever revealing the actual value itself. This allows us to prove that a polynomial satisfies some properties without ever revealing what the polynomial is. Additionally, this is useful for zk-rollups because the commitment is smaller than the polynomial itself.

### Polynomial IOP (Interactive Oracle Proof)

An Interactive Oracle Proof (IOP) is a protocol in which the verifier is not required to fully read the prover's messages (the [traces](#execution-trace) and [constraints](#constraint) generated from [arithmetization](#arithmetization)). Instead, the verifier has [oracle](#oracle) access to the prover’s messages. This oracle is repeatedly queried to create the concrete proof system, or [polynomial commitment](#polynomial-commitment) for the [validity proof](#validity-proof).

## Q

## R

### Rollup

A type of [L2](#layer-2) scaling solution that batches multiple transactions and submits them to the Ethereum main chain in a single transaction. This allows for reductions in gas costs and increases in transaction throughput. There are optimistic and zero-knowledge rollups, which use different security methods to offer these scalability gains.

Rollup architecture is made up of the following components:

- **Rollup contract**: contract on the L1 stores rollup blocks, monitors state updates on the rollup, and tracks user deposits
- **Off-chain VM**: computation and state storage on another virtual machine separate from the Ethereum Virtual Machine
- **Aggregators/sequencers/operators/validators**: nodes that aggregate transactions, compress the underlying data, and publish the block on Ethereum
- **Verifier contract**: contract on the L1 that verifies the [validity proof](#validity-proof)

## S

### Scaling

The main goal of scalability is to increase transaction speed (faster finality), and transaction throughput (high transactions per second), without sacrificing decentralization or security.

### Sidechain

A scaling solution that uses a separate chain with different, often faster, consensus rules. A bridge is needed to connect these sidechains to Mainnet. Rollups also use sidechains, but they operate in collaboration with Mainnet instead. Sidechains are NOT considered [L2](#layer-2) solutions, because they do not leverage Ethereum for data availability and security.

## T

### Transaction fee

A fee you need to pay whenever you use the Ethereum network. Examples include: sending funds from your wallet, or a dapp interaction, like swapping tokens or buying a collectible. You can think of this like a service charge. This fee will change based on how busy the network is. This is because miners or sequencers, the people responsible for processing your transaction depending on the network, are likely to prioritize transactions with higher fees – so congestion forces the price up.

## U

## V

### Validity proof

A security model for certain [L2](#layer-2) solutions where, to increase speed, transactions are rolled up into batches and submitted to Ethereum in a single transaction. The transaction computation is done off-chain and then supplied to the main chain with a proof of their validity. This method increases the amount of transactions possible while maintaining security. Some rollups use [fraud proofs](#fraud-proof).

### Verifiable computation

Verifiable computation allows a “weak computer” (Ethereum L1) to offload computation to a potentially untrusted, but “powerful computer” (Linea L2). The “powerful computer” must return a validity proof of the correctness of its results. Verifying the proof is cheaper than performing the computation from scratch.

## W

## X

## Y

## Z

### Zero-knowledge proof

A zero-knowledge proof, or zk-proof, is a cryptographic method that allows an individual to prove that a statement is true without conveying any additional information. This is commonly associated with privacy, but is great for _scaling_ blockchain networks through rollups, because it reduces the amount of information you have to provide to lower layers. This is the [validity proof](#validity-proof) that the “powerful computer” must provide for [verifiable computation](#verifiable-computation).

### Zero-knowledge rollup

This is a [L2 scaling solution](#layer-2) that uses a [zero-knowledge proof](#zero-knowledge-proof) as its [validity proof](#validity-proof) to post data back to Ethereum L1. As compared to [optimistic rollups](#optimistic-rollup), this validity proof allows for a more secure trust assumption and removes the need for a challenge period.

### zkEVM

A zkEVM is a virtual machine that executes smart contracts and proves the correctness of execution using zero-knowledge proofs. ZkEVMs recreate aspects of Ethereum’s design, which provides an “Ethereum-like” experience for developers and users. For Ethereum developers, this means you can write in Solidity, but leverage the zkEVM to perform off-chain computations to offload execution from Ethereum, enabling the scalability provided by zk-rollups!

### zk-SNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge)

This is a type of zk-proof where the prover and verifier don’t have to interact. With zk-SNARKs, you can verify 1 transaction or 1 billion transactions in the same amount of time, which is great for scaling. You can read more about zk-SNARKs [here](https://consensys.net/blog/blockchain-explained/zero-knowledge-proofs-starks-vs-snarks/) and [here](https://docs.gnark.consensys.net/Concepts/zkp).


==================== FILE: /workspace/docs/learn/ecosystem-tutorials/irys/irys-nfts.mdx ====================

---
title: Create an NFT
image: /img/socialCards/create-an-nft.jpg
description: Build permanent NFTs using Irys and Linea.
---

You can use [Irys](../../../get-started/tooling/permanent-data/irys/overview.mdx) to create an NFT on Linea in three steps:

1. Deploy your smart contract on Linea
2. Permanently store your NFT assets on Irys
3. Mint your NFTs using metadata stored on Irys

When you upload NFTs to Irys, you make a one-time payment for and your data is guaranteed to be retrievable forever. Creators and
collectors benefit from the assurance that their NFTs are preserved indefinitely. NFT metadata and
images stored on Irys are permanent and immutable.

:::note
You can also use Irys to create [dynamic NFTs](./irys-dynamic-nfts.mdx) that evolve based on onchain or
offchain actions.
:::

## Deploy your smart contract

If you're new to NFTs and smart contract development, consider deploying
one of [the audited ThirdWeb contracts](../../../get-started/how-to/deploy-smart-contract/thirdweb.mdx) to learn more.

You can also [deploy this minimal contract using Remix](../../../get-started/how-to/deploy-smart-contract/remix.mdx).

```solidity
// SPDX-License-Identifier: MIT
// Compatible with OpenZeppelin Contracts ^5.0.0
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract IrysLineaNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _nextTokenId;

    constructor(address initialOwner)
        ERC721("IrysLineaNFT", "ILNFT")
        Ownable(initialOwner)
    {}

    function safeMint(address to, string memory uri) public onlyOwner {
        uint256 tokenId = _nextTokenId++;
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, uri);
    }

    // The following functions are overrides required by Solidity.
    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
```

## Store your assets on Irys

Uploads to Irys are fully unconstrained; you can upload files of any size and use Irys to make
images, videos, music, or interactive NFTs.

This guide covers using the [Irys CLI](../../../get-started/tooling/permanent-data/irys/irys-quickstart.mdx#irys-cli) 
to upload your assets to Irys. You can also do the same using the [Irys SDK](../../../get-started/tooling/permanent-data/irys/irys-quickstart.mdx#irys-sdk).

### Store your visual assets

#### Install the Irys CLI

Install the CLI globally using the `-g` flag. Depending on your setup, you may or may not need to use `sudo`.

```bash
npm i -g @irys/cli
```
Depending on your setup, you may need to use the sudo command.

```bash
sudo npm i -g @irys/cli
```

#### Upload single assets

To upload a single file, use the command `irys upload`.

```bash
irys upload myNFT.png \
  -t linea-eth \
  -w bf20......c9885307
```

The CLI will output the link to download the file from the Irys gateway.

Example:

```bash
Uploaded to https://gateway.irys.xyz/A7CXNp4WqwkY73TRxKR2o3gfSCw3ghhZZXiP8CM6Yv1x
```

#### Upload multiple assets

To upload a folder of files, use the command `irys upload-dir`.

```bash
irys upload-dir myNFTs \
  -t linea-eth \
  -w bf20......c9885307
```

The CLI outputs a link to the manifest for the upload:

```bash
https://gateway.irys.xyz/A7CXNp4WqwkY73TRxKR2o3gfSCw3ghhZZXiG8CM6Yv1f
```

The CLI also produces a `.json` file containing the transaction IDs of each upload:

```json
{
  "manifest": "irys/paths",
  "version": "0.1.0",
  "paths": {
    "nft1.png": { "id": "B7CXNp4WqwkY73TRxKR2o3gfSCw3ghhZZXiP8CM6Yv1x" },
    "nft2.png": { "id": "C7CXNp4WqwkY73TRxKR2o3gfSCw3ghhZZXiP8CM6Yv1x" },
    "nft3.png": { "id": "D7CXNp4WqwkY73TRxKR2o3gfSCw3ghhZZXiP8CM6Yv1x" },
    "nft4.png": { "id": "E7CXNp4WqwkY73TRxKR2o3gfSCw3ghhZZXiP8CM6Yv1x" },
    "nft5.png": { "id": "F7CXNp4WqwkY73TRxKR2o3gfSCw3ghhZZXiP8CM6Yv1x" }
  }
}
```

You can download files by using the transaction ID directly, or by creating a URL using the manifest
ID combined with the original file name. For example, `nft1.png` can be downloaded with either of these URLs:

- `https://gateway.irys.xyz/gF7CXNp4WqwkY73TRxKR2o3gfSCw3ghhZZXiP8CM6Yv1x`
- `https://gateway.irys.xyz/F7CXNp4WqwkY73TRxKR2o3gfSCw3ghhZZXiP8CM6Yv1x/nft1.png`

### Store your metadata

#### Create metadata

Create unique metadata files, one for each NFT.

```json
{
  "name": "Irys & Linea Forever",
  "description": "Irys & Linea NFTs #42",
  "image": "https://gateway.irys.xyz/F7CXNp4WqwkY73TRxKR2o3gfSCw3ghhZZXiP8CM6Yv1x",
  "background_color": "FEF4EE"
}
```

#### Upload metadata

Upload the metadata to Irys

```console
irys upload metadata.json \
  -t linea-eth \
  -w bf20......c9885307
```

## Mint the NFTs

Now use your metadata URLs (in the format `https://gateway.irys.xyz/:txId`) to mint the NFTs
using [the contract you deployed on Linea](../../../get-started/how-to/deploy-smart-contract/index.mdx).


==================== FILE: /workspace/docs/learn/ecosystem-tutorials/irys/index.mdx ====================

---
title: Irys
image: /img/socialCards/irys.jpg
---

import DocCardList from "@theme/DocCardList";

<DocCardList />


==================== FILE: /workspace/docs/learn/ecosystem-tutorials/irys/irys-dynamic-nfts.mdx ====================

---
title: Create a dynamic NFT
image: /img/socialCards/create-a-dynamic-nft.jpg
description: Create NFTs that evolve based on user actions.
---

Data on Irys is permanent and immutable, but you can use
[Irys's mutability features](https://docs.irys.xyz/build/d/features/mutability) to simulate
mutability and create dynamic NFTs that evolve based on onchain or offchain actions.

A mutable-style URL is a single, static URL that is linked to a series of transactions.
You can add a new transaction to the series at any time, and the URL will always resolve to the
most recent transaction.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/learn/ecosystem-tutorials/irys/irys_dynamic_nfts/mutable-references.png"
      alt=""
    />
  </div>
</div>

In this guide, you will create a dynamic NFT using Irys's mutability features. Dynamic NFTs are NFTs whose
metadata evolves over time. They are commonly used in:

- Gaming projects where in-game assets evolve as players progress.
- Loyalty programs where NFTs evolve as users accumulate points.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/learn/ecosystem-tutorials/irys/irys_dynamic_nfts/all-characters.png"
      alt=""
    />
  </div>
</div>

This tutorial focuses on creating a SuperMon NFT that can evolve during gameplay. The NFT starts with
a basic appearance that can be upgraded twice. We will use the
[Irys CLI](../../../get-started/tooling/permanent-data/irys/irys-quickstart.mdx#irys-cli) to "mutate" the
metadata, simulating the automatic changes that would occur through player interactions in an actual game.

## Prerequisites

[Install the Irys CLI](../../../get-started/tooling/permanent-data/irys/irys-quickstart.mdx#irys-cli) to upload
your images and metadata.

## How to create a "mutable" URL

1. Create a single static URL that is tied to a chain of transactions:

    ```js
    const irysUploader = await getIrysUploader();
    const receiptOne = await irysUploader.upload("First TX");
    console.log(`TX 1 uploaded https://gateway.irys.xyz/mutable/${receiptOne.id}`);
    ```

1. Update the "chain" by posting a second transaction (from the same wallet) tagged with the original transaction's ID:

    ```js
    const tags = [{ name: "Root-TX", value: receiptOne.id }];
    const receiptTwo = await irysUploader.upload("Second TX", { tags });
    console.log(`TX 2 uploaded https://gateway.irys.xyz/mutable/${receiptOne.id}`);
    ```

## Deploy your smart contract

Deploy your NFT smart contract. The following is a simple example that you can use to mint
the NFT that we'll create.

```solidity filename="SuperMon.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Import OpenZeppelin's ERC721 and ERC721URIStorage contracts
// These URLs are compatible with Remix IDE
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract SuperMon is ERC721URIStorage {
    uint256 private _tokenIdCounter;

    // No arguments in the constructor, the owner will be the contract deployer
    constructor() ERC721("SuperMon", "SMON") {
        _tokenIdCounter = 0;
    }

    // Mint function to create a new NFT
    function mint(address to, string memory uri) public {
        uint256 tokenId = _tokenIdCounter;
        _tokenIdCounter += 1;
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, uri);
    }
}

```

[Deploy the smart contract using Remix](../../../get-started/how-to/deploy-smart-contract/remix.mdx), or
[any other environment](../../../get-started/how-to/deploy-smart-contract/index.mdx).

## Upload the images

1. Right-click each image and save it on your local drive.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/learn/ecosystem-tutorials/irys/irys_dynamic_nfts/image-level-1-3.png"
      alt=""
    />
  </div>
</div>

1. Fund the Irys Devnet with 0.1 [Linea Sepolia ETH](https://infura.io/faucet/linea) to pay
    for your uploads.

    :::info
    In all of these CLI examples, ensure you replace the value of the `-w` parameter with your own private key.
    :::

    ```bash
    irys fund 100000000000000000 \
      -n devnet \
      -t linea-eth \
      -w 6dd5e....54a120201cb6a \
      --provider-url https://rpc.sepolia.linea.build
    ```

    :::note
    The `fund` command accepts a value in atomic units, 0.1 ETH is equal to 100000000000000000 in atomic units.
    :::

1. Use the Irys CLI to upload each of the images to the Irys Devnet.

    ```bash
    irys upload image-level-1.png \
      -n devnet \
      -t linea-eth \
      -w 6dd5e....54a120201cb6a \
      --provider-url https://rpc.sepolia.linea.build

    irys upload image-level-2.png \
      -n devnet \
      -t linea-eth \
      -w 6dd5e....54a120201cb6a \
      --provider-url https://rpc.sepolia.linea.build

    irys upload image-level-3.png \
      -n devnet \
      -t linea-eth \
      -w 6dd5e....54a120201cb6a \
      --provider-url https://rpc.sepolia.linea.build
    ```

## Upload the metadata

1. Create three metadata files similar to the ones below. Make sure to change the value of the image field
    to match the URLs generated in the previous step.

    ```json filename="metadata-level-1.json"
    {
      "name": "SuperMon",
      "symbol": "SMON",
      "image": "https://gateway.irys.xyz/A7CXNp4WqwkY73TRxKR2o3gfSCw3ghhZZXiP8CM6Yv1x",
      "description": "Super dooper, changing shapes, changing power",
      "attributes": [
        {
          "trait_type": "supermon-level",
          "value": "1"
        }
      ]
    }
    ```

    ```json filename="metadata-level-2.json"
    {
      "name": "SuperMon",
      "symbol": "SMON",
      "image": "https://gateway.irys.xyz/A7CXNp4WqwkY73TRxKR2o3gfSCw3ghhZZXiP8CM6Yv1x",
      "description": "Super dooper, changing shapes, changing power",
      "attributes": [
        {
          "trait_type": "supermon-level",
          "value": "2"
        }
      ]

    }
    ```

    ```json filename="metadata-level-3.json"
    {
      "name": "SuperMon",
      "symbol": "SMON",
      "image": "https://gateway.irys.xyz/A7CXNp4WqwkY73TRxKR2o3gfSCw3ghhZZXiP8CM6Yv1x",
      "description": "Super dooper, changing shapes, changing power",
      "attributes": [
        {
          "trait_type": "supermon-level",
          "value": "3"
        }
      ]

    }
    ```

1. Upload **just the first file** using the Irys CLI:

    ```console
    irys upload metadata-level-1.json \
      -n devnet \
      -t linea-eth \
      -w 6dd5e....54a120201cb6a \
      --provider-url https://rpc.sepolia.linea.build
    ```

The CLI will return a URL similar to `https://gateway.irys.xyz/2N9YPwW3KdWcDsCZr4EWzZryZVUxbDN4oKRiutLxKJrF`.
To convert that to a mutable references URL, interpolate it by adding `/mutable/` after the
domain and before the transaction ID.

Your final URL will be similar to `https://gateway.irys.xyz/mutable/2N9YPwW3KdWcDsCZr4EWzZryZVUxbDN4oKRiutLxKJrF`.

## Mint the NFT

To mint your NFT in [Remix](https://remix.ethereum.org/):

1. Under **Deployed Contracts**, locate your contract and expand it to see its functions.
1. Under the `Mint` function, enter the wallet address you want to mint the NFT to and the
    metadata URL (e.g. `https://gateway.irys.xyz/mutable/2N9YPwW3KdWcDsCZr4EWzZryZVUxbDN4oKRiutLxKJrF`) from
    the previous step.
1. Select **Transact**.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/learn/ecosystem-tutorials/irys/irys_dynamic_nfts/open-sea-mockup.jpg"
      alt=""
    />
  </div>
</div>

You can now view the NFT on the [Opensea Testnet](https://testnets.opensea.io/account).

## Mutate the metadata

To "mutate" the NFT, upload a new version of the metadata tagging it as having a `Root-TX`
equal to the transaction ID of your first transaction. In this example, we pass the
value of `2N9YPwW3KdWcDsCZr4EWzZryZVUxbDN4oKRiutLxKJrF`, however make sure to change this to match your
unique transaction ID.

```bash
irys upload metadata-level-2.json \
  -n devnet \
  -t linea-eth \
  -w 6dd5e....54a120201cb6a \
  --tags Root-TX 2N9YPwW3KdWcDsCZr4EWzZryZVUxbDN4oKRiutLxKJrF \
  --provider-url https://rpc.sepolia.linea.build
```

Return to Opensea and request that it refresh your metadata.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/learn/ecosystem-tutorials/irys/irys_dynamic_nfts/refresh-metadata.png"
      alt=""
    />
  </div>
</div>

Give it a few minutes and your updated NFT should be visible.

## Free metadata uploads

This tutorial uses the Irys Devnet where uploads are kept for ~60 days and are paid for with free
faucet currencies. When deploying production projects, you'll use Irys's mainnet where uploads are permanent.

Uploads of less than 100 KiB are free on Irys, which is more than enough for most metadata files. This
means projects can let users "evolve" their NFTs without having to pay gas fees.

## Caching

Wallets and NFT websites typically cache metadata to optimize performance, this can affect the
visibility of updates to dynamic NFTs. While OpenSea offers a feature for users to manually request
metadata refreshes, not all platforms provide this level of control. When building dynamic NFT
projects, make sure to thoroughly test and understand the implications of caching on your platform.


==================== FILE: /workspace/docs/learn/ecosystem-tutorials/index.mdx ====================

---
title: Ecosystem tutorials
description: Curated community and ecosystem tutorials.
image: /img/socialCards/ecosystem-tutorials.jpg
---

import DocCardList from "@theme/DocCardList";

Building on Linea is more than just deploying a smart contract!

Here you can find a list of tutorials and educational resources created by our community and 
ecosystem contributors to help guide you through Solidity, web3 fundamentals, and full dapp 
tutorials.

<DocCardList />


==================== FILE: /workspace/docs/learn/ecosystem-tutorials/usdc.mdx ====================

---
title: USDC quickstart
description: Build a simple dapp to transfer USDC on Linea.
image: /img/socialCards/usdc-quickstart.jpg
---

USDC, [issued by Circle](https://developers.circle.com/stablecoins/what-is-usdc),
enables the seamless transfer of digital dollars on the Linea network using a smart contract. 
This guide will walk you through building a simple React app that allows users to connect their
wallet and send USDC transactions over Linea Sepolia.

## Prerequisites

Before you begin, ensure you have the following:

- ✅ Development environment
  - [Node.js (16+)](https://nodejs.org/) installed (comes with `npm`).
  - MetaMask browser extension installed.
- ✅ Fund your wallet
  - Native gas token (ETH on Linea Sepolia) to cover transaction fees.
  - USDC tokens for testing. ([Use a faucet](../../get-started/how-to/get-testnet-eth.mdx) to get 
  testnet USDC and ETH.)

## Project setup

### Step 1: Create a new project

Run the following commands to set up your project:

```bash
mkdir usdc-transfer-app
cd usdc-transfer-app
npm init -y
```

### Step 2: Install dependencies

Run the following command to install the required libraries:

```bash
npm install react@latest react-dom@latest @types/react@latest @types/react-dom@latest @vitejs/plugin-react@latest typescript@latest vite@latest viem@latest
```

### Step 3: Configure `package.json`

After installing dependencies, open your `package.json` file and verify that it looks similar to this:

```json
{
  "name": "usdc-transfer-app",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@types/react": "^19.0.11",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react": "^4.3.4",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "typescript": "^5.8.2",
    "viem": "^2.23.12"
  },
  "devDependencies": {
    "vite": "^6.2.2"
  }
}
```

If your `package.json` doesn't have the `scripts` section, add it. This ensures you can run the 
project using:

```bash
npm run dev
```

## Configure blockchain clients

### Public client (for reading blockchain data)

Create a `src/clients.ts` file and add:

```ts
import { http, createPublicClient } from 'viem';
import { lineaSepolia } from 'viem/chains';

export const publicClient = createPublicClient({
  chain: lineaSepolia,
  transport: http(),
});
```

### Wallet client (for sending transactions)

Modify `src/clients.ts`:

```ts
import { createWalletClient, custom } from 'viem';

export const walletClient = createWalletClient({
  chain: lineaSepolia,
  transport: custom(window.ethereum!),
});
```

## Define USDC contract details

Add this to `src/constants.ts`:

```ts
export const USDC_CONTRACT_ADDRESS = '0xfece4462d57bd51a6a552365a011b95f0e16d9b7';

export const USDC_ABI = [
  {
    constant: false,
    inputs: [
      { name: "_to", type: "address" },
      { name: "_value", type: "uint256" },
    ],
    name: "transfer",
    outputs: [{ name: "", type: "bool" }],
    type: "function",
  },
  {
    constant: true,
    inputs: [{ name: "_owner", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "balance", type: "uint256" }],
    type: "function",
  },
];
```

## Implement wallet connection and USDC transfer

Create `src/App.tsx`:

```tsx
import React, { useEffect, useState } from 'react';
import { publicClient, walletClient } from './clients';
import { USDC_CONTRACT_ADDRESS, USDC_ABI } from './constants';
import { type Address, encodeFunctionData, type Hash, type TransactionReceipt, stringify } from 'viem';

function USDCApp() {
  const [account, setAccount] = useState<Address>();
  const [balance, setBalance] = useState<string>();
  const [hash, setHash] = useState<Hash>();
  const [receipt, setReceipt] = useState<TransactionReceipt>();

  const addressInput = React.createRef<HTMLInputElement>();
  const valueInput = React.createRef<HTMLInputElement>();

  // Fetch USDC balance
  const fetchBalance = async (address: Address) => {
    const balance: bigint = await publicClient.readContract({
      address: USDC_CONTRACT_ADDRESS,
      abi: USDC_ABI,
      functionName: "balanceOf",
      args: [address],
    });
    setBalance((Number(balance) / 10 ** 6).toFixed(2));
  };

  // Connect Wallet
  const connect = async () => {
    const [address] = await walletClient.requestAddresses();
    setAccount(address);
    fetchBalance(address);
  };

  return (
    <div>
      <h1>USDC Transfer Sample App</h1>
      {account ? (
        <>
          <p><strong>Connected Wallet:</strong> {account}</p>
          <p><strong>USDC Balance:</strong> {balance ? `${balance} USDC` : "Fetching..."}</p>
        </>
      ) : (
        <button onClick={connect}>Connect Wallet</button>
      )}
    </div>
  );
}

export default USDCApp;
```

## Configure your entry point

Create `src/main.tsx`:

```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import USDCApp from './App';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <USDCApp />
  </React.StrictMode>
);
```

## Create your HTML file

Create `index.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>USDC Transfer Sample App</title>
</head>
<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>
</html>
```

## Start your app

Run the following command:

```bash
npm run dev
```

Then open `http://localhost:5173` in your browser.



==================== FILE: /workspace/docs/learn/fallback.mdx ====================

---
title: Add a fallback for RPC requests
description: >-
  Use Wagmi's `fallback` Transport in your app for contingency in case one RPC
  endpoint fails.
image: /img/socialCards/add-a-fallback-for-rpc-requests.jpg
---

It's best practice to ensure your app can still function if your primary RPC endpoint provider fails,
enabling JSON-RPC API requests to fall back to an alternative. Wagmi provides a [`fallback`](https://wagmi.sh/core/api/transports/fallback) 
function that fulfils this need, and is based on the [corresponding Viem function](https://v1.viem.sh/docs/clients/transports/fallback.html).

It enables you to add multiple [Transports](https://viem.sh/docs/clients/intro#transports) — the 
element of Viem, and therefore Wagmi, which handles requests — to your app's configuration. If the 
first fails, the request falls back to the next Transport.

## Prerequisites

Install Wagmi and Viem: 

```bash
npm install @wagmi/core @wagmi/connectors viem
```

Viem is required for Wagmi to function. The `@wagmi/connectors` package is not strictly necessary, 
since `fallback` is included in `@wagmi/core`, but you'll most likely need it for your app anyway. 

## Usage

You can implement the `fallback` transport by adding it to your app's Wagmi configuration:

```typescript
    export const wagmiConfig = createConfig({
    chains: [linea],
    transports: {
        [linea.id]: fallback([
        http('https://linea-mainnet.infura.io/v3/{YOUR_API_KEY}'), // Primary RPC provider
        http('https://rpc.linea.build'),        // Fallback RPC provider
        ]),
    }
```

In this example, we define a primary RPC endpoint (Infura) and a fallback (`rpc.linea.build`). 

<details>
    <summary>See full code example</summary>
    ```typescript title="src/config/wagmiConfig.ts"
    import { createConfig, http, fallback } from '@wagmi/core';
    import { jsonRpcProvider } from '@wagmi/core/providers/jsonRpc';
    import { linea } from 'viem/chains';

    // Add the fallback to the config
    export const wagmiConfig = createConfig({
      chains: [linea],
      transports: {
        [linea.id]: fallback([
          http('https://rpc.linea.build'),        // primary RPC HTTP endpoint
          http('https://another.rpc.endpoint/1'), // fallback HTTP endpoint
        ]),
      },
    });
    ```
</details>

Optionally, you can also configure the [`rank` parameter](https://v1.viem.sh/docs/clients/transports/fallback.html#rank-optional)
to enable your fallback Transport(s) to be used in order of latency and stability.


==================== FILE: /workspace/docs/learn/voting-dapp.mdx ====================

---
title: Build a voting dapp
description: A step-by-step guide to building a simple voting dapp on Linea.
image: /img/socialCards/build-a-voting-dapp.jpg
---

Web3 values such as transparency, trust and decentralization naturally lend themselves to 
decentralized voting, where removing intermediaries and ensuring transparency can significantly
enhance the democratic process. 

In this tutorial, we will build a simple voting dapp, and you'll learn how to write, deploy and 
interact with a smart contract designed for a decentralized voting process.

## Architecture

The voting dapp has three main components: 
- Smart contracts
- The smart contracts' integration
- Frontend interface.

The smart contract handles critical functionalities such as: 
- Registering candidates
- Allowing users to give their votes based on candidates index numbers
- Enforcing a one-vote-per-address policy
- Managing the voting period by automatically closing it after a specified duration. 

The smart contract makes sure that the voting process is secure, transparent, and tamper-proof by 
recording all votes on the blockchain.

The frontend interface is the user-facing part of the application where users can interact and cast 
their votes by inputting the candidate index number. It also can show information about the 
remaining time period.

To ensure seamless interaction with the Linea blockchain, we'll utilize the MetaMask SDK and Wagmi 
and connect through Infura RPC providers. These tools allow the frontend to communicate with the 
blockchain, enabling users to sign transactions and interact with the smart contracts directly from 
their web browsers. 

## Set up the environment

Before we start building our dapp, we'll set up the development environment using **Consensys's 
Create Web3 Template CLI**. This tool streamlines the process by generating a monorepo structure 
that includes both the frontend and backend components needed for our application.

### Prerequisites

- **Node.js** and **pnpm/any other package manager** installed on your system.
- Basic familiarity with the command line.

### Initialize the project

Let's create a new project using the [Create Web3 Template CLI](https://npmjs.com/package/@consensys/create-web3-template) 
by Consensys.

This command-line tool simplifies the setup process by providing all the necessary tools and 
integrations out of the box, including MetaMask SDK, Linea support, Infura integration, and a 
selection of templates to choose from.

1. Open your terminal and run the following command:
    
    ```bash
    pnpm create @consensys/create-web3-template
    ```
    
2. You'll be prompted to specify a name for your project. We'll name it `simple-voting-dapp`:
    
    ```
    ? Please specify a name for your project: simple-voting-dapp
    ```
    
3. Next, select the framework for your frontend. We'll choose **Next.js**:
    
    ```
    ? Please select the framework you want to use:
      HardHat Vanilla
      React
    ❯ Next.js
    ```
    
    *Selected framework: Next.js*
    
4. Choose the smart contract development environment. We'll go with **HardHat**:
    
    ```
    ? Would you like to use HardHat or Foundry?
    ❯ HardHat
      Foundry
    
    ```
    
    *Selected tooling: HardHat*
    
5. Select your preferred package manager. We'll use **pnpm**:
    
    ```
    ? Please select the package manager you want to use:
      Yarn
      NPM
    ❯ pnpm
    
    ```
    
6. The CLI will generate the project based on your selections.

### Project structure

After the setup is complete, your project directory `simple-voting-dapp` will have the following 
structure:

```
simple-voting-dapp
├── packages
│   ├── site          # Frontend built with Next.js
│   └── blockchain    # Smart contracts using HardHat
├── pnpm-workspace.yaml
├── package.json
```

- **`packages/site`**: Contains the frontend code of the dapp, built with Next.js.
- **`packages/blockchain`**: Contains the smart contracts and related scripts using HardHat.
- **`pnpm-workspace.yaml`**: Defines the workspace configuration for the monorepo.

### Install dependencies

Navigate into your project directory:

```bash
cd simple-voting-dapp
```

Install all the necessary dependencies:

```bash
pnpm install
```

This command will install all packages for both the frontend and backend components.

### Understanding the monorepo

A **monorepo** (monolithic repository) is a single repository that stores code for multiple 
projects or packages. In our case, it allows us to manage both the frontend and backend in a 
unified codebase, making development and maintenance more efficient.

### Verify the setup

To ensure everything is set up correctly, let's run the development servers.

**For the frontend:**

1. Navigate to the `site` directory:
    
    ```bash
    cd packages/site
    ```
    
2. Start the Next.js development server:
    
    ```bash
    pnpm dev
    ```
    
3. Open your browser and go to `http://localhost:3000` to see the frontend running.

**For the backend:**

1. Open a new terminal window.
2. Navigate to the `blockchain` directory:
    
    ```bash
    cd packages/blockchain
    ```
    
3. Compile the default smart contracts:
    
    ```bash
    pnpm hardhat compile
    ```
    
    This will compile the sample contracts included in the HardHat setup.
    

## Write the smart contract

Let's create a `Voting.sol` file and add the following code: 

```jsx
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/// @title A contract for a voting system
/// @author [Your Name]
/// @notice This contract allows for the creation and management of a voting system
contract Voting {
    /// @dev Struct to represent a candidate
    struct Candidate {
        string name;
        uint256 voteCount;
    }

    /// @notice Array to store all candidates
    Candidate[] public candidates;
    
    /// @notice Address of the contract owner
    address owner;
    
    /// @notice Mapping to track if an address has voted
    mapping(address => bool) public voters;

    /// @notice Timestamp when voting starts
    uint256 public votingStart;
    
    /// @notice Timestamp when voting ends
    uint256 public votingEnd;

    /// @notice Constructor to initialize the voting contract
    /// @param _candidateNames Array of candidate names
    /// @param _durationInMinutes Duration of the voting period in minutes
    constructor(string[] memory _candidateNames, uint256 _durationInMinutes) {
        for (uint256 i = 0; i < _candidateNames.length; i++) {
            candidates.push(Candidate({
                name: _candidateNames[i],
                voteCount: 0
            }));
        }
        owner = msg.sender;
        votingStart = block.timestamp;
        votingEnd = block.timestamp + (_durationInMinutes * 1 minutes);
    }

    /// @notice Modifier to restrict function access to the contract owner
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    /// @notice Adds a new candidate to the election
    /// @param _name Name of the new candidate
    function addCandidate(string memory _name) public onlyOwner {
        candidates.push(Candidate({
                name: _name,
                voteCount: 0
        }));
    }

    /// @notice Allows a voter to cast their vote
    /// @param _candidateIndex Index of the candidate in the candidates array
    function vote(uint256 _candidateIndex) public {
        require(!voters[msg.sender], "You have already voted.");
        require(_candidateIndex < candidates.length, "Invalid candidate index.");

        candidates[_candidateIndex].voteCount++;
        voters[msg.sender] = true;
    }

    /// @notice Retrieves all candidates and their vote counts
    /// @return An array of Candidate structs
    function getAllVotesOfCandidates() public view returns (Candidate[] memory){
        return candidates;
    }

    /// @notice Checks if voting is currently active
    /// @return Boolean indicating if voting is active
    function getVotingStatus() public view returns (bool) {
        return (block.timestamp >= votingStart && block.timestamp < votingEnd);
    }

    /// @notice Calculates the remaining time in the voting period
    /// @return The remaining time in seconds
    function getRemainingTime() public view returns (uint256) {
        require(block.timestamp >= votingStart, "Voting has not started yet.");
        if (block.timestamp >= votingEnd) {
            return 0;
        }
        return votingEnd - block.timestamp;
    }
}
```

This contract provides a basic framework for a decentralized voting system where users can cast 
votes for candidates securely and transparently. It ensures that each user can vote only once by 
tracking voter addresses, and it maintains a record of all votes on the blockchain. The contract 
manages the voting period by specifying start and end times, enforcing voting rules, and providing 
functions to retrieve voting results and status. Let's explore the concept of the smart contract a 
bit more:

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/voting-dapp/voting.png"
      alt=""
    />
  </div>
</div>

**1. Contract initialization and candidate setup**

- The `Voting` contract initializes with an array of candidate names provided during deployment.
- Each candidate is represented by a `Candidate` struct containing a `name` and a `voteCount`.
- The constructor sets the `votingStart` time to the current block timestamp.
- It calculates the `votingEnd` time by adding the specified duration in minutes to the start time.

**2. Access control and owner functions**

- The contract stores the deployer's address as `owner`.
- An `onlyOwner` modifier restricts certain functions to the contract owner.
- The `addCandidate` function allows the owner to add new candidates after hardhat deployment.This ensures only authorized users can modify the list of candidates.

**3. Voting mechanism**

- The `vote` function lets users cast a vote by specifying a candidate's index.
- A `voters` mapping tracks whether an address has already voted.
- The function checks if the voter hasn't voted before and if the candidate index is valid.
- Upon a valid vote, it increments the candidate's `voteCount` and marks the voter as having voted.

**4. Utility functions and voting status**

- `getAllVotesOfCandidates` returns all candidates and their current vote counts.
- `getVotingStatus` returns `true` if voting is active based on the current time.
- `getRemainingTime` calculates and returns how much time is left in the voting period.
- These functions provide users with real-time information about the election.

This smart contract facilitates a decentralized voting system where users can vote for candidates 
securely, with all votes and results recorded on the blockchain.

## Deploy the smart contract

In the `ignition` folder, let's create a file named `Voting.ts` to deploy our contract. Add the 
following code:

```tsx
import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";

const VotingModule = buildModule("VotingModule", (m) => {
  // Default values
  const DEFAULT_CANDIDATES = ["Candidate 1", "Candidate 2", "Candidate 3"];
  const DEFAULT_DURATION_MINUTES = 60; // 1 hour

  // Get parameters with default values
  const candidateNames = m.getParameter("candidateNames", DEFAULT_CANDIDATES);
  const durationInMinutes = m.getParameter(
    "durationInMinutes",
    DEFAULT_DURATION_MINUTES
  );

  // Deploy the Voting contract
  const voting = m.contract("Voting", [
    candidateNames,
    durationInMinutes,
  ]);

  return { voting };
});

export default VotingModule;
```

In this deployment script, we utilize Hardhat Ignition to manage the deployment of our `Voting` 
contract. We set default candidates and a default voting duration but also allow these values to be 
customized through parameters if needed.

### Compile the contract

Before deploying, compile the contract by running the following command in the `blockchain` directory:

```bash
npx hardhat compile
```

This will compile your Solidity code and prepare it for deployment.

### Set up environment variables

Before deploying the smart contract, ensure that your `.env` file in the `packages/blockchain` 
directory is updated with the necessary environment variables:

```bash
# Infura API key for connecting to Ethereum networks
INFURA_API_KEY=your_infura_api_key_here

# Private key of the account to be used for deployments and transactions
ACCOUNT_PRIVATE_KEY=your_account_private_key_here

```

- Replace `your_infura_api_key_here` with your actual Infura API key.
- Replace `your_account_private_key_here` with the private key of the Ethereum account you will use 
for deploying the contract.

### Deploy the smart contract

To deploy the smart contract on Linea Sepolia, run the following command from the `blockchain` 
directory:

```bash
npx hardhat ignition deploy ignition/modules/Voting.ts --network linea-testnet
```

This command tells Hardhat to use Ignition to deploy the `Voting` module to the `linea-testnet` 
network.

Alternatively, you can add a deployment script to your `package.json` to simplify the process. Add 
the following line under the `"scripts"` section:

```json
"scripts": {
  "deploy:testnet": "npx hardhat ignition deploy ignition/modules/Voting.ts --network linea-testnet"
}
```

Now you can deploy the contract by simply running:

```bash
pnpm run deploy:testnet
```

After deployment, you'll receive the contract address. Keep this address safe, as we'll need it 
when integrating with the frontend.

## Frontend integration with Next.js and Shadcn UI

### View frontend

Navigate to the `site` directory in your monorepo:

```bash
cd packages/site
```

Since we've already set up the frontend using the Create Web3 Template CLI, we can proceed to 
integrate our smart contract.

### Configure Wagmi and MetaMask SDK

Create a `wagmi.config.ts` file in the `src` directory with the following content:

```tsx
import { http, createConfig } from "wagmi";
import { lineaSepolia } from "wagmi/chains";
import { metaMask } from "wagmi/connectors";

export const config = createConfig({
  chains: [lineaSepolia],
  connectors: [metaMask()],
  transports: {
    [lineaSepolia.id]: http(),
  },
});
```

This configuration sets up the connection to the Linea testnet and enables wallet integration 
using MetaMask.

### Add contract constants

In the `src` directory, create a file named `constants.ts` and add the following:

```tsx
export const CONTRACT_ADDRESS = 'your_deployed_contract_address_here';

export const ABI = [
  // Paste the ABI of your Voting contract here
];
```

- Replace `'your_deployed_contract_address_here'` with the actual contract address you obtained 
after deployment.
- For the ABI, you can find it in the `artifacts` folder generated by Hardhat after compilation.

## React and hooks usage

```jsx
"use client";

import { useState } from "react";
import { useAccount, useWalletClient } from "wagmi";
import { ConnectButton } from "@consensys/connect-button";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useReadContract, useWriteContract } from "wagmi";
import { Card, CardContent } from "@/components/ui/card";
import { contractAddress, contractAbi } from "../../constants";
```

This Next.js client-side component uses React's `useState` for state management, Wagmi hooks 
(`useAccount`, `useWalletClient`, `useReadContract`, `useWriteContract`) for wallet and contract 
interactions, imports UI elements (`Button`, `Input`, `Card`, `CardContent`) from Shadcn UI, 
includes a `ConnectButton` for MetaMask connection, and brings in `contractAddress` and `contractAbi` 
from constants for contract use.

## Interface definition

```jsx
interface Candidate {
  index: number;
  name: string;
  voteCount: number;
}
```

- Defines a TypeScript `interface` named `Candidate`.
- Specifies the structure for candidate objects:
    - `index`: The candidate's index number.
    - `name`: The candidate's name.
    - `voteCount`: The number of votes the candidate has received.

## Component initialization

```jsx
export default function Home() {
  const { address } = useAccount();
  const { data: walletClient } = useWalletClient();
  const [number, setNumber] = useState("");

```
- **Function component**: Defines the `Home` component as the default export.
- **Wallet information**:
    - `address`: The user's wallet address obtained from `useAccount`.
    - `walletClient`: The wallet client used for signing transactions.
- **State management**:
    - `number`: A state variable to store the candidate index input by the user for voting.
    - `setNumber`: Function to update the `number` state.

## Smart contract interaction - reading data

```jsx
const { writeContract } = useWriteContract();

const { data: votingStatus } = useReadContract({
  address: contractAddress,
  abi: contractAbi,
  functionName: "getVotingStatus",
}) as { data: boolean };

const { data: canVote } = useReadContract({
  address: contractAddress,
  abi: contractAbi,
  functionName: "voters",
  args: [address],
});

const { data: remainingTime } = useReadContract({
  address: contractAddress,
  abi: contractAbi,
  functionName: "getRemainingTime",
}) as { data: bigint };

const { data: candidates } = useReadContract({
  address: contractAddress,
  abi: contractAbi,
  functionName: "getAllVotesOfCandidates",
}) as { data: Candidate[] };
```

- **Writing to contract**:
    - `writeContract` is prepared for sending transactions to the smart contract.
- **Reading contract data**:
    - `votingStatus`: Retrieves whether the voting is currently active.
    - `canVote`: Checks if the current user has already voted.
    - `remainingTime`: Gets the time remaining before the voting period ends.
    - `candidates`: Fetches the list of all candidates and their vote counts.
- **Type assertions**:
    - Uses TypeScript `as` syntax to specify the expected data type for better type safety.

## Early return for missing data

```jsx
if (!candidates) return;
```

- Checks if the `candidates` data is available.
- If `candidates` is `undefined` or `null`, the component returns early to prevent rendering errors.

## Voting functionality

```jsx
async function vote() {
  if (!walletClient || !address || number === "") {
    console.error("Missing required data for voting");
    return;
  }
  if (
    isNaN(Number(number)) ||
    Number(number) < 0 ||
    Number(number) >= candidates.length
  ) {
    console.error("Invalid candidate index");
    return;
  }
  if (!votingStatus) {
    console.error("Voting is not currently active");
    return;
  }
  try {
    console.log("Attempting to vote for candidate index:", number);
    writeContract({
      address: contractAddress,
      abi: contractAbi,
      functionName: "vote",
      args: [BigInt(number)],
      account: address,
    });
  } catch (error) {
    console.error("Detailed error in vote function:", error);
  }
}
```

- **Input validation**:
    - Checks if the wallet client, user address, and candidate number are available.
    - Validates that the candidate index is a valid number within the range of available candidates.
    - Ensures that voting is currently active.
- **Voting process**:
    - Uses `writeContract` to call the `vote` function on the smart contract.
    - Passes the candidate index as a `BigInt`.
    - Uses the user's wallet address as the account.
- **Error handling**:
    - Wraps the contract interaction in a `try-catch` block to handle any errors that occur during 
    the voting process.
    - Logs detailed error information to the console.

## UI rendering

```jsx
return (
  <main className="container mx-auto p-4">
    <h1 className="text-2xl font-bold mb-4">
      Decentralized Voting Application
    </h1>
    <ConnectButton />

    {votingStatus ? (
      address ? (
        <Card className="mt-4">
          <CardContent>
            <p>Connected Account: {address}</p>
            <p>Remaining Time: {Number(remainingTime)} seconds</p>
            {!canVote ? (
              <div className="mt-4">
                <Input
                  type="number"
                  placeholder="Enter Candidate Index"
                  value={number}
                  onChange={(e) => setNumber(e.target.value)}
                  className="mb-2"
                />
                <Button onClick={vote}>Vote</Button>
              </div>
            ) : (
              <p>You have already voted</p>
            )}
            <div className="mt-4">
              <h2 className="text-xl font-semibold mb-2">Candidates</h2>
              <ul>
                {candidates.map((candidate) => (
                  <li key={candidate.index}>
                    {candidates.indexOf(candidate)}: {candidate.name} -{" "}
                    {Number(candidate.voteCount)} votes
                  </li>
                ))}
              </ul>
            </div>
          </CardContent>
        </Card>
      ) : (
        <p>Please connect your wallet to vote</p>
      )
    ) : (
      <p>Voting has finished</p>
    )}
  </main>
);

```

The component features a styled main container with a header and a `ConnectButton` for MetaMask 
integration. It conditionally renders content based on `votingStatus` and user connection: if voting
is active and the user is connected, it displays their address, remaining time, and voting options; 
if they've already voted, it notifies them and lists all candidates. If the user isn't connected, 
it prompts them to connect their wallet. When voting has ended, it shows "Voting has finished".

## Error handling and validation

- **Input validation**:
    - Ensures the candidate index entered is a valid number within the acceptable range.
- **Error messages**:
    - Uses `console.error` to log meaningful error messages for debugging purposes.
- **User feedback**:
    - Provides real-time feedback to the user based on their actions and the application's state.

View the [full code](https://github.com/meowyx/simple-voting-dapp).

### Run the development server

```bash
npm run dev
```

Your Next.js application with Shadcn UI should now be running at `http://localhost:3000`.

Now, you have a decentralized voting dapp where users can vote for the candidates by using their 
index number. These votes are secure, transparent and recorded on Linea blockchain.

To build on this project, you could add voter registration or vote delegation, enhance security 
measures, or improve the user interface for better accessibility.

Happy coding!


==================== FILE: /workspace/docs/learn/first-dapp.mdx ====================

---
title: Build your first dapp on Linea
description: A step-by-step guide to building your first dapp on Linea.
image: /img/socialCards/build-your-first-dapp-on-linea.jpg
---

## Gm developers 👋

Today we're going to learn how to create a dapp that will allow a web3 degen to stake certain tokens in your contract! 🔥

We'll be using the Linea blockchain ⛓️ for this tutorial. It's a zk-rollup EVM equivalent and fully EVM-compatible, with advantages such as high speed and low costs.

You can get some Linea Sepolia (testnet) ETH [here](../get-started/how-to/get-testnet-eth.mdx). 

:::info

As Linea uses the **London** version of Ethereum, a small number of recent opcodes are [not available](../get-started/build/ethereum-differences.mdx).

:::

### Requirements

- Basic blockchain and web development knowledge
- A set-up MetaMask wallet (be sure to download it from [metamask.io](https://metamask.io))
- [Node](https://nodejs.org/en/download/package-manager) and your favorite package manager ([pnpm](https://pnpm.io/installation) | [npm](https://docs.npmjs.com/cli/v10/configuring-npm/install) | [yarn](https://classic.yarnpkg.com/lang/en/docs/install/))
    
:::info

Versions used for this tutorial: `node 20.11.1` & `pnpm 9.9.0`

:::

### 1️⃣ Create your contract

First, we'll start with the staking contract. To simplify the deployment, we'll use Remix, an online tool that speeds up Solidity development. For a complete development environment, you can use [Foundry](https://book.getfoundry.sh/) or [Hardhat](https://hardhat.org/).

*You can follow the steps directly on the images if you don't know how to use Remix.*

1. Go to [Remix ↗️](https://remix.ethereum.org/) and create a new file in the contracts folder.
2. Copy and paste the following code ⏬

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract StakingWithAllowlist {
    mapping(address => mapping(address => uint256)) public stakedBalances;
    mapping(address => bool) public allowlistedTokens;

    event Staked(address indexed user, address indexed token, uint256 amount);
    event Withdrawn(address indexed user, address indexed token, uint256 amount);

    constructor(address[] memory tokens) {
        for (uint256 i = 0; i < tokens.length; i++) {
            allowlistedTokens[tokens[i]] = true;
        }
    }

    function stake(address _token, uint256 _amount) public {
        require(allowlistedTokens[_token], "Token is not in the allowlist");
        require(_amount > 0, "Amount must be greater than 0");
        IERC20 token = IERC20(_token);
        require(token.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");
        stakedBalances[msg.sender][_token] += _amount;
        emit Staked(msg.sender, _token, _amount);
    }

    function withdraw(address _token, uint256 _amount) public {
        require(allowlistedTokens[_token], "Token is not in the allowlist");
        require(_amount > 0, "Amount must be greater than 0");
        require(stakedBalances[msg.sender][_token] >= _amount, "Insufficient staked balance");
        IERC20 token = IERC20(_token);
        stakedBalances[msg.sender][_token] -= _amount;
        require(token.transfer(msg.sender, _amount), "Token transfer failed");
        emit Withdrawn(msg.sender, _token, _amount);
    }

    function isTokenAllowlisted(address _token) public view returns (bool) {
        return allowlistedTokens[_token];
    }
}
```

This is a simplified version of a staking contract with an allowlist, so let's take a moment to explain it:

- This contract allows you to stake virtually any ERC-20, and contains the two basic functions "stake" and "withdraw".
- The allowlist is set up when the contract is deployed; there are other versions where the allowlist can be modified, usually by the owner.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/learn/first-dapp/tutoremix_1.png"
      alt="First 2 instructions on Remix interface"
    />
  </div>
</div>

1. Then go to the *Solidity Compiler* tab.
2. Select the London version in the EVM Version list under Advanced Configurations (to avoid any compatibility problems, even if there won't be any with this contract).
3. Click on the *Compile* button.
    
    You can also get the ABI on this page, after compiling the code, you'll see this below the compile button:
    
<div class="center-container">
  <div class="img-large">
    <img
      src="/img/learn/first-dapp/image.png"
      alt="compile menu on Remix"
    />
  </div>
</div>
    
    You can copy the ABI using the button at the bottom. Save it in a JSON file, as you'll need it later.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/learn/first-dapp/tutoremix_2.png"
      alt="Compile instructions on Remix interface"
    />
  </div>
</div>

1. Finally, we're ready to deploy the contract. To do this, go to the *Deploy* tab.
2. Select your injected provider (for us, MetaMask) as the environment. You'll get a connection request that you'll have to accept.
    - What should I do if my injected provider doesn't appear? 🆘
        
        If your injected provider does not appear by default, follow these steps:
        
        1. Click on *Customize this list* at the very bottom of the environment list. A page will open in Remix.
        2. You should see your injected provider here. Simply click on the box at the top right and it should appear at the top of the list.
        
        <div class="center-container">
          <div class="img-large">
            <img
            src="/img/learn/first-dapp/tutoremix_troubleshoot1.png"
            alt="injected provider menu on Remix"
          />
        </div>
      </div>
        
        Troubleshoot: injected provider not in Environment list
        
3. Check that the contract is the one you want to deploy.
4. Enter the list of tokens you want to allowlist. For this tutorial, I've deployed 3 ERC-20 contracts that you can use (you can copy and paste directly into the field): 

```solidity
["0x46871676658472B99720F2a368CDa6430c1647b9","0xB7D70343639aF53a02f6ea7d9cde240fc72de6Dd","0x66a6F52C2100FB82EE21FD1380b4D516CB540c93"]
```

Those ERC-20 contracts are verified so you can interact with them directly on Lineascan to mint some tokens. Put your address and the number of tokens you want (don't forget that if you want 1 token you have to put 1e18, e.g., 100000000000000000).

- [Mint link for COFFEE](https://sepolia.lineascan.build/address/0x46871676658472b99720f2a368cda6430c1647b9#writeContract#F3)
- [Mint link for TEA](https://sepolia.lineascan.build/address/0xb7d70343639af53a02f6ea7d9cde240fc72de6dd#writeContract#F3)
- [Mint link for WATER](https://sepolia.lineascan.build/address/0x66a6f52c2100fb82ee21fd1380b4d516cb540c93#writeContract#F3)
1. Finally, click on deploy and confirm the transaction in MetaMask. You should see success logs appear in the console at the bottom right. The contract address can be copied by going to recorded transactions (under the deploy button), but you can also find it by searching for your address on the [Sepolia Linea explorer](https://sepolia.lineascan.build).

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/learn/first-dapp/tutoremix_3.png"
      alt="Deploy instructions on Remix interface"
    />
  </div>
</div>


### 2️⃣ Create the frontend

We're going to create a simple frontend. You can find all the code [here](https://github.com/jidohanbaiki/linea_staking).

We'll create this frontend using `rainbowkit`, which will set up a new [Next.js](https://nextjs.org/) app and is built on top of another library called `wagmi`. These libraries greatly simplify how to handle reading chain state, wallet connections, sending transactions, listening for events and state changes, etc.

Let's begin! 🔥

1. Run this command: `pnpm create @rainbow-me/rainbowkit@latest` and choose a project name.
2. Then run `cd yourprojectname` and open the project in your favorite IDE (eg: `code .` to open it in VS Code).
3. Now you can configure the chain to Linea Sepolia by modifying the `src/wagmi.ts` file:

```tsx
import { getDefaultConfig } from '@rainbow-me/rainbowkit';
import { lineaSepolia } from 'wagmi/chains';

export const config = getDefaultConfig({
  appName: 'Linea Token Staking App',
  projectId: 'YOUR_PROJECT_ID',
  chains: [lineaSepolia],
  ssr: true,
});
```

1. We need configure the project and setup some styling. We'll use `shadcn` with `tailwindcss` to make it easier:

```bash
pnpm install -D tailwindcss postcss autoprefixer lucide-react
npx tailwindcss init -p
npx shadcn-ui@latest init
```

Then press `enter` each time to choose the default parameters (if you are an expert, feel free to use your preferred config).

Depending on your system, you might have some differences (we love config 🙃), so I'll guide you to be sure we have the same configuration:

a. You should have an `app` folder, with a `global.css` file inside. You can move it to `src/pages/globals.css` and edit the import at the top of `_app.tsx`:

```tsx
import './globals.css';
```

b. Shadcn works by manually adding each component with the `pnpm dlx shadcn-ui@atest add <component>`, so be sure to do it for each import. Run this command to add all the components we'll use:

```bash
pnpm dlx shadcn-ui@latest add tabs button card input label popover command
```

c. You also have a folder containing two folders `components` and `lib`. You can move them under `src` —> `src/components` and `src/lib` .

d. Verify that in the `tsconfig.json` file that you have this under `compilerOptions`:

```tsx
"compilerOptions": {    
		...,
		"paths": {
      "@/*": ["./src/*"]
    }
}
```

e. Finally we can delete the empty folders (these might vary depending on your system, but you should have an empty `app` folder at least). Also, if you have both `tailwind.config.js` and `tailwind.config.ts` you should remove the useless `tailwind.config.js` file.

The configuration is finally done. You should have a project structure like this:

```bash
src
├── components
│   └── ui
│       ├── button.tsx
│       ├── card.tsx
│       ├── command.tsx
│       ├── dialog.tsx
│       ├── input.tsx
│       ├── label.tsx
│       └── popover.tsx
├── lib
│   └── utils.ts
├── pages
│   ├── _app.tsx
│   ├── globals.css
│   └── index.tsx
└── wagmi.ts
```

1. We are now ready to integrate our contracts and build the main interface! We'll do that in the `src/pages/index.tsx` file, which will be our main page. You can remove the content in this file and start from scratch.
    
    Let's start by defining an empty page with a connect button and some useful debug information. We use the `ConnectButton` from RainbowKit to handle the wallet connection, and we use the `useAccount` hook from Wagmi to get the connected account information.
    

```tsx
import type { NextPage } from 'next';
import { ConnectButton } from '@rainbow-me/rainbowkit';
import { useAccount } from 'wagmi';

const Home: NextPage = () => {
  const account = useAccount();

  return (
    <div className="bg-background w-full h-screen flex items-center justify-center">
      {/* Top right corner: Wallet information */}
      <div className="absolute top-0 right-0 p-4">
        <ConnectButton />
      </div>

      {/* Bottom left corner: Debug information */}
      <div className="absolute text-xs text-gray-500 bottom-0 left-0 p-4">
        status: {account.status}
        <br />
        address: {JSON.stringify(account.address)}
        <br />
        chainId: {account.chainId}
      </div>
    </div>
  );
};

export default Home;
```

1. You can now run `pnpm dev` and go to `http://localhost:3000/` in your browser. Try to connect your wallet; RainbowKit should automatically ask you to switch to Linea Sepolia. Verify that the `chainId` is `59141` in the debug information corner.
2. Now that we have our frontend set up, our wallet connection working and our chain set to Linea Sepolia, we can move to the next part: interacting with the contract 🥳
    
    Copy and paste this code for a simple staking card design at the top of `index.tsx`:
    
    ```tsx
    import { useEffect, useState } from "react";
    import { cn } from "@/lib/utils";
    import { Button } from "@/components/ui/button";
    import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
    import { Label } from "@/components/ui/label";
    import { Input } from "@/components/ui/input";
    import {
      Command,
      CommandEmpty,
      CommandGroup,
      CommandInput,
      CommandItem,
      CommandList,
    } from "@/components/ui/command";
    import {
      Popover,
      PopoverContent,
      PopoverTrigger,
    } from "@/components/ui/popover";
    import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
    import { Check, ChevronsUpDown } from "lucide-react";
    
    const tokens: { value: `0x${string}`; label: string }[] = [
      {
        value: "0x46871676658472B99720F2a368CDa6430c1647b9",
        label: "COFFEE",
      },
      {
        value: "0xB7D70343639aF53a02f6ea7d9cde240fc72de6Dd",
        label: "TEA",
      },
      {
        value: "0x66a6F52C2100FB82EE21FD1380b4D516CB540c93",
        label: "WATER",
      },
    ];
    
    const TokensCombobox = ({ value, setValue, disabled }: any) => {
      const [open, setOpen] = useState(false);
      return (
        <Popover open={open} onOpenChange={setOpen}>
          <PopoverTrigger asChild>
            <Button
              variant="outline"
              role="combobox"
              aria-expanded={open}
              className="w-full justify-between"
              disabled={disabled}
            >
              {value
                ? tokens.find((token) => token.value === value)?.label
                : "Select token..."}
              <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
            </Button>
          </PopoverTrigger>
          <PopoverContent className="w-full p-0">
            <Command>
              <CommandInput placeholder="Search by address..." />
              <CommandList>
                <CommandEmpty>No token found.</CommandEmpty>
                <CommandGroup>
                  {tokens.map((token) => (
                    <CommandItem
                      key={token.value}
                      value={token.value}
                      onSelect={(currentValue) => {
                        setValue(currentValue === value ? "" : currentValue);
                        setOpen(false);
                      }}
                    >
                      <Check
                        className={cn(
                          "mr-2 h-4 w-4",
                          value === token.value ? "opacity-100" : "opacity-0"
                        )}
                      />
                      {token.label}
                    </CommandItem>
                  ))}
                </CommandGroup>
              </CommandList>
            </Command>
          </PopoverContent>
        </Popover>
      );
    };
    
    const StakingCard = ({ account, disabled }: any) => {
      const [menuTab, setMenuTab] = useState<"stake" | "unstake">("stake");
      const [token, setToken] = useState<`0x${string}`>(tokens[0].value);
      const [amountToStake, setAmountToStake] = useState<number>(0);
      const [amountToUnstake, setAmountToUnstake] = useState<number>(0);
      const [amountStakable, setAmountStakable] = useState<number>(0);
      const [amountStaked, setAmountStaked] = useState<number>(0);
    
      const mockFetchAmountStakableForToken = (tokenAddress: string) => 10;
      const mockFetchAmountStakedForToken = (tokenAddress: string) => 10;
      useEffect(() => {
        const stakable = mockFetchAmountStakableForToken(token);
        const staked = mockFetchAmountStakedForToken(token);
        setAmountStakable(stakable);
        setAmountToStake(stakable);
        setAmountStaked(staked);
        setAmountToUnstake(staked);
      }, [token]);
    
      return (
        <Card className="w-full max-w-sm relative">
          {disabled && (
            <div className="z-50 backdrop-blur-[3px] rounded-lg absolute inset-0 flex items-center justify-center">
              <p className="text-md text-gray-500">
                Please connect your wallet first
              </p>
            </div>
          )}
    
          <div className="absolute text-xs text-gray-500 top-0 right-0 p-4">
            Available to stake: {amountStakable}
            <br />
            Amount staked: {amountStaked}
          </div>
    
          <CardHeader>
            <CardTitle className="text-2xl">Linea Staking</CardTitle>
          </CardHeader>
          <CardContent className="grid gap-4">
            <div className="grid gap-2">
              <Label htmlFor="targetToken">Token</Label>
              <TokensCombobox
                id="targetToken"
                value={token}
                setValue={setToken}
                disabled={disabled}
              />
            </div>
    
            <Tabs defaultValue="stake" value={menuTab}>
              <TabsList
                className="grid w-full grid-cols-2"
                hidden={amountStakable === 0 || amountStaked === 0}
              >
                <TabsTrigger
                  value="stake"
                  disabled={amountStakable === 0}
                  onClick={() => setMenuTab("stake")}
                >
                  Stake
                </TabsTrigger>
                <TabsTrigger
                  value="unstake"
                  disabled={amountStaked === 0}
                  onClick={() => setMenuTab("unstake")}
                >
                  Unstake/Withdraw
                </TabsTrigger>
              </TabsList>
    
              <TabsContent value="stake">
                <div className="grid gap-2">
                  <div className="flex w-full max-w-sm items-center space-x-2">
                    <Input
                      id="amountToStake"
                      value={amountToStake}
                      onChange={(e) => {
                        const value = Math.min(
                          Number(e.target.value),
                          amountStakable
                        );
                        setAmountToStake(value);
                      }}
                      disabled={disabled || amountStakable === 0}
                      type="number"
                    />
                    <Button
                      type="submit"
                      variant="secondary"
                      onClick={() => setAmountToStake(amountStakable)}
                    >
                      Max
                    </Button>
                  </div>
                </div>
                <Button
                  className="w-full mt-4"
                  onClick={() => {}}
                  disabled={disabled || amountStakable === 0}
                >
                  Stake
                </Button>
              </TabsContent>
    
              <TabsContent value="unstake">
                <div className="grid gap-2">
                  <div className="flex w-full max-w-sm items-center space-x-2">
                    <Input
                      id="amountToUnstake"
                      value={amountToUnstake}
                      onChange={(e) => {
                        const value = Math.min(
                          Number(e.target.value),
                          amountStaked
                        );
                        setAmountToUnstake(value);
                      }}
                      disabled={disabled || amountStaked === 0}
                      type="number"
                    />
                    <Button
                      type="submit"
                      variant="secondary"
                      onClick={() => setAmountToUnstake(amountStaked)}
                    >
                      Max
                    </Button>
                  </div>
                </div>
                <Button
                  className="w-full mt-4"
                  onClick={() => {}}
                  disabled={disabled || amountStaked === 0}
                >
                  Unstake
                </Button>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      );
    };
    ```
    
    We'll not explain this code much as it's mostly React state management. We define the list of tokens as a constant to simplify. The `StakingCard` component handles all the token selection and inputs as well. 
    
    We can then add it to the page (in React, it means you have to put this code in `return( ... )`):
    
    ```tsx
    {/* Main content */}
    <StakingCard
      account={account}
      disabled={account.status !== "connected"}
    />
    ```
    
3. For now, nothing is connected to the blockchain. Note that the `mockFetchAmountStakableForToken` and `mockFetchAmountStakedForToken`  functions just return a constant. We will use the `useReadContracts` hook for this purpose. We are also using `useWatchBlockNumber` to reread the state on each new block.
    
    Before doing that, let's create an `abi.json` file in `src/pages` and paste the ABI from the smart contract (step 5 from the first part if you lost the file).
    
4. You need to define the contract address and ABI:

```tsx
import { useAccount, useReadContracts, useWatchBlockNumber } from "wagmi";
import { erc20Abi } from 'viem'
import CONTRACT_ABI from "./abi.json";
const CONTRACT_ADDRESS = "0xe5fac868B1d0E4d119A09cC7253E2D7a3cb250da;
```

1. Now you can remove the previous mock part with this new one:

```tsx
const mockFetchAmountStakableForToken = (tokenAddress: string) => 10;
const mockFetchAmountStakedForToken = (tokenAddress: string) => 10;
useEffect(() => {
  const stakable = mockFetchAmountStakableForToken(token);
  const staked = mockFetchAmountStakedForToken(token);
  setAmountStakable(stakable);
  setAmountToStake(stakable);
  setAmountStaked(staked);
  setAmountToUnstake(staked);
}, [token]);

const [blockNumber, setBlockNumber] = useState<bigint>(BigInt(0));
  useWatchBlockNumber({
    onBlockNumber(blockNumber) {
      setBlockNumber(blockNumber);
    },
  })

const { data, isSuccess, isLoading } = useReadContracts({
	allowFailure: false,
	blockNumber,
	contracts: [
	  // Token decimals
	  {
	    address: token,
	    abi: erc20Abi,
	    functionName: "decimals",
	  },
	  // Stakable
	  {
	    address: token,
	    abi: erc20Abi,
	    functionName: "balanceOf",
	    args: [account.address],
	  },
	  // Staked
	  {
	    address: CONTRACT_ADDRESS,
	    abi: CONTRACT_ABI,
	    functionName: "stakedBalances",
      args: [account.address, token],
	  },
		//Allowance
    {
      address: token,
      abi: erc20Abi,
      functionName: "allowance",
      args: [account.address, CONTRACT_ADDRESS],
    },
	],
});

useEffect(() => {
	if (isSuccess) {
	  const decimals = data?.[0] ?? 18;
	  const stakable = Number((data?.[1] as bigint) ?? 0) / 10 ** decimals;
	  const staked = Number((data?.[2] as bigint) ?? 0) / 10 ** decimals;
	  setAmountStakable(stakable);
	  setAmountStaked(staked);
	}
}, [data]);

useEffect(() => {
      setAmountToStake(0);
      setAmountToUnstake(0);
  }, [token])
```

- Optional animation:
    
    We can use the `isLoading` boolean to add animation while fetching values for the two inputs, "Stake" and "Unstake":
    
    ```tsx
    <Input
      id="amountToUnstake"
      value={amountToUnstake}
      className={isLoading ? " animate-pulse" : ""}
      onChange={(e) => {
        const value = Math.min(
          Number(e.target.value),
          amountStaked
        );
        setAmountToUnstake(value);
      }}
      disabled={disabled || amountStaked === 0}
      type="number"
    />
    ```
    

If you choose a token on your dapp now, the frontend should automatically fetch the token decimals, available balances, and staked balances. 

1. Finally, we will handle the deposit and withdraw transactions! In this last part, we will need to prepare and send a transaction. We will use the `useWriteContract` hook.

```tsx
import { useAccount, useReadContracts, useWriteContract } from "wagmi";
import { Check, ChevronsUpDown, Loader2 } from "lucide-react";

// ...

// StakingCard:
const { writeContract, isPending } = useWriteContract();

return (
	//...
	
  <Button
    className="w-full mt-4"
    onClick={() => {}}
    disabled={disabled || amountStakable === 0}
  >
    Stake
  </Button>
{(data?.[3] ?? 0) < amountToStake * 10 ** (data?.[0] ?? 18) ? (
  <Button
    className="w-full mt-4"
    onClick={() =>
      writeContract({
        abi: erc20Abi,
        address: token,
        functionName: "approve",
        args: [
          CONTRACT_ADDRESS,
          BigInt(amountToStake * 10 ** (data?.[0] ?? 18)),
        ],
      })
    }
    disabled={disabled || amountStakable === 0 || isPending}
  >
    {isPending ? (
      <Loader2 className="animate-spin" />
    ) : (
      <p>Approve</p>
    )}
  </Button>
) : (
  <Button
    className="w-full mt-4"
    onClick={() =>
      writeContract({
        abi: CONTRACT_ABI,
        address: CONTRACT_ADDRESS,
        functionName: "stake",
        args: [token, amountToStake * 10 ** (data?.[0] ?? 18)],
      })
    }
    disabled={disabled || amountStakable === 0 || isPending}
  >
    {isPending ? (
      <Loader2 className="animate-spin" />
    ) : (
      <p>Stake</p>
    )}
  </Button>
)}
  
	//...
	
  <Button
    className="w-full mt-4"
    onClick={() => {}}
    disabled={disabled || amountStaked === 0}
  >
    Unstake
  </Button>
  <Button
    className="w-full mt-4"
    onClick={() =>
      writeContract({
        abi: CONTRACT_ABI,
        address: CONTRACT_ADDRESS,
        functionName: "withdraw",
        args: [token, amountToUnstake * 10 ** (data?.[0] ?? 18)],
      })
    }
    disabled={disabled || amountStaked === 0 || isPending}
  >
    {isPending ? <Loader2 className="animate-spin" /> : <p>Unstake</p>}
  </Button>
  
	//...
)
```

And voilà! 🎉 You should be able to easily stake and unstake from the list of allowlisted tokens.

This frontend part only demonstrated read and write operations. Most Wagmi hooks return lots of data such as `isLoading` or `error`, which are useful for building reactive and beautiful frontends, so be sure to check the documentation. We also omit error handling here for simplicity.

Lastly, we can listen for events to dynamically update the frontend. I'll leave this to you as an optional exercise if you want to go further (hint: you can use `watchContractEvent`(https://wagmi.sh/core/api/actions/watchContractEvent) or `watchAsset`(https://wagmi.sh/core/api/actions/watchAsset))

---

I hope you enjoyed following this tutorial about how to create a simple staking contract on Linea 🧑‍💻 See you soon for a new one!

Gwen, DevRel @Consensys

Find more content about Linea on my X: [https://x.com/Gwenole_M](https://x.com/Gwenole_M)

## Additional resources

[Solidity by Example](https://solidity-by-example.org/): very useful website when creating smart contracts

[Linea Discord](https://discord.gg/linea): to contact the team if you need more help

Also, check the [full codebase on GitHub](https://github.com/Gwen-M/linea-first-dapp)


==================== FILE: /workspace/docs/learn/aiagent-quickstart.mdx ====================

---
title: Build an AI agent
description: A quickstart guide to building a simple AI agent on Linea.
image: /img/socialCards/build-an-ai-agent.jpg
---

ElizaOS is an open-source framework for creating AI agents that interact with blockchain networks. This tutorial will guide you through setting up an AI agent on the **Linea blockchain** using ElizaOS. By the end, your agent will be able to execute smart contract transactions and interact with the blockchain autonomously. You’ll be able to add any custom action to improve it and make it the best agent in town.

### Prerequisites

- Install [Node.js](https://nodejs.org/) (23.3) and [pnpm](https://pnpm.io/).
- Basic knowledge of **TypeScript** and **blockchain concepts**.
- Access to a Linea RPC endpoint and a funded Ethereum wallet for testing. We strongly recommend you use a development wallet. Stay safe!

---

## 1. Set up the environment

To start, we want to clone the main ElizaOS repo, there’s also a starter-kit if you prefer but I recommend you to use the full package:

```bash
git clone https://github.com/elizaOS/eliza.git # Starter kit: eliza-starter.git
cd eliza # Starter kit : eliza-starter
```

This sets up the framework on your local machine. ElizaOS is iterating fast, so a few things might have changed if you’re following this tutorial a long time after its publication.

Be sure you’re using the right version of Node. If you get an error message, it can help to start again with a clean Node modules installation. 

Then, you need to checkout to the latest version of ElizaOS:

```bash
git checkout $(git describe --tags --abbrev=0)
# If the above doesn't checkout the latest release, this should work:
# git checkout $(git describe --tags `git rev-list --tags --max-count=1`)

pnpm install
```

Installation can take time, so relax and go grab a drink ☕

---

## 2. Configure the AI agent for Linea

ElizaOS uses environment variables stored in a `.env` file to manage configurations, including blockchain settings.

### Set up the `.env` file

Copy the `.env.example` file in a `.env` file in the root directory and configure it as follows:

```
# Blockchain Connection
EVM_RPC_URL=https://rpc.linea.build
EVM_PRIVATE_KEY=your_private_key_here
```

Replace `your_private_key_here` with your Ethereum **development** private key. Be sure to keep this key private and do not reuse it to store funds.

We’ll also need a `modelProvider` (unless you feel comfortable running a local model on your computer; it can be quite slow depending on your computer's performance). You can add your API key in the `.env` file, depending on which provider you’ll use (OpenAI, Anthropic, Gaia, etc.). Some `modelProvider`s provide different options, such as enabling you to choose a specific model for certain actions. 

### Install the EVM plugin

We’ll use the [EVM Plugin](https://github.com/elizaOS/eliza/blob/main/packages/docs/packages/plugins/evm.md) to interact with the Linea blockchain.

If you used the main repository, it should already be installed, otherwise, you need to install it:

```bash
pnpm add @elizaos/plugin-evm
```

Then, configure the plugin in your character settings.

ElizaOS uses some “characters” files that define your agent's personality. You can create one or choose a preconfigured one in the characters folder.

At the top of the file, you'll need to add the following:

```json
{
	...,
	"modelProvider": "your_provider_name", //eg. openai
	"settings": {
		"chains": {
			"evm": [ "lineaSepolia" ]
		}
	},
	"plugins": ["@elizaos/plugin-evm"],
	...
}
```

This will allow you to use all the actions in the EVM plugin and configure your AI agent to use your provider.

## 3. How it works

If you check the `/plugin-evm` folder, you’ll see different types of files:

### Actions files

They define actions that can be performed by the agent.

```tsx title="actions/transfer.ts"
import { type ByteArray, formatEther, parseEther, type Hex } from "viem";
import {
    type Action,
    composeContext,
    generateObjectDeprecated,
    type HandlerCallback,
    ModelClass,
    type IAgentRuntime,
    type Memory,
    type State,
} from "@elizaos/core";

import { initWalletProvider, type WalletProvider } from "../providers/wallet";
import type { Transaction, TransferParams } from "../types";
import { transferTemplate } from "../templates";

// Exported for tests
export class TransferAction {
    constructor(private walletProvider: WalletProvider) {}

    async transfer(params: TransferParams): Promise<Transaction> {
        console.log(
            `Transferring: ${params.amount} tokens to (${params.toAddress} on ${params.fromChain})`
        );

        if (!params.data) {
            params.data = "0x";
        }

        this.walletProvider.switchChain(params.fromChain);

        const walletClient = this.walletProvider.getWalletClient(
            params.fromChain
        );

        try {
            const hash = await walletClient.sendTransaction({
                account: walletClient.account,
                to: params.toAddress,
                value: parseEther(params.amount),
                data: params.data as Hex,
                kzg: {
                    blobToKzgCommitment: (_: ByteArray): ByteArray => {
                        throw new Error("Function not implemented.");
                    },
                    computeBlobKzgProof: (
                        _blob: ByteArray,
                        _commitment: ByteArray
                    ): ByteArray => {
                        throw new Error("Function not implemented.");
                    },
                },
                chain: undefined,
            });

            return {
                hash,
                from: walletClient.account.address,
                to: params.toAddress,
                value: parseEther(params.amount),
                data: params.data as Hex,
            };
        } catch (error) {
            throw new Error(`Transfer failed: ${error.message}`);
        }
    }
}

const buildTransferDetails = async (
    state: State,
    runtime: IAgentRuntime,
    wp: WalletProvider
): Promise<TransferParams> => {
    const chains = Object.keys(wp.chains);
    state.supportedChains = chains.map((item) => `"${item}"`).join("|");

    const context = composeContext({
        state,
        template: transferTemplate,
    });

    const transferDetails = (await generateObjectDeprecated({
        runtime,
        context,
        modelClass: ModelClass.SMALL,
    })) as TransferParams;

    const existingChain = wp.chains[transferDetails.fromChain];

    if (!existingChain) {
        throw new Error(
            "The chain " +
                transferDetails.fromChain +
                " not configured yet. Add the chain or choose one from configured: " +
                chains.toString()
        );
    }

    return transferDetails;
};

export const transferAction: Action = {
    name: "transfer",
    description: "Transfer tokens between addresses on the same chain",
    handler: async (
        runtime: IAgentRuntime,
        message: Memory,
        state: State,
        _options: any,
        callback?: HandlerCallback
    ) => {
        if (!state) {
            state = (await runtime.composeState(message)) as State;
        } else {
            state = await runtime.updateRecentMessageState(state);
        }

        console.log("Transfer action handler called");
        const walletProvider = await initWalletProvider(runtime);
        const action = new TransferAction(walletProvider);

        // Compose transfer context
        const paramOptions = await buildTransferDetails(
            state,
            runtime,
            walletProvider
        );

        try {
            const transferResp = await action.transfer(paramOptions);
            if (callback) {
                callback({
                    text: `Successfully transferred ${paramOptions.amount} tokens to ${paramOptions.toAddress}\nTransaction Hash: ${transferResp.hash}`,
                    content: {
                        success: true,
                        hash: transferResp.hash,
                        amount: formatEther(transferResp.value),
                        recipient: transferResp.to,
                        chain: paramOptions.fromChain,
                    },
                });
            }
            return true;
        } catch (error) {
            console.error("Error during token transfer:", error);
            if (callback) {
                callback({
                    text: `Error transferring tokens: ${error.message}`,
                    content: { error: error.message },
                });
            }
            return false;
        }
    },
    validate: async (runtime: IAgentRuntime) => {
        const privateKey = runtime.getSetting("EVM_PRIVATE_KEY");
        return typeof privateKey === "string" && privateKey.startsWith("0x");
    },
    examples: [
        [
            {
                user: "assistant",
                content: {
                    text: "I'll help you transfer 1 ETH to 0x9FA746b844747f77c6C54F4f88ab71048c608864",
                    action: "SEND_TOKENS",
                },
            },
            {
                user: "user",
                content: {
                    text: "Transfer 1 ETH to 0x9FA746b844747f77c6C54F4f88ab71048c608864",
                    action: "SEND_TOKENS",
                },
            },
        ],
    ],
    similes: ["SEND_TOKENS", "TOKEN_TRANSFER", "MOVE_TOKENS"],
};

```

### Contracts artifacts and sources

If you want to allow your agent to deploy new contracts or interact with existing contracts, you can put them in this folder to be able to refer to the ABI in your actions files.

### Providers

Contains wallet providers files. You can modify these to use AA wallets, for example, or connect your agent with an MPC provider.

### Templates

A very important section: every time you send a prompt to the agent, it’ll try to determine if you’re trying to perform an action, then use the template for this action. 

Here's the transfer template:

```tsx
export const transferTemplate = `You are an AI assistant specialized in processing cryptocurrency transfer requests. Your task is to extract specific information from user messages and format it into a structured JSON response.

First, review the recent messages from the conversation:

<recent_messages>
{{recentMessages}}
</recent_messages>

Here's a list of supported chains:
<supported_chains>
{{supportedChains}}
</supported_chains>

Your goal is to extract the following information about the requested transfer:
1. Chain to execute on (must be one of the supported chains)
2. Amount to transfer (in ETH, without the coin symbol)
3. Recipient address (must be a valid Ethereum address)
4. Token symbol or address (if not a native token transfer)

Before providing the final JSON output, show your reasoning process inside <analysis> tags. Follow these steps:

1. Identify the relevant information from the user's message:
   - Quote the part of the message mentioning the chain.
   - Quote the part mentioning the amount.
   - Quote the part mentioning the recipient address.
   - Quote the part mentioning the token (if any).

2. Validate each piece of information:
   - Chain: List all supported chains and check if the mentioned chain is in the list.
   - Amount: Attempt to convert the amount to a number to verify it's valid.
   - Address: Check that it starts with "0x" and count the number of characters (should be 42).
   - Token: Note whether it's a native transfer or if a specific token is mentioned.

3. If any information is missing or invalid, prepare an appropriate error message.

4. If all information is valid, summarize your findings.

5. Prepare the JSON structure based on your analysis.

After your analysis, provide the final output in a JSON markdown block. All fields except 'token' are required. The JSON should have this structure:

\`\`\`json
{
    "fromChain": string,
    "amount": string,
    "toAddress": string,
    "token": string | null
}
\`\`\`

Remember:
- The chain name must be a string and must exactly match one of the supported chains.
- The amount should be a string representing the number without any currency symbol.
- The recipient address must be a valid Ethereum address starting with "0x".
- If no specific token is mentioned (i.e., it's a native token transfer), set the "token" field to null.

Now, process the user's request and provide your response.
`;
```

---

## 4. Run the AI agent

Start the agent with:

```bash
pnpm build
pnpm start --character-"characters/yourcharactername.character.json"
```

You’ll also want to start the web interface, so you can chat with your agent:

```bash
pnpm start:client
```

The interface is available by default on `localhost:5173`. If you want to interact with multiple agents, launch them on different ports.

And you’re good to go!

You can ask your agent to send some ETH to another address or bridge a token from one chain to another (though for that, you’ll need to add more chains in your configuration). By default, the agent will need the exact name of the chain, e.g.:

```bash
Send 1 ETH to 0x9FA746b844747f77c6C54F4f88ab71048c608864 on lineaSepolia
```

You can modify this by changing the templates in the EVM plugin.

---

In this introductory tutorial, you learned how to use ElizaOS to create an AI agent that is able to send transactions on Linea and interact with contracts.

There’s much much more you can do with ElizaOS. The framework is evolving very fast, so be ready to devote plenty of time if you plan to explore it further.

For more details, explore the [ElizaOS documentation](https://github.com/elizaOS/eliza). Happy building!


==================== FILE: /workspace/docs/learn/marketplace-dapp.mdx ====================

---
title: Build a marketplace dapp
description: A step-by-step guide to building a simple marketplace dapp on Linea.
image: /img/socialCards/build-a-marketplace-dapp.jpg
---

Decentralized marketplaces are one of the most popular types of web3 dapps, and enable users to 
buy and sell items directly on the blockchain while removing the need for any intermediaries.

In this tutorial, we will build a simple marketplace dapp. 

We will cover both the **frontend** and **smart contract development.**

## Architecture

Let's dive into the architecture of the marketplace dapp and its components.

The marketplace will incorporate smart contracts, a frontend, and blockchain integration. The smart 
contract will include features such as listing items, buying items, and transferring ownership of 
an item.

The frontend serves as the user interface where buyers and sellers can interact with each other 
using the smart contract. While having a frontend and backend is important, the way the dapp 
interacts with the Linea blockchain is also crucial. We will be using the MetaMask SDK along with 
Wagmi and Infura RPC providers.

### Set up the environment

We will start by initializing a monorepo. A monorepo (short for monolithic repository) is a software 
development strategy where code for multiple projects is stored in a single version control repository.

To create our monorepo, we'll use pnpm.
 
Create a new directory for your monorepo and initialize it:

```
mkdir web3-marketplace-linea
cd web3-marketplace-linea
pnpm init

```

Create a `pnpm-workspace.yaml` file in the root to define your workspace structure:

```yaml
packages:
  - 'packages/*'
```

Here's what our workspace file structure will be like:

```
packages
├── site          # Frontend built with Next.js, Tailwind CSS, and Shadcn UI
└── blockchain    # Smart contracts using Hardhat
```

Let's head over to the `blockchain` directory and initialize a Hardhat project.

```
cd blockchain
npx hardhat init
```

You'll be presented with several options:

```
? What do you want to do? …
❯ Create a JavaScript project
  Create a TypeScript project
  Create a TypeScript project (with Viem)
  Create an empty hardhat.config.js
  Quit
```

For this tutorial we'll be using a TypeScript project. Hardhat will automatically install the 
necessary dependencies for you.

### Project structure

After initialization, you'll have a project structure that includes:

- **`contracts/`**: Solidity contracts
- **`ignition/`**: Ignition deployment modules
- **`test/`**: Test files
- **`hardhat.config.js`**: Hardhat configuration

### Write the smart contract

Let's start writing the smart contract:

```jsx
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/// @title Marketplace
/// @notice A simple marketplace contract for listing, purchasing, and transferring items
/// @dev This contract manages items, their ownership, and transactions
contract Marketplace {
    /// @notice Structure to represent an item in the marketplace
    /// @dev Each item has a unique ID, name, price, seller, owner, and sale status
    struct Item {
        uint id;
        string name;
        uint price;
        address payable seller;
        address owner;
        bool isSold;
    }

    /// @notice Total number of items listed in the marketplace
    uint public itemCount = 0;

    /// @notice Mapping of item IDs to Item structs
    mapping(uint => Item) public items;

    /// @notice Mapping of owner addresses to arrays of owned item IDs
    mapping(address => uint[]) public ownedItems;

    /// @notice Lists a new item in the marketplace
    /// @param _name The name of the item
    /// @param _price The price of the item in wei
    /// @dev Increments itemCount and adds the new item to the items mapping
    function listItem(string memory _name, uint _price) public {
        require(_price > 0, "Price must be greater than zero");

        itemCount++;
        items[itemCount] = Item(itemCount, _name, _price, payable(msg.sender), msg.sender, false);
        ownedItems[msg.sender].push(itemCount);
    }

    /// @notice Allows a user to purchase an item
    /// @param _id The ID of the item to purchase
    /// @dev Transfers the item's price to the seller and updates ownership
    function purchaseItem(uint _id) public payable {
        Item storage item = items[_id];
        require(_id > 0 && _id <= itemCount, "Item does not exist");
        require(msg.value == item.price, "Incorrect price");
        require(!item.isSold, "Item already sold");
        require(msg.sender != item.seller, "Seller cannot buy their own item");

        item.isSold = true;
        item.seller.transfer(msg.value);

        // Transfer ownership
        _transferOwnership(_id, item.seller, msg.sender);
    }

    /// @notice Internal function to transfer ownership of an item
    /// @param _id The ID of the item
    /// @param _from The current owner's address
    /// @param _to The new owner's address
    /// @dev Updates the item's owner and adjusts the ownedItems mappings
    function _transferOwnership(uint _id, address _from, address _to) internal {
        Item storage item = items[_id];
        item.owner = _to;

        // Remove item from the previous owner's list
        uint[] storage fromItems = ownedItems[_from];
        for (uint i = 0; i < fromItems.length; i++) {
            if (fromItems[i] == _id) {
                fromItems[i] = fromItems[fromItems.length - 1];
                fromItems.pop();
                break;
            }
        }

        // Add item to the new owner's list
        ownedItems[_to].push(_id);
    }

    /// @notice Allows the owner to transfer an item to another address
    /// @param _id The ID of the item to transfer
    /// @param _to The address of the recipient
    /// @dev Calls the internal _transferOwnership function
    function transferItem(uint _id, address _to) public {
        Item storage item = items[_id];
        require(_id > 0 && _id <= itemCount, "Item does not exist");
        require(msg.sender == item.owner, "You do not own this item");

        _transferOwnership(_id, msg.sender, _to);
    }

    /// @notice Retrieves all item IDs owned by a specific address
    /// @param _owner The address of the owner
    /// @return An array of item IDs owned by the specified address
    function getItemsByOwner(address _owner) public view returns (uint[] memory) {
        return ownedItems[_owner];
    }
}
```

This contract provides a basic framework for a decentralized marketplace where users can list items 
for sale, purchase items, and transfer ownership of items. It maintains a record of item ownership 
and ensures that only valid transactions can occur. Let's explore the concept of the smart contract 
a bit more:

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/marketplace/marketplace-contract.png"
      alt=""
    />
  </div>
</div>

1. **Seller**:
    - **Listing an item**:
        - Sellers can list items for sale by calling the `listItem` function.
        - This function requires a name and price for the item.
        - The item is added to the marketplace with a unique ID, and the seller is recorded as the 
        owner.
2. **Buyer**:
    - **Purchasing an item**:
        - Buyers can purchase items using the `purchaseItem` function.
        - The function checks that the item exists, the price is correct, and that the item is not 
        already sold.
        - The payment is transferred to the seller, and ownership of the item is updated.
3. **Transferring ownership**:
    - **Ownership transfer**:
        - The `_transferOwnership` function handles the internal logic for transferring item ownership.
        - It updates the owner in the `items` mapping and adjusts the `ownedItems` lists for both 
        the previous and new owners.
    - **Manual transfer**:
        - The `transferItem` function allows current owners to transfer their items to another address.
        - It ensures the sender is the current owner before calling the `_transferOwnership` function.
4. **Retrieving owned items**:
    - **Get items by owner**:
        - The `getItemsByOwner` function returns a list of item IDs owned by a specific address.

This smart contract facilitates a decentralized marketplace where items can be listed, purchased, 
and transferred securely, with all transactions and ownership changes recorded on the blockchain.

In the `ignition` folder, let's create `Marketplace.ts`  to deploy our contract. Add the following code:

```jsx
import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";

const MarketplaceModule = buildModule("MarketplaceModule", (m) => {
  // Deploy the Marketplace contract
  const marketplace = m.contract("Marketplace");

  // Return the deployed contract instance
  return { marketplace };
});

export default MarketplaceModule;
```

To compile the contract, run the following command:

```
npx hardhat compile
```

### `.env` variables

Before deploying the smart contract, make sure to update the `.env` file in the `packages/blockchain` 
directory with the following values:

```bash
# Infura API key for connecting to Ethereum networks
INFURA_API_KEY=your_infura_api_key_here

# Private key of the account to be used for deployments and transactions
ACCOUNT_PRIVATE_KEY=your_account_private_key_here
```

### Deploy the smart contract

To deploy the smart contract to the Linea testnet, run the following command:

```bash
npx hardhat ignition deploy ignition/modules/Marketplace.ts --network linea-testnet
```

This will deploy the marketplace smart contract on Linea Sepolia. You can always write a script to 
deploy quicker by writing small commands like this on `package.json` file:

```jsx
"deploy:testnet": "npx hardhat ignition deploy ignition/modules/Marketplace.ts --network linea-testnet"
```

After the deployment we'll get the `contract address` — make a note of this. We will need it soon 
while integrating with the frontend. 

## Frontend: Next.js with Shadcn UI

### Create and navigate to the project directory

```bash
mkdir site
cd site
```

### Initialize Next.js project

```bash
npx create-next-app@latest .
```

When prompted, choose the following options:

- TypeScript: Yes
- ESLint: Yes
- Tailwind CSS: Yes
- `src/` directory: No (or Yes, if you prefer)
- App Router: Yes
- Import alias: Yes (default @/*)

### Install Shadcn UI CLI

```bash
npx shadcn-ui@latest init
```

Install the necessary UI components like buttons, cards, and input fields as needed.

Create a `wagmi.config.ts` and add the following code:

```jsx
import { http, createConfig } from "wagmi";
import { lineaSepolia } from "wagmi/chains";
import { metaMask } from "wagmi/connectors";

export const config = createConfig({
  chains: [lineaSepolia],
  connectors: [metaMask()],
  transports: {
    [lineaSepolia.id]: http(),
  },
});
```

We will be using Wagmi and the MetaMask SDK to connect our wallet and make transactions. All that is 
left now is to create a `ConnectWallet.tsx` UI component.

On the `site/src` directory let's create a file called `constants.ts` and add the following:

```jsx
export const CONTRACT_ADDRESS = //paste deployed contract here
export const ABI = 
  // Paste the ABI here
```

Remember the deployed contract address that you saved earlier? We'll add it here. Head over to the 
`blockchain/ignition` module and find the `artifacts` folder to find the ABI.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/marketplace/marketplace-ui.png"
      alt=""
    />
  </div>
</div>

Let's break down the code in `app.tsx` and explain its key aspects in more detail:

## React and hooks usage

```jsx
import { useState, useEffect } from "react";
import { useAccount, useWalletClient } from "wagmi";
```

- The component uses React's `useState` for local state management and `useEffect` for side effects.
- It also uses custom hooks from `wagmi` (`useAccount` and `useWalletClient`) for blockchain wallet 
integration.

## State management

```jsx
const [items, setItems] = useState<any[]>([]);
const [ownedItems, setOwnedItems] = useState<any[]>([]);
const [newItemName, setNewItemName] = useState("");
const [newItemPrice, setNewItemPrice] = useState("");
```

- Multiple state variables are defined to manage the component's data.
- `items` and `ownedItems` are arrays to store marketplace items.
- `newItemName` and `newItemPrice` are for form inputs when listing a new item.

## `useEffect` for data loading

```jsx
useEffect(() => {
  loadItems();
  loadOwnedItems();
}, []);
```

- This effect runs once when the component mounts.
- It calls `loadItems()` and `loadOwnedItems()` to populate the state with data from the blockchain.

## Smart contract interaction

```jsx
const loadItems = async () => {
  try {
    const itemCount = await client.readContract({
      address: CONTRACT_ADDRESS,
      abi: ABI_STRING_ARRAY,
      functionName: "itemCount",
    });
    // ... (fetching individual items)
  } catch (error) {
    console.error("Error loading items:", error);
  }
};
```

- This function reads data from the smart contract using `client.readContract`.
- It first gets the total item count, then fetches details for each item.

## Writing to the blockchain

```jsx
const listItem = async () => {
  try {
    if (!walletClient) return;
    const { request } = await client.simulateContract({
      // ... contract call details
    });
    await walletClient.writeContract(request);
    loadItems();
  } catch (error) {
    console.error("Error listing item:", error);
  }
};
```

- This function writes data to the blockchain (listing a new item).
- It first simulates the contract call, then uses `walletClient.writeContract` to execute the transaction.

## UI components and styling

```jsx
<Card className="p-4 sm:p-6" key={index}>
  <li key={item.id} className=" p-4">
    <p><strong>Name:</strong> {item.name}</p>
    {/* ... other item details */}
    <Button
      variant="outline"
      onClick={() => purchaseItem(item.id, item.price)}
      className="border-2 border-green-500 text-green-500 hover:bg-green-500 hover:text-white py-2 px-4 rounded  duration-200 hover:shadow-xl"
    >
      Purchase
    </Button>
  </li>
</Card>
```

- The component uses custom UI components like `Card` and `Button`.
- Tailwind CSS classes are used for styling (`className` props).
- Conditional rendering is used to show/hide the purchase button based on item status and ownership.

## Form handling

```jsx
<Input
  type="text"
  placeholder="Item Name"
  value={newItemName}
  onChange={(e) => setNewItemName(e.target.value)}
  className="border p-2 flex-1"
/>
```

- Controlled inputs are used for the form fields.
- The `value` and `onChange` props connect the input to the component's state.

## Error handling

```jsx
try {
  // ... contract interaction
} catch (error) {
  console.error("Error loading items:", error);
}
```

- Try-catch blocks are used throughout the code to handle potential errors in asynchronous operations, 
especially during blockchain interactions.

The `app.tsx` can become quite large so we can also refactor the code in`site/src/app/components/` 
directory.

```
/components
  - ListItem.tsx
  - AvailableItems.tsx
  - OwnedItems.tsx
/hooks
  - useItems.ts
```

View the [full code](https://github.com/meowyx/web3-marketplace-linea/blob/code-refactor/packages/site/src/app/page.tsx).

You can also view the [refactored code](https://github.com/meowyx/web3-marketplace-linea/tree/code-refactor/packages/site/src/app).

This component demonstrates advanced React patterns, integration with blockchain technology, and 
modern UI practices. It showcases how to build a decentralized application frontend that interacts 
with a smart contract while providing a user-friendly interface.

### Run the development server

```bash
npm run dev
```

Your Next.js application with Shadcn UI should now be running at `http://localhost:3000`.

<div class="center-container">
  <div class="img-large">
    <img
      src="/img/marketplace/marketplace-dapp.png"
      alt=""
    />
  </div>
</div>

Now we should be able to list an item, buy and sell, and transfer ownership.

In this guide, we built a simple decentralized marketplace DApp on Linea, leveraging zkEVM technology 
for scalability and cost efficiency. We covered everything from setting up the environment to writing and deploying smart contracts, and integrating the frontend with Next.js and ShadcnUI.

Now you have your simple decentralized marketplace dapp! You can explore further options and expand
on this base with enhancements such as optimizing the user experience with additional features, or
enabling bidding on items, auctions etc. The possibilities of dapps are endless.

Happy coding!

## Resources:

- GitHub repository: https://github.com/meowyx/web3-marketplace-linea
- Deployed site: https://web3-marketplace-linea.vercel.app/


